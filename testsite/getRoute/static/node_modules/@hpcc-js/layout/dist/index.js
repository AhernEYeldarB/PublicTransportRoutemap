(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@hpcc-js/common'), require('@hpcc-js/dgrid'), require('@hpcc-js/api')) :
    typeof define === 'function' && define.amd ? define(['exports', '@hpcc-js/common', '@hpcc-js/dgrid', '@hpcc-js/api'], factory) :
    (global = global || self, factory(global['@hpcc-js/layout'] = {}, global['@hpcc-js/common'], global['@hpcc-js/dgrid'], global['@hpcc-js/api']));
}(this, function (exports, common, dgrid, api) { 'use strict';

    var PKG_NAME = "@hpcc-js/layout";
    var PKG_VERSION = "2.15.1";
    var BUILD_VERSION = "2.10.1";

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function styleInject(css, ref) {
      if ( ref === void 0 ) ref = {};
      var insertAt = ref.insertAt;

      if (!css || typeof document === 'undefined') { return; }

      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';

      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css = ".layout_AbsoluteSurface{pointer-events:none!important}.layout_AbsoluteSurface>.placeholder{position:relative;overflow:hidden;pointer-events:all}";
    styleInject(css);

    var AbsoluteSurface = /** @class */ (function (_super) {
        __extends(AbsoluteSurface, _super);
        function AbsoluteSurface() {
            var _this = _super.call(this) || this;
            _this._tag = "div";
            return _this;
        }
        AbsoluteSurface.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
        };
        AbsoluteSurface.prototype.update = function (domNode, element) {
            _super.prototype.update.call(this, domNode, element);
            var xPos = 0;
            var yPos = 0;
            var width = this.clientWidth();
            var height = this.clientHeight();
            switch (this.units()) {
                case "pixels":
                    xPos = this.widgetX();
                    yPos = this.widgetY();
                    width = this.widgetWidth() === "" ? width - xPos : Number(this.widgetWidth());
                    height = this.widgetHeight() === "" ? height - yPos : Number(this.widgetHeight());
                    break;
                case "percent":
                    xPos = this.widgetX() * width / 100;
                    yPos = this.widgetY() * height / 100;
                    width = this.widgetWidth() === "" ? width - xPos : Number(this.widgetWidth()) * width / 100;
                    height = this.widgetHeight() === "" ? height - yPos : Number(this.widgetHeight()) * height / 100;
                    break;
            }
            element.style("opacity", this.opacity());
            var widgets = element.selectAll("#" + this._id + " > .placeholder").data(this.widget() ? [this.widget()] : [], function (d) { return d._id; });
            widgets.enter().append("div")
                .attr("class", "placeholder")
                .each(function (d) {
                d.target(this);
            })
                .merge(widgets)
                .style("left", xPos + "px")
                .style("top", yPos + "px")
                .style("width", width + "px")
                .style("bottom", height + "px")
                .each(function (d) {
                d
                    .resize({ width: width, height: height });
            });
            widgets.exit().each(function (d) {
                d.target(null);
            }).remove();
        };
        AbsoluteSurface.prototype.exit = function (domNode, element) {
            if (this.widget()) {
                this.widget().target(null);
            }
            _super.prototype.exit.call(this, domNode, element);
        };
        return AbsoluteSurface;
    }(common.HTMLWidget));
    AbsoluteSurface.prototype._class += " layout_AbsoluteSurface";
    AbsoluteSurface.prototype.publish("units", "percent", "set", "Units", ["pixels", "percent"]);
    AbsoluteSurface.prototype.publish("widgetX", 0, "number", "Widget XPos");
    AbsoluteSurface.prototype.publish("widgetY", 0, "number", "Widget YPos");
    AbsoluteSurface.prototype.publish("widgetWidth", "100", "string", "Widget Width, omit for full");
    AbsoluteSurface.prototype.publish("widgetHeight", "100", "string", "Widget Height, omit for full");
    AbsoluteSurface.prototype.publish("widget", null, "widget", "Widget", null, { tags: ["Private"] });
    AbsoluteSurface.prototype.publish("opacity", 1, "number", "Opacity");

    var css$1 = ".layout_Accordion>ul{position:relative}.layout_Accordion.open>span{font-style:italic}.layout_Accordion.closed>ul{height:0;overflow:hidden}.layout_Accordion.open>ul{display:block}.layout_Accordion>.collapsible-icon,.layout_Accordion>.collapsible-title{cursor:pointer;box-sizing:border-box}.layout_Accordion>.collapsible-title{display:block;width:100%;font-size:13px;color:#fff;padding:4px 8px;height:26px;-webkit-box-shadow:inset 0 -1px 1px 0 rgba(0,0,0,.2);-moz-box-shadow:inset 0 -1px 1px 0 rgba(0,0,0,.2);box-shadow:inset 0 -1px 1px 0 rgba(0,0,0,.2)}.layout_Accordion li{background-color:#fff}.layout_Accordion>.collapsible-title,.layout_Accordion>ul{background-color:#333}.layout_Accordion .layout_Accordion>.collapsible-title,.layout_Accordion .layout_Accordion>ul{background-color:#555}.layout_Accordion .layout_Accordion .layout_Accordion>.collapsible-title,.layout_Accordion .layout_Accordion .layout_Accordion>ul{background-color:#777}.layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion>.collapsible-title,.layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion>ul{background-color:#999}.layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion>.collapsible-title,.layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion>ul{background-color:#bbb}.layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion>.collapsible-title,.layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion>ul{background-color:#ccc}.layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion>.collapsible-title,.layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion .layout_Accordion>ul{background-color:#ddd}.layout_Accordion>span,.layout_Accordion>ul{padding-left:0}.layout_Accordion .layout_Accordion>span,.layout_Accordion .layout_Accordion>ul{padding-left:12px}.layout_Accordion>.collapsible-title:before{padding:4px 8px;position:absolute;left:0;top:0}.layout_Accordion>.collapsible-icon{position:absolute;top:0;right:0;width:24px;height:24px;color:#fff}";
    styleInject(css$1);

    var Accordion = /** @class */ (function (_super) {
        __extends(Accordion, _super);
        function Accordion() {
            var _this = _super.call(this) || this;
            _this._tag = "div";
            _this._isClosed = false;
            return _this;
        }
        Accordion.prototype.pushListItem = function (widget, prepend, protect) {
            if (prepend === void 0) { prepend = false; }
            if (protect === void 0) { protect = false; }
            var contentArr = this.content();
            widget._protected = protect;
            if (prepend) {
                contentArr.unshift(widget);
            }
            else {
                contentArr.push(widget);
            }
            this.content(contentArr);
            return this;
        };
        Accordion.prototype.clearListItems = function () {
            var arr = [];
            for (var i in this.content()) {
                if (this.content()[i]._protected) {
                    arr.push(this.content()[i]);
                }
            }
            this.content(arr);
            return this;
        };
        Accordion.prototype.collapseClick = function (element) {
            if (element.classed("closed")) {
                this._isClosed = false;
                element.classed("open", true);
                element.classed("closed", false);
            }
            else {
                this._isClosed = true;
                element.classed("open", false);
                element.classed("closed", true);
            }
        };
        Accordion.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            var context = this;
            this._isClosed = this.defaultCollapsed();
            element.classed(this._isClosed ? "closed" : "open", true);
            this.titleSpan = element.append("span").classed("collapsible-title", true);
            this.iconDiv = element.append("div").classed("collapsible-icon", true);
            this.ul = element.append("ul");
            this.icon = new common.FAChar()
                .size({ height: 24, width: 24 })
                .target(this.iconDiv.node());
            this.iconDiv.on("click", function () {
                context.collapseClick(element);
                context.render();
            });
            this.titleSpan.on("click", function () {
                context.collapseClick(element);
                context.render();
            });
        };
        Accordion.prototype.update = function (domNode, element) {
            _super.prototype.update.call(this, domNode, element);
            var context = this;
            var this_id = "";
            this.titleSpan.text(context.title().length > 0 ? context.title() + this_id : "Accordion [" + context._id + "]" + this_id);
            var rows = this.ul.selectAll("#" + context._id + " > ul > li").data(this.content(), function (d) {
                return d._id;
            });
            rows.enter()
                .append(function (widget) {
                var li = document.createElement("li");
                if (widget._target === null) {
                    var wSize = widget.size();
                    if (wSize.width === 0 || wSize.height === 0) {
                        var cSize = context.size();
                        widget.size({
                            width: cSize.width,
                            height: cSize.width
                        });
                    }
                    widget.target(li);
                }
                else {
                    return widget._target;
                }
                return li;
            });
            rows.exit().remove();
            this.icon
                .text_colorFill(this.titleFontColor())
                .char(this._isClosed ? this.closedIcon() : this.openIcon()).render();
        };
        Accordion.prototype.exit = function (domNode, element) {
            _super.prototype.exit.call(this, domNode, element);
        };
        return Accordion;
    }(common.HTMLWidget));
    Accordion.prototype._class += " layout_Accordion";
    Accordion.prototype.publish("content", [], "widgetArray", "Array of widgets", null, { tags: ["Basic"] });
    Accordion.prototype.publish("title", "", "string", "Title of collapsible section", null, { tags: ["Private"] });
    Accordion.prototype.publish("openIcon", "\uf147", "string", "Icon to display when list is open", null, { tags: ["Private"] });
    Accordion.prototype.publish("closedIcon", "\uf196", "string", "Icon to display when list is closed", null, { tags: ["Private"] });
    Accordion.prototype.publish("titleFontColor", "#FFFFFF", "html-color", "Title font color", null, { tags: ["Private"] });
    Accordion.prototype.publish("titleBackgroundColor", "#333333", "html-color", "Title background color", null, { tags: ["Private"] });
    Accordion.prototype.publish("defaultCollapsed", false, "boolean", "Collapsed by default if true", null, { tags: ["Private"] });

    var noop = {value: function() {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none() {}

    function selector(selector) {
      return selector == null ? none : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection(subgroups, this._parents);
    }

    function empty() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty : function() {
        return this.querySelectorAll(selector);
      };
    }

    function selection_selectAll(select) {
      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant(x) {
      return function() {
        return x;
      };
    }

    var keyPrefix = "$"; // Protect against keys like “__proto__”.

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that don’t fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = {},
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
          if (keyValue in nodeByKeyValue) {
            exit[i] = node;
          } else {
            nodeByKeyValue[keyValue] = node;
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = keyPrefix + key.call(parent, data[i], i, data);
        if (node = nodeByKeyValue[keyValue]) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue[keyValue] = null;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
          exit[i] = node;
        }
      }
    }

    function selection_data(value, key) {
      if (!value) {
        data = new Array(this.size()), j = -1;
        this.each(function(d) { data[++j] = d; });
        return data;
      }

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = value.call(parent, parent && parent.__data__, j, parents),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    function selection_exit() {
      return new Selection(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
      if (onupdate != null) update = onupdate(update);
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(selection) {

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection(sortgroups, this._parents).order();
    }

    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      var nodes = new Array(this.size()), i = -1;
      this.each(function() { nodes[++i] = this; });
      return nodes;
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      var size = 0;
      this.each(function() { ++size; });
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)
          : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove : typeof value === "function"
                ? styleFunction
                : styleConstant)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction
              : textConstant)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
    }

    function selection_cloneDeep() {
      return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    var filterEvents = {};

    var event = null;

    if (typeof document !== "undefined") {
      var element = document.documentElement;
      if (!("onmouseenter" in element)) {
        filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
      }
    }

    function filterContextListener(listener, index, group) {
      listener = contextListener(listener, index, group);
      return function(event) {
        var related = event.relatedTarget;
        if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
          listener.call(this, event);
        }
      };
    }

    function contextListener(listener, index, group) {
      return function(event1) {
        var event0 = event; // Events can be reentrant (e.g., focus).
        event = event1;
        try {
          listener.call(this, this.__data__, index, group);
        } finally {
          event = event0;
        }
      };
    }

    function parseTypenames$1(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, capture) {
      var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
      return function(d, i, group) {
        var on = this.__on, o, listener = wrap(value, i, group);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
            this.addEventListener(o.type, o.listener = listener, o.capture = capture);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, capture);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, capture) {
      var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      if (capture == null) capture = false;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
      return this;
    }

    function customEvent(event1, listener, that, args) {
      var event0 = event;
      event1.sourceEvent = event;
      event = event1;
      try {
        return listener.apply(that, args);
      } finally {
        event = event0;
      }
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    var root = [null];

    function Selection(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection([[document.documentElement]], root);
    }

    Selection.prototype = selection.prototype = {
      constructor: Selection,
      select: selection_select,
      selectAll: selection_selectAll,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch
    };

    function d3Select(selector) {
      return typeof selector === "string"
          ? new Selection([[document.querySelector(selector)]], [document.documentElement])
          : new Selection([[selector]], root);
    }

    function sourceEvent() {
      var current = event, source;
      while (source = current.sourceEvent) current = source;
      return current;
    }

    function point(node, event) {
      var svg = node.ownerSVGElement || node;

      if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [point.x, point.y];
      }

      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }

    function mouse(node) {
      var event = sourceEvent();
      if (event.changedTouches) event = event.changedTouches[0];
      return point(node, event);
    }

    function d3SelectAll(selector) {
      return typeof selector === "string"
          ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
          : new Selection([selector == null ? [] : selector], root);
    }

    function touch(node, touches, identifier) {
      if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

      for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
        if ((touch = touches[i]).identifier === identifier) {
          return point(node, touch);
        }
      }

      return null;
    }

    function nopropagation() {
      event.stopImmediatePropagation();
    }

    function noevent() {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function nodrag(view) {
      var root = view.document.documentElement,
          selection = d3Select(view).on("dragstart.drag", noevent, true);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent, true);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = d3Select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent, true);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    function constant$1(x) {
      return function() {
        return x;
      };
    }

    function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
      this.target = target;
      this.type = type;
      this.subject = subject;
      this.identifier = id;
      this.active = active;
      this.x = x;
      this.y = y;
      this.dx = dx;
      this.dy = dy;
      this._ = dispatch;
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter() {
      return !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable() {
      return "ontouchstart" in this;
    }

    function d3Drag() {
      var filter = defaultFilter,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned() {
        if (touchending || !filter.apply(this, arguments)) return;
        var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
        if (!gesture) return;
        d3Select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
        nodrag(event.view);
        nopropagation();
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start");
      }

      function mousemoved() {
        noevent();
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag");
      }

      function mouseupped() {
        d3Select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent();
        gestures.mouse("end");
      }

      function touchstarted() {
        if (!filter.apply(this, arguments)) return;
        var touches = event.changedTouches,
            c = container.apply(this, arguments),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) {
            nopropagation();
            gesture("start");
          }
        }
      }

      function touchmoved() {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent();
            gesture("drag");
          }
        }
      }

      function touchended() {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation();
            gesture("end");
          }
        }
      }

      function beforestart(id, container, point, that, args) {
        var p = point(container, id), s, dx, dy,
            sublisteners = listeners.copy();

        if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
          if ((event.subject = s = subject.apply(that, args)) == null) return false;
          dx = s.x - p[0] || 0;
          dy = s.y - p[1] || 0;
          return true;
        })) return;

        return function gesture(type) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[id] = gesture, n = active++; break;
            case "end": delete gestures[id], --active; // nobreak
            case "drag": p = point(container, id), n = active; break;
          }
          customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$1(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$1(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$1(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$1(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    var css$2 = ".layout_Surface{box-sizing:border-box;margin:0;border:1px solid #e5e5e5;overflow:hidden;height:100%;width:100%}.layout_Surface.shadow2{box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 3px 1px -2px rgba(0,0,0,.2),0 1px 5px 0 rgba(0,0,0,.12)}.layout_Surface>h3{margin:0;padding:2px;background-color:#e5e5e5}.layout_Surface .html-button-container{position:absolute;right:0;top:3px}.layout_Surface>div{padding:8px}.layout_Surface .html-button-container .surface-button{margin-right:5px}.layout_Surface .html-button-container .surface-button i{opacity:.8}.layout_Surface .html-button-container .surface-button:hover{opacity:1}.layout_Surface .html-button-container .surface-button:active{opacity:.5}div[draggable=true].hideDragCellContent.content-icon:before{content:\"\\f080\";font-family:FontAwesome;position:absolute;top:calc(50% - 74px);left:calc(50% - 56px);font-size:100px}div[draggable=true].hideDragCellContent.content-icon-Line:before{content:\"\\f201\"}div[draggable=true].hideDragCellContent.content-icon-Pie:before{top:calc(50% - 72px);left:calc(50% - 45px);content:\"\\f200\"}div[draggable=true].hideDragCellContent.content-icon-Area:before{content:\"\\f1fe\"}div[draggable=true].hideDragCellContent.content-icon-Gauge:before{content:\"\\f0e4\"}div[draggable=true].hideDragCellContent.content-icon-Table:before{content:\"\\f0ce\"}div[draggable=true].hideDragCellContent.content-icon-Form:before{content:\"\\f11c\"}div[draggable=true].hideDragCellContent.content-icon-Accordion:before,div[draggable=true].hideDragCellContent.content-icon-Border:before,div[draggable=true].hideDragCellContent.content-icon-Graph:before,div[draggable=true].hideDragCellContent.content-icon-Grid:before,div[draggable=true].hideDragCellContent.content-icon-MultiChart:before,div[draggable=true].hideDragCellContent.content-icon-MultiChartSurface:before,div[draggable=true].hideDragCellContent.content-icon-Tabbed:before{content:\"\\f247\"}div[draggable=true].hideDragCellContent.content-icon-ChoroplethCounties:before,div[draggable=true].hideDragCellContent.content-icon-ChoroplethCountries:before,div[draggable=true].hideDragCellContent.content-icon-ChoroplethStates:before,div[draggable=true].hideDragCellContent.content-icon-ChoroplethStatesHeat:before,div[draggable=true].hideDragCellContent.content-icon-FAChar:before,div[draggable=true].hideDragCellContent.content-icon-GMap:before,div[draggable=true].hideDragCellContent.content-icon-GMapGraph:before,div[draggable=true].hideDragCellContent.content-icon-GMapHeat:before,div[draggable=true].hideDragCellContent.content-icon-Text:before,div[draggable=true].hideDragCellContent.content-icon-TextBox:before{content:\"\\f278\"}";
    styleInject(css$2);

    var Surface = /** @class */ (function (_super) {
        __extends(Surface, _super);
        function Surface() {
            var _this = _super.call(this) || this;
            _this._tag = "div";
            _this._surfaceButtons = [];
            return _this;
        }
        Surface.prototype.widgetSize = function (titleDiv, widgetDiv) {
            var width = this.clientWidth();
            var height = this.clientHeight();
            if (this.title()) {
                height -= this.calcHeight(titleDiv);
            }
            height -= this.calcFrameHeight(widgetDiv);
            width -= this.calcFrameWidth(widgetDiv);
            return { width: width, height: height };
        };
        Surface.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
        };
        Surface.prototype.update = function (domNode, element2) {
            _super.prototype.update.call(this, domNode, element2);
            var context = this;
            element2
                .classed("shadow2", this.surfaceShadow())
                .style("border-width", this.surfaceBorderWidth_exists() ? this.surfaceBorderWidth() + "px" : null)
                .style("border-color", this.surfaceBorderColor())
                .style("border-radius", this.surfaceBorderRadius_exists() ? this.surfaceBorderRadius() + "px" : null)
                .style("background-color", this.surfaceBackgroundColor());
            var titles = element2.selectAll(".surfaceTitle").data(this.title() ? [this.title()] : []);
            titles.enter().insert("h3", "div")
                .attr("class", "surfaceTitle")
                .merge(titles)
                .text(function (d) { return d; })
                .style("text-align", this.surfaceTitleAlignment())
                .style("color", this.surfaceTitleFontColor())
                .style("font-size", this.surfaceTitleFontSize_exists() ? this.surfaceTitleFontSize() + "px" : null)
                .style("font-family", this.surfaceTitleFontFamily())
                .style("font-weight", this.surfaceTitleFontBold() ? "bold" : "normal")
                .style("background-color", this.surfaceTitleBackgroundColor())
                .style("padding", this.surfaceTitlePadding_exists() ? this.surfaceTitlePadding() + "px" : null)
                .style("title", this.altText_exists() ? this.altText() : null);
            titles.exit().remove();
            var surfaceTitle = element2.select(".surfaceTitle");
            var surfaceButtons = surfaceTitle.append("div").attr("class", "html-button-container").selectAll(".surface-button").data(this.buttonAnnotations());
            surfaceButtons.enter().append("button").classed("surface-button", true)
                .each(function (button, idx) {
                var el = context._surfaceButtons[idx] = d3Select(this)
                    .attr("class", "surface-button" + (button.class ? " " + button.class : ""))
                    .attr("id", button.id)
                    .style("padding", button.padding)
                    .style("width", button.width)
                    .style("height", button.height)
                    .style("cursor", "pointer");
                if (button.font === "FontAwesome") {
                    el
                        .style("background", "transparent")
                        .style("border", "none")
                        .on("click", function (d) { context.click(d); })
                        .append("i")
                        .attr("class", "fa")
                        .text(function () { return button.label; });
                }
                else {
                    el
                        .text(function () { return button.label; })
                        .on("click", function (d) { context.click(d); });
                }
            });
            surfaceButtons.exit()
                .each(function (_d, idx) {
                var element = d3Select(this);
                delete context._surfaceButtons[idx];
                element.remove();
            });
            var widgets = element2.selectAll("#" + this._id + " > .surfaceWidget").data(this.widget() ? [this.widget()] : [], function (d) { return d._id; });
            widgets.enter().append("div")
                .attr("class", "surfaceWidget")
                .each(function (d) {
                d3Select(context.element().node().parentElement).classed("content-icon content-icon-" + (d.classID().split("_")[1]), true);
                d.target(this);
            })
                .merge(widgets)
                .style("padding", this.surfacePadding_exists() ? this.surfacePadding() + "px" : null)
                .each(function (d) {
                var widgetSize = context.widgetSize(element2.select("h3"), d3Select(this));
                if (widgetSize.width < 0)
                    widgetSize.width = 0;
                if (widgetSize.height < 0)
                    widgetSize.height = 0;
                d
                    .resize({ width: widgetSize.width, height: widgetSize.height });
            });
            widgets.exit().each(function (d) {
                d.target(null);
            }).remove();
        };
        Surface.prototype.exit = function (domNode, element) {
            if (this.widget()) {
                this.widget().target(null);
            }
            _super.prototype.exit.call(this, domNode, element);
        };
        //  Events  ---
        Surface.prototype.click = function (obj) {
            console.log("Clicked: " + obj.id);
        };
        return Surface;
    }(common.HTMLWidget));
    Surface.prototype._class += " layout_Surface";
    Surface.prototype.publish("title", "", "string", "Title", null, { tags: ["Intermediate"] });
    Surface.prototype.publish("altText", null, "string", "Alt text", null, { optional: true });
    Surface.prototype.publish("surfaceTitlePadding", null, "number", "Title Padding (px)", null, { tags: ["Advanced"], disable: function (w) { return !w.title(); } });
    Surface.prototype.publish("surfaceTitleFontSize", null, "number", "Title Font Size (px)", null, { tags: ["Advanced"], disable: function (w) { return !w.title(); } });
    Surface.prototype.publish("surfaceTitleFontColor", null, "html-color", "Title Font Color", null, { tags: ["Advanced"], disable: function (w) { return !w.title(); } });
    Surface.prototype.publish("surfaceTitleFontFamily", null, "string", "Title Font Family", null, { tags: ["Advanced"], disable: function (w) { return !w.title(); } });
    Surface.prototype.publish("surfaceTitleFontBold", true, "boolean", "Enable Bold Title Font", null, { tags: ["Advanced"], disable: function (w) { return !w.title(); } });
    Surface.prototype.publish("surfaceTitleBackgroundColor", null, "html-color", "Title Background Color", null, { tags: ["Advanced"], disable: function (w) { return !w.title(); } });
    Surface.prototype.publish("surfaceTitleAlignment", "center", "set", "Title Alignment", ["left", "right", "center"], { tags: ["Basic"], disable: function (w) { return !w.title(); } });
    Surface.prototype.publish("surfaceShadow", false, "boolean", "3D Shadow");
    Surface.prototype.publish("surfacePadding", null, "string", "Surface Padding (px)", null, { tags: ["Intermediate"] });
    Surface.prototype.publish("surfaceBackgroundColor", null, "html-color", "Surface Background Color", null, { tags: ["Advanced"] });
    Surface.prototype.publish("surfaceBorderWidth", null, "number", "Surface Border Width (px)", null, { tags: ["Advanced"] });
    Surface.prototype.publish("surfaceBorderColor", null, "html-color", "Surface Border Color", null, { tags: ["Advanced"] });
    Surface.prototype.publish("surfaceBorderRadius", null, "number", "Surface Border Radius (px)", null, { tags: ["Advanced"] });
    Surface.prototype.publish("buttonAnnotations", [], "array", "Button Array", null, { tags: ["Private"] });
    Surface.prototype.publish("widget", null, "widget", "Widget", null, { tags: ["Basic"] });

    var css$3 = ".layout_Cell .update-indicator{box-sizing:border-box;position:absolute;top:0;left:0;padding:0;z-index:1000;border-width:0;border-style:solid;pointer-events:none}";
    styleInject(css$3);

    var Cell = /** @class */ (function (_super) {
        __extends(Cell, _super);
        function Cell() {
            var _this = _super.call(this) || this;
            _this._indicateTheseIds = [];
            return _this;
        }
        Cell.prototype.indicateTheseIds = function (_) {
            if (!arguments.length)
                return this._indicateTheseIds;
            this._indicateTheseIds = _;
            return this;
        };
        Cell.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            var context = this;
            element
                .classed("layout_Surface", true)
                .on("mouseenter", function () { context.onMouseEnter(); })
                .on("mouseleave", function () { context.onMouseLeave(); });
        };
        Cell.prototype.update = function (domNode, element) {
            _super.prototype.update.call(this, domNode, element);
        };
        Cell.prototype.onMouseEnter = function () {
            var arr = this.indicateTheseIds();
            var opacity = this.indicatorOpacity();
            var indicatorBorderColor = this.indicatorBorderColor();
            var indicatorGlowColor = this.indicatorGlowColor();
            for (var i = 0; i < arr.length; i++) {
                var otherElement = d3Select("#" + arr[i]);
                var otherWidget = otherElement.datum();
                if (otherElement && otherWidget) {
                    otherElement.append("div")
                        .attr("class", "update-indicator")
                        .style("width", otherWidget.width() + "px")
                        .style("height", otherWidget.height() + "px")
                        .style("opacity", opacity)
                        .style("border-color", indicatorBorderColor)
                        .style("-webkit-box-shadow", "inset 0px 0px 30px 0px " + indicatorGlowColor)
                        .style("-moz-box-shadow", "inset 0px 0px 30px 0px " + indicatorGlowColor)
                        .style("box-shadow", "inset 0px 0px 30px 0px " + indicatorGlowColor);
                }
            }
        };
        Cell.prototype.onMouseLeave = function () {
            var arr = this.indicateTheseIds();
            for (var i = 0; i < arr.length; i++) {
                d3SelectAll("#" + arr[i] + " > div.update-indicator").remove();
            }
        };
        return Cell;
    }(Surface));
    Cell.prototype._class += " layout_Cell";
    Cell.prototype.publish("gridRow", 0, "number", "Grid Row Position", null, { tags: ["Private"] });
    Cell.prototype.publish("gridCol", 0, "number", "Grid Column Position", null, { tags: ["Private"] });
    Cell.prototype.publish("gridRowSpan", 1, "number", "Grid Row Span", null, { tags: ["Private"] });
    Cell.prototype.publish("gridColSpan", 1, "number", "Grid Column Span", null, { tags: ["Private"] });
    Cell.prototype.publish("indicatorGlowColor", "#EEEE11", "html-color", "Glow color of update-indicator", null, { tags: ["Basic"] });
    Cell.prototype.publish("indicatorBorderColor", "#F48A00", "html-color", "Border color of update-indicator", null, { tags: ["Basic"] });
    Cell.prototype.publish("indicatorOpacity", 0.8, "number", "Opacity of update-indicator", null, { tags: ["Basic"] });

    var css$4 = ".layout_Border{width:100%;height:100%}.layout_Border>.border-content{width:100%;height:100%;position:relative}.layout_Border>.borderHandle{width:6px;height:6px;background-color:#444;opacity:.3;position:absolute;visibility:hidden}.layout_Border.design-mode>.borderHandle{visibility:visible}.layout_Border>.borderHandle:hover{background-color:#666}.layout_Border>.borderHandle.borderHandleDisabled{display:none}.layout_Border>.borderHandle_bottom,.layout_Border>.borderHandle_top{cursor:ns-resize}.layout_Border>.borderHandle_left,.layout_Border>.borderHandle_right{cursor:ew-resize}.layout_Border .cell{border-radius:5px;border:1px solid #e5e5e5;display:inline-block;overflow:hidden}.layout_Border .cell h2{margin:0;padding-top:4px;-webkit-margin:0;text-align:center}.layout_Border .layout_BorderCell.over{border:2px dashed #000}.layout_Border .dragItem{z-index:-1;opacity:.33}.layout_Border .notDragItem{z-index:-1;opacity:1}.layout_Border div[draggable=true]{opacity:.75;cursor:default}.layout_Border div[draggable=true] .dragHandle{opacity:1}.layout_Border div[draggable=true] .dragHandle_e,.layout_Border div[draggable=true] .dragHandle_n,.layout_Border div[draggable=true] .dragHandle_s,.layout_Border div[draggable=true] .dragHandle_w{background-color:#aaa}.layout_Border div[draggable=true] .dragHandle_ne,.layout_Border div[draggable=true] .dragHandle_nw,.layout_Border div[draggable=true] .dragHandle_se,.layout_Border div[draggable=true] .dragHandle_sw{background-color:#333}.layout_Border div[draggable=true] .dragHandle_nw{cursor:nw-resize}.layout_Border div[draggable=true] .dragHandle_n{cursor:n-resize}.layout_Border div[draggable=true] .dragHandle_ne{cursor:ne-resize}.layout_Border div[draggable=true] .dragHandle_e{cursor:e-resize}.layout_Border div[draggable=true] .dragHandle_se{cursor:se-resize}.layout_Border div[draggable=true] .dragHandle_s{cursor:s-resize}.layout_Border div[draggable=true] .dragHandle_sw{cursor:sw-resize}.layout_Border div[draggable=true] .dragHandle_w{cursor:w-resize}.layout_Border div[draggable=false]>div>.dragHandle{display:none}.layout_Border .grid-drop-target{position:fixed;box-sizing:border-box;border:2px dashed #7f8c8d;border-radius:0;background:repeating-linear-gradient(-45deg,transparent,transparent 4px,hsla(0,0%,39.2%,.1) 0,hsla(0,0%,39.2%,.1) 8px)}.layout_Border .grid-drop-target.drop-target-over{border:2px dashed #179bd7;background:repeating-linear-gradient(-45deg,transparent,transparent 6px,rgba(17,155,215,.1) 0,rgba(17,155,215,.1) 12px)}";
    styleInject(css$4);

    var Border = /** @class */ (function (_super) {
        __extends(Border, _super);
        function Border() {
            var _this = _super.call(this) || this;
            _this.lazyPostUpdate = common.Utility.debounce(function () {
                this.postUpdate();
            }, 100);
            _this._tag = "div";
            _this._colCount = 0;
            _this._rowCount = 0;
            _this._colSize = 0;
            _this._rowSize = 0;
            _this._shrinkWrapBoxes = {};
            _this.content([]);
            _this.sectionTypes([]);
            return _this;
        }
        Border.prototype.watchWidget = function (widget) {
            if (this._watch === undefined) {
                this._watch = {};
            }
            if (this._watch[widget.id()]) {
                this._watch[widget.id()].remove();
                delete this._watch[widget.id()];
            }
            if (widget) {
                var context_1 = this;
                this._watch[widget.id()] = widget.monitor(function (paramId, newVal, oldVal) {
                    if (oldVal !== newVal) {
                        context_1.lazyPostUpdate();
                    }
                });
            }
        };
        Border.prototype.applyLayoutType = function () {
            var layoutObj = this.borderLayoutObject();
            this.content().forEach(function (cell, i) {
                cell._fixedLeft = layoutObj[this.sectionTypes()[i]].left;
                cell._fixedTop = layoutObj[this.sectionTypes()[i]].top;
                cell._fixedWidth = layoutObj[this.sectionTypes()[i]].width;
                cell._fixedHeight = layoutObj[this.sectionTypes()[i]].height;
                cell._dragHandles = this.cellSpecificDragHandles(this.sectionTypes()[i]);
            }, this);
        };
        Border.prototype.cellSpecificDragHandles = function (sectionType) {
            switch (sectionType) {
                case "top": return ["s"];
                case "right": return ["w"];
                case "bottom": return ["n"];
                case "left": return ["e"];
                case "center": return [];
            }
        };
        Border.prototype.borderLayoutObject = function (layoutType) {
            var t;
            var b;
            var r;
            var l;
            var c;
            var retObj = {};
            var context = this;
            var topSize;
            var topPerc;
            var bottomSize;
            var bottomPerc;
            var leftSize;
            var leftPerc;
            var rightSize;
            var rightPerc;
            var bcRect = this.target().getBoundingClientRect();
            var gridRect = {};
            gridRect.top = bcRect.top;
            gridRect.left = bcRect.left;
            gridRect.bottom = bcRect.bottom;
            gridRect.right = bcRect.right;
            if (this.target() instanceof SVGElement) {
                gridRect.width = parseFloat(this.target().getAttribute("width"));
                gridRect.height = parseFloat(this.target().getAttribute("height"));
            }
            else {
                gridRect.width = bcRect.width;
                gridRect.height = bcRect.height;
            }
            if (this.sectionTypes().indexOf("top") !== -1) {
                topSize = this.topSize();
                topPerc = this.topPercentage();
                if (typeof (this._shrinkWrapBoxes["top"]) !== "undefined") {
                    topSize = this._shrinkWrapBoxes["top"].height + this.gutter();
                    topPerc = 0;
                }
            }
            if (this.sectionTypes().indexOf("bottom") !== -1) {
                bottomSize = this.bottomSize();
                bottomPerc = this.bottomPercentage();
                if (typeof (this._shrinkWrapBoxes["bottom"]) !== "undefined") {
                    bottomSize = this._shrinkWrapBoxes["bottom"].height + this.gutter();
                    bottomPerc = 0;
                }
            }
            if (this.sectionTypes().indexOf("left") !== -1) {
                leftSize = this.leftSize();
                leftPerc = this.leftPercentage();
                if (typeof (this._shrinkWrapBoxes["left"]) !== "undefined") {
                    leftSize = this._shrinkWrapBoxes["left"].width + this.gutter();
                    leftPerc = 0;
                }
            }
            if (this.sectionTypes().indexOf("right") !== -1) {
                rightSize = this.rightSize();
                rightPerc = this.rightPercentage();
                if (typeof (this._shrinkWrapBoxes["right"]) !== "undefined") {
                    rightSize = this._shrinkWrapBoxes["right"].width + this.gutter();
                    rightPerc = 0;
                }
            }
            t = _sectionPlacementObject({
                width: { "px": 0, "%": 100 },
                height: { "px": topSize, "%": topPerc },
                top: { "px": 0, "%": 0 },
                left: { "px": 0, "%": 0 }
            });
            b = _sectionPlacementObject({
                width: { "px": 0, "%": 100 },
                height: { "px": bottomSize, "%": bottomPerc },
                top: { "px": 0, "%": 100 },
                left: { "px": 0, "%": 0 }
            });
            b.top -= b.height;
            l = _sectionPlacementObject({
                width: { "px": leftSize, "%": leftPerc },
                height: { "px": -t.height - b.height, "%": 100 },
                top: { "px": t.height, "%": 0 },
                left: { "px": 0, "%": 0 }
            });
            r = _sectionPlacementObject({
                width: { "px": rightSize, "%": rightPerc },
                height: { "px": -t.height - b.height, "%": 100 },
                top: { "px": t.height, "%": 0 },
                left: { "px": 0, "%": 100 }
            });
            r.left -= r.width;
            c = _sectionPlacementObject({
                width: { "px": -r.width - l.width, "%": 100 },
                height: { "px": -t.height - b.height, "%": 100 },
                top: { "px": t.height, "%": 0 },
                left: { "px": l.width, "%": 0 }
            });
            retObj["top"] = t;
            retObj["bottom"] = b;
            retObj["right"] = r;
            retObj["left"] = l;
            retObj["center"] = c;
            return retObj;
            function _sectionPlacementObject(obj) {
                obj.width["px"] = typeof (obj.width["px"]) !== "undefined" ? obj.width["px"] : 0;
                obj.width["%"] = typeof (obj.width["%"]) !== "undefined" ? obj.width["%"] : 0;
                obj.height["px"] = typeof (obj.height["px"]) !== "undefined" ? obj.height["px"] : 0;
                obj.height["%"] = typeof (obj.height["%"]) !== "undefined" ? obj.height["%"] : 0;
                var ret = {
                    width: obj.width["px"] + (obj.width["%"] / 100 * context.width()),
                    height: obj.height["px"] + (obj.height["%"] / 100 * context.height()),
                    top: obj.top["px"] + (obj.top["%"] / 100 * context.height()) + context.gutter() / 2,
                    left: obj.left["px"] + (obj.left["%"] / 100 * context.width()) + context.gutter() / 2
                };
                return ret;
            }
        };
        Border.prototype.clearContent = function (sectionType) {
            if (!sectionType) {
                this.content().forEach(function (contentWidget) {
                    contentWidget.target(null);
                    return false;
                });
                d3Select("#" + this.id() + " > div.borderHandle")
                    .classed("borderHandleDisabled", true);
                delete this._watch;
                this.content([]);
                this.sectionTypes([]);
            }
            else {
                var idx = this.sectionTypes().indexOf(sectionType);
                if (idx >= 0) {
                    if (this._watch && this.content()[idx]) {
                        delete this._watch[this.content()[idx].id()];
                    }
                    this.content()[idx].target(null);
                    d3Select("#" + this.id() + " > div.borderHandle_" + sectionType)
                        .classed("borderHandleDisabled", true);
                    this.content().splice(idx, 1);
                    this.sectionTypes().splice(idx, 1);
                }
            }
        };
        Border.prototype.hasContent = function (sectionType, widget, title) {
            return this.sectionTypes().indexOf(sectionType) >= 0;
        };
        Border.prototype.setContent = function (sectionType, widget, title) {
            this.clearContent(sectionType);
            title = typeof (title) !== "undefined" ? title : "";
            if (widget) {
                var cell = new Cell()
                    .surfaceBorderWidth(0)
                    .widget(widget)
                    .title(title);
                this.watchWidget(widget);
                this.content().push(cell);
                this.sectionTypes().push(sectionType);
            }
            return this;
        };
        Border.prototype.getCell = function (id) {
            var idx = this.sectionTypes().indexOf(id);
            if (idx >= 0) {
                return this.content()[idx];
            }
            return null;
        };
        Border.prototype.getContent = function (id) {
            var idx = this.sectionTypes().indexOf(id);
            if (idx >= 0) {
                return this.content()[idx].widget();
            }
            return null;
        };
        Border.prototype.setLayoutOffsets = function () {
            this._offsetX = this._element.node().getBoundingClientRect().left + (this.gutter() / 2);
            this._offsetY = this._element.node().getBoundingClientRect().top + (this.gutter() / 2);
        };
        Border.prototype.dragStart = function (handle) {
            event.sourceEvent.stopPropagation();
            var context = this;
            this._dragCell = handle;
            this._dragCellStartSize = this[handle + "Size"]();
            if (this[handle + "ShrinkWrap"]()) {
                this[handle + "Percentage"](0);
                this[handle + "ShrinkWrap"](false);
            }
            var handleElm = d3Select("#" + context.id() + " > div.borderHandle_" + handle);
            context._handleTop = parseFloat(handleElm.style("top").split("px")[0]);
            context._handleLeft = parseFloat(handleElm.style("left").split("px")[0]);
            this._dragPrevX = event.sourceEvent.clientX;
            this._dragPrevY = event.sourceEvent.clientY;
        };
        Border.prototype.dragTick = function (handle) {
            var context = this;
            var xDelta = this._dragPrevX - event.sourceEvent.clientX;
            var yDelta = this._dragPrevY - event.sourceEvent.clientY;
            switch (handle) {
                case "top":
                case "bottom":
                    _moveHandles(handle, yDelta);
                    break;
                case "right":
                case "left":
                    _moveHandles(handle, xDelta);
                    break;
            }
            function _moveHandles(handle2, delta) {
                if (delta === 0)
                    return;
                var handles = d3SelectAll("#" + context.id() + " > div.borderHandle");
                var grabbedHandle = d3Select("#" + context.id() + " > div.borderHandle_" + handle2);
                if (grabbedHandle.classed("borderHandle_top")) {
                    grabbedHandle.style("top", (context._handleTop - delta) + "px");
                    context._cellSizes.topHeight = context._handleTop - delta;
                    context._cellSizes.leftHeight = context._cellSizes.height;
                    context._cellSizes.leftHeight -= context._cellSizes.topHeight;
                    context._cellSizes.leftHeight -= context._cellSizes.bottomHeight;
                    context._cellSizes.rightHeight = context._cellSizes.leftHeight;
                }
                else if (grabbedHandle.classed("borderHandle_right")) {
                    grabbedHandle.style("left", (context._handleLeft - delta) + "px");
                    context._cellSizes.rightWidth = context._cellSizes.width - context._handleLeft + delta;
                }
                else if (grabbedHandle.classed("borderHandle_bottom")) {
                    grabbedHandle.style("top", (context._handleTop - delta) + "px");
                    context._cellSizes.bottomHeight = context._cellSizes.height - context._handleTop + delta;
                    context._cellSizes.leftHeight = context._cellSizes.height;
                    context._cellSizes.leftHeight -= context._cellSizes.bottomHeight;
                    context._cellSizes.leftHeight -= context._cellSizes.topHeight;
                    context._cellSizes.rightHeight = context._cellSizes.leftHeight;
                }
                else if (grabbedHandle.classed("borderHandle_left")) {
                    grabbedHandle.style("left", (context._handleLeft - delta) + "px");
                    context._cellSizes.leftWidth = context._handleLeft - delta;
                }
                handles.each(function () {
                    var handle3 = d3Select(this);
                    if (handle3.classed("borderHandle_top")) {
                        handle3.style("width", context._cellSizes.width + "px");
                        handle3.style("top", (context._cellSizes.topHeight - 3) + "px");
                    }
                    else if (handle3.classed("borderHandle_right")) {
                        handle3.style("left", (context._cellSizes.width - context._cellSizes.rightWidth) + "px");
                        handle3.style("top", (context._cellSizes.topHeight + 3) + "px");
                        handle3.style("height", context._cellSizes.rightHeight + "px");
                    }
                    else if (handle3.classed("borderHandle_bottom")) {
                        handle3.style("width", context._cellSizes.width + "px");
                        handle3.style("top", (context._cellSizes.height - context._cellSizes.bottomHeight - 3) + "px");
                    }
                    else if (handle3.classed("borderHandle_left")) {
                        handle3.style("left", context._cellSizes.leftWidth + "px");
                        handle3.style("height", context._cellSizes.leftHeight + "px");
                        handle3.style("top", (context._cellSizes.topHeight + 3) + "px");
                    }
                });
            }
        };
        Border.prototype.dragEnd = function (handle) {
            if (handle) {
                var xDelta = this._dragPrevX - event.sourceEvent.clientX;
                var yDelta = this._dragPrevY - event.sourceEvent.clientY;
                switch (handle) {
                    case "top":
                        if (yDelta !== 0) {
                            this.topPercentage(0);
                            this.topSize(this.topSize() === 0 ? this.getContent("top").getBBox().height - yDelta : this.topSize() - yDelta);
                        }
                        break;
                    case "right":
                        if (xDelta !== 0) {
                            this.rightPercentage(0);
                            this.rightSize(this.rightSize() === 0 ? this.getContent("right").getBBox().width + xDelta : this.rightSize() + xDelta);
                        }
                        break;
                    case "bottom":
                        if (yDelta !== 0) {
                            this.bottomPercentage(0);
                            this.bottomSize(this.bottomSize() === 0 ? this.getContent("bottom").getBBox().height + yDelta : this.bottomSize() + yDelta);
                        }
                        break;
                    case "left":
                        if (xDelta !== 0) {
                            this.leftPercentage(0);
                            this.leftSize(this.leftSize() === 0 ? this.getContent("left").getBBox().width - xDelta : this.leftSize() - xDelta);
                        }
                        break;
                }
                this._dragPrevX = event.sourceEvent.clientX;
                this._dragPrevY = event.sourceEvent.clientY;
            }
            this.render();
        };
        Border.prototype.size = function (_) {
            var retVal = common.HTMLWidget.prototype.size.apply(this, arguments);
            if (arguments.length && this.contentDiv) {
                this.contentDiv
                    .style("width", this._size.width + "px")
                    .style("height", this._size.height + "px");
            }
            return retVal;
        };
        Border.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            var context = this;
            element.style("position", "relative");
            this.contentDiv = element.append("div").classed("border-content", true);
            this._scrollBarWidth = common.Platform.getScrollbarWidth();
            this._borderHandles = ["top", "left", "right", "bottom"];
            var handles = element.selectAll("div.borderHandle").data(this._borderHandles);
            handles.enter().append("div")
                .classed("borderHandle", true)
                .each(function (handle) {
                var h = d3Select(this);
                h.classed("borderHandle_" + handle, true)
                    .classed("borderHandleDisabled", context.getContent(handle) === null);
            });
        };
        Border.prototype.update = function (domNode, element) {
            _super.prototype.update.call(this, domNode, element);
            this._sectionTypeArr = this.sectionTypes();
            var context = this;
            element.classed("design-mode", this.designMode());
            this.setLayoutOffsets();
            var rows = this.contentDiv.selectAll(".cell_" + this._id).data(this.content(), function (d) { return d._id; });
            var rowsUpdate = rows.enter().append("div")
                .classed("cell_" + this._id, true)
                .style("position", "absolute")
                .each(function (d, i) {
                d3Select(this).classed("border-cell border-cell-" + context._sectionTypeArr[i], true);
                d.target(this);
                d3Select("#" + context.id() + " > div.borderHandle_" + context._sectionTypeArr[i])
                    .classed("borderHandleDisabled", false);
            }).merge(rows);
            rowsUpdate
                .each(function (d, idx) {
                var sectionType = context.sectionTypes()[idx];
                if (typeof (context[sectionType + "ShrinkWrap"]) !== "undefined" && context[sectionType + "ShrinkWrap"]()) {
                    d.render();
                    context._shrinkWrapBoxes[sectionType] = d.widget().getBBox(true);
                }
                else {
                    delete context._shrinkWrapBoxes[sectionType];
                }
            });
            var drag = d3Drag()
                .on("start", function (d, i) { context.dragStart.call(context, d, i); })
                .on("drag", function (d, i) { context.dragTick.call(context, d, i); })
                .on("end", function (d, i) { context.dragEnd.call(context, d, i); });
            if (this.designMode()) {
                element.selectAll("#" + this.id() + " > div.borderHandle").call(drag);
            }
            else {
                element.selectAll("#" + this.id() + " > div.borderHandle").on(".drag", null);
            }
            var layoutObj = this.borderLayoutObject();
            this.content().forEach(function (cell, i) {
                cell._fixedLeft = layoutObj[this.sectionTypes()[i]].left;
                cell._fixedTop = layoutObj[this.sectionTypes()[i]].top;
                cell._fixedWidth = layoutObj[this.sectionTypes()[i]].width;
                cell._fixedHeight = layoutObj[this.sectionTypes()[i]].height;
                cell._dragHandles = [];
            }, this);
            rowsUpdate
                .style("left", function (d) { return d._fixedLeft + "px"; })
                .style("top", function (d) { return d._fixedTop + "px"; })
                .style("width", function (d) { return d._fixedWidth - context.gutter() + "px"; })
                .style("height", function (d) { return d._fixedHeight - context.gutter() + "px"; })
                .each(function (d) {
                d._placeholderElement
                    .attr("draggable", context.designMode())
                    .selectAll(".dragHandle")
                    .attr("draggable", context.designMode());
                d
                    .surfacePadding(context.surfacePadding())
                    .resize();
            });
            rows.exit().each(function (d) {
                d.target(null);
            }).remove();
            this.getCellSizes();
            element
                .selectAll("#" + this.id() + " > div.borderHandle")
                .each(function () {
                var handle = d3Select(this);
                if (handle.classed("borderHandle_top")) {
                    handle.style("width", context._cellSizes.width + "px");
                    handle.style("top", (context._cellSizes.topHeight - 3) + "px");
                }
                else if (handle.classed("borderHandle_right")) {
                    handle.style("left", (context._cellSizes.width - context._cellSizes.rightWidth) + "px");
                    handle.style("top", (context._cellSizes.topHeight + 3) + "px");
                    handle.style("height", context._cellSizes.rightHeight + "px");
                }
                else if (handle.classed("borderHandle_bottom")) {
                    handle.style("width", context._cellSizes.width + "px");
                    handle.style("top", (context._cellSizes.height - context._cellSizes.bottomHeight - 3) + "px");
                }
                else if (handle.classed("borderHandle_left")) {
                    handle.style("left", context._cellSizes.leftWidth + "px");
                    handle.style("height", context._cellSizes.leftHeight + "px");
                    handle.style("top", (context._cellSizes.topHeight + 3) + "px");
                }
            });
        };
        Border.prototype.getCellSizes = function () {
            var context = this;
            context._cellSizes = {};
            var contentRect = this.element().node().getBoundingClientRect();
            context._cellSizes.width = contentRect.width;
            context._cellSizes.height = contentRect.height;
            this.element()
                .selectAll("#" + this.id() + " > div > div.border-cell")
                .each(function () {
                var cell = d3Select(this);
                if (typeof cell.node === "function") {
                    var rect = cell.node().getBoundingClientRect();
                    if (cell.classed("border-cell-top")) {
                        context._cellSizes.topHeight = rect.height;
                    }
                    else if (cell.classed("border-cell-left")) {
                        context._cellSizes.leftWidth = rect.width;
                        context._cellSizes.leftHeight = rect.height;
                    }
                    else if (cell.classed("border-cell-right")) {
                        context._cellSizes.rightWidth = rect.width;
                        context._cellSizes.rightHeight = rect.height;
                    }
                    else if (cell.classed("border-cell-bottom")) {
                        context._cellSizes.bottomHeight = rect.height;
                    }
                }
            });
            var sizes = ["height", "width", "topHeight", "bottomHeight", "leftHeight", "rightHeight", "leftWidth", "rightWidth"];
            sizes.forEach(function (size) {
                context._cellSizes[size] = context._cellSizes[size] === undefined ? 0 : context._cellSizes[size];
            });
        };
        Border.prototype.postUpdate = function (domNode, element) {
            var context = this;
            this.content().forEach(function (n) {
                if (n._element.node() !== null && n.widget()) {
                    var prevBox = n.widget().getBBox(false, true);
                    var currBox = n.widget().getBBox(true, true);
                    if (prevBox.width !== currBox.width || prevBox.height !== currBox.height) {
                        context.lazyRender();
                    }
                }
            });
        };
        Border.prototype.exit = function (domNode, element) {
            this.content().forEach(function (w) { return w.target(null); });
            _super.prototype.exit.call(this, domNode, element);
        };
        return Border;
    }(common.HTMLWidget));
    Border.prototype._class += " layout_Border";
    Border.prototype.publish("designMode", false, "boolean", "Design Mode", null, { tags: ["Basic"] });
    Border.prototype.publish("content", [], "widgetArray", "widgets", null, { tags: ["Intermediate"] });
    Border.prototype.publish("gutter", 0, "number", "Gap Between Widgets", null, { tags: ["Basic"] });
    Border.prototype.publish("topShrinkWrap", false, "boolean", "'Top' Cell shrinks to fit content", null, { tags: ["Intermediate"] });
    Border.prototype.publish("leftShrinkWrap", false, "boolean", "'Left' Cell shrinks to fit content", null, { tags: ["Intermediate"] });
    Border.prototype.publish("rightShrinkWrap", false, "boolean", "'Right' Cell shrinks to fit content", null, { tags: ["Intermediate"] });
    Border.prototype.publish("bottomShrinkWrap", false, "boolean", "'Bottom' Cell shrinks to fit content", null, { tags: ["Intermediate"] });
    Border.prototype.publish("topSize", 0, "number", "Height of the 'Top' Cell (px)", null, { tags: ["Private"] });
    Border.prototype.publish("leftSize", 0, "number", "Width of the 'Left' Cell (px)", null, { tags: ["Private"] });
    Border.prototype.publish("rightSize", 0, "number", "Width of the 'Right' Cell (px)", null, { tags: ["Private"] });
    Border.prototype.publish("bottomSize", 0, "number", "Height of the 'Bottom' Cell (px)", null, { tags: ["Private"] });
    Border.prototype.publish("topPercentage", 20, "number", "Percentage (of parent) Height of the 'Top' Cell", null, { tags: ["Private"] });
    Border.prototype.publish("leftPercentage", 20, "number", "Percentage (of parent) Width of the 'Left' Cell", null, { tags: ["Private"] });
    Border.prototype.publish("rightPercentage", 20, "number", "Percentage (of parent) Width of the 'Right' Cell", null, { tags: ["Private"] });
    Border.prototype.publish("bottomPercentage", 20, "number", "Percentage (of parent) Height of the 'Bottom' Cell", null, { tags: ["Private"] });
    Border.prototype.publish("surfacePadding", 0, "number", "Cell Padding (px)", null, { tags: ["Intermediate"] });
    Border.prototype.publish("sectionTypes", [], "array", "Section Types sharing an index with 'content' - Used to determine position/size.", null, { tags: ["Private"] });

    var css$5 = ".layout_Border2>.body{margin:0;padding:0;display:flex;flex-flow:row}.layout_Border2>.body>.center{flex:3 1 60%;-ms-flex:3 1 auto;order:2}.layout_Border2>.body>.lhs{flex:1 6 20%;-ms-flex:1 6 auto;order:1}.layout_Border2>.body>.rhs{margin-left:4px;flex:1 6 20%;-ms-flex:1 6 auto;order:3}.layout_Border2>.footer,.layout_Border2>.header{display:block}";
    styleInject(css$5);

    var WidgetDiv = /** @class */ (function () {
        function WidgetDiv(div) {
            this._overlay = false;
            this._div = div;
        }
        WidgetDiv.prototype.overlay = function (_) {
            if (!arguments.length)
                return this._overlay;
            this._overlay = _;
            return this;
        };
        WidgetDiv.prototype.element = function () {
            return this._div;
        };
        WidgetDiv.prototype.node = function () {
            return this._div.node();
        };
        WidgetDiv.prototype.widget = function (_) {
            if (!arguments.length)
                return this._widget;
            if (this._widget !== _) {
                if (this._widget) {
                    this._widget.target(null);
                }
                this._widget = _;
                if (this._widget) {
                    this._widget.target(this._div.node());
                }
            }
            return this;
        };
        WidgetDiv.prototype.resize = function (size) {
            if (this._widget) {
                this._div
                    .style("height", size.height + "px");
                this._widget.resize(size);
            }
            return this;
        };
        WidgetDiv.prototype.render = function (getBBox) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    this._div
                        .style("height", this.overlay() ? "0px" : null)
                        .style("overflow", this.overlay() ? "visible" : null);
                    if (this._widget) {
                        return [2 /*return*/, this._widget.renderPromise().then(function (w) {
                                if (getBBox && _this._widget.visible()) {
                                    var retVal = _this._widget.getBBox();
                                    retVal.width += 8;
                                    if (_this.overlay()) {
                                        retVal.height = 0;
                                    }
                                    else {
                                        retVal.height += 8;
                                    }
                                    return retVal;
                                }
                                return getBBox ? { x: 0, y: 0, width: 0, height: 0 } : undefined;
                            })];
                    }
                    return [2 /*return*/, Promise.resolve(getBBox ? { x: 0, y: 0, width: 0, height: 0 } : undefined)];
                });
            });
        };
        return WidgetDiv;
    }());
    var Border2 = /** @class */ (function (_super) {
        __extends(Border2, _super);
        function Border2() {
            var _this = _super.call(this) || this;
            _this._tag = "div";
            return _this;
        }
        Border2.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            this._topWA = new WidgetDiv(element.append("header"));
            var body = element.append("div").attr("class", "body");
            this._centerWA = new WidgetDiv(body.append("div").attr("class", "center"));
            this._leftWA = new WidgetDiv(body.append("div").attr("class", "lhs"));
            this._rightWA = new WidgetDiv(body.append("div").attr("class", "rhs"));
            this._bottomWA = new WidgetDiv(element.append("div").attr("class", "footer"));
        };
        Border2.prototype.update = function (domNode, element) {
            _super.prototype.update.call(this, domNode, element);
        };
        Border2.prototype.targetNull = function (w) {
            if (w) {
                w.target(null);
            }
        };
        Border2.prototype.exit = function (domNode, element) {
            this.targetNull(this.center());
            this.targetNull(this.bottom());
            this.targetNull(this.right());
            this.targetNull(this.left());
            this.targetNull(this.top());
            _super.prototype.exit.call(this, domNode, element);
        };
        Border2.prototype.render = function (callback) {
            var _this = this;
            var retVal = _super.prototype.render.call(this, function (w) {
                if (_this._topWA) {
                    _this._topWA
                        .widget(_this.top())
                        .overlay(_this.topOverlay())
                        .render(true).then(function (topBBox) { return __awaiter(_this, void 0, void 0, function () {
                        var leftBBox, rightBBox, bottomBBox, promises;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this._leftWA.widget(this.left()).render(true)];
                                case 1:
                                    leftBBox = _a.sent();
                                    return [4 /*yield*/, this._rightWA.widget(this.right()).render(true)];
                                case 2:
                                    rightBBox = _a.sent();
                                    return [4 /*yield*/, this._bottomWA.widget(this.bottom()).render(true)];
                                case 3:
                                    bottomBBox = _a.sent();
                                    if (this.bottomHeight_exists()) {
                                        bottomBBox.height = this.bottomHeight();
                                    }
                                    promises = [
                                        this._topWA
                                            .resize({ width: this.width(), height: topBBox.height })
                                            .render(),
                                        this._leftWA
                                            .resize({ width: leftBBox.width, height: this.height() - (topBBox.height + bottomBBox.height) })
                                            .render(),
                                        this._rightWA
                                            .resize({ width: rightBBox.width, height: this.height() - (topBBox.height + bottomBBox.height) })
                                            .render(),
                                        this._centerWA
                                            .widget(this.center())
                                            .resize({ width: this.width() - (leftBBox.width + rightBBox.width), height: this.height() - (topBBox.height + bottomBBox.height) })
                                            .render(),
                                        this._bottomWA
                                            .resize({ width: this.width(), height: bottomBBox.height })
                                            .render()
                                    ];
                                    Promise.all(promises).then(function (promises) {
                                        if (callback) {
                                            callback(_this);
                                        }
                                    });
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                }
                else {
                    if (callback) {
                        callback(_this);
                    }
                }
            });
            return retVal;
        };
        return Border2;
    }(common.HTMLWidget));
    Border2.prototype._class += " layout_Border2";
    Border2.prototype.publish("top", null, "widget", "Top Widget", undefined, { render: false });
    Border2.prototype.publish("topOverlay", false, "boolean", "Overlay Top Widget");
    Border2.prototype.publish("left", null, "widget", "Left Widget", undefined, { render: false });
    Border2.prototype.publish("center", null, "widget", "Center Widget", undefined, { render: false });
    Border2.prototype.publish("right", null, "widget", "Right Widget", undefined, { render: false });
    Border2.prototype.publish("bottom", null, "widget", "Bottom Widget", undefined, { render: false });
    Border2.prototype.publish("bottomHeight", null, "number", "Bottom Fixed Height", undefined, { optional: true });

    var frame = 0, // is an animation frame pending?
        timeout = 0, // is a timeout pending?
        interval = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend we’ve set an alarm, if we haven’t already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout) timeout = clearTimeout(timeout);
      var delay = time - clockNow;
      if (delay > 24) {
        if (time < Infinity) timeout = setTimeout(wake, delay);
        if (interval) interval = clearInterval(interval);
      } else {
        if (!interval) clockLast = clockNow, interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout$1(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(function(elapsed) {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get$1(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set$1(node, id) {
      var schedule = get$1(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get$1(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout$1(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout$1(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex3 = /^#([0-9a-f]{3})$/,
        reHex6 = /^#([0-9a-f]{6})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color, {
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: function() {
        return this.rgb().hex();
      },
      toString: function() {
        return this.rgb() + "";
      }
    });

    function color(format) {
      var m;
      format = (format + "").trim().toLowerCase();
      return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
          : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format])
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return (0 <= this.r && this.r <= 255)
            && (0 <= this.g && this.g <= 255)
            && (0 <= this.b && this.b <= 255)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: function() {
        return "#" + hex(this.r) + hex(this.g) + hex(this.b);
      },
      toString: function() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "rgb(" : "rgba(")
            + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.b) || 0))
            + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    var deg2rad = Math.PI / 180;
    var rad2deg = 180 / Math.PI;

    // https://beta.observablehq.com/@mbostock/lab-and-rgb
    var K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0 = 4 / 29,
        t1 = 6 / 29,
        t2 = 3 * t1 * t1,
        t3 = t1 * t1 * t1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) {
        if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
        var h = o.h * deg2rad;
        return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
      }
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function lab(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab, extend(Color, {
      brighter: function(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker: function(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb: function() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
    }

    function lab2xyz(t) {
      return t > t1 ? t * t * t : t2 * (t - t0);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * rad2deg;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function hcl(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hcl, hcl, extend(Color, {
      brighter: function(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker: function(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb: function() {
        return labConvert(this).rgb();
      }
    }));

    var A = -0.14861,
        B = +1.78277,
        C = -0.29227,
        D = -0.90649,
        E = +1.97294,
        ED = E * D,
        EB = E * B,
        BC_DA = B * C - D * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B * sinh)),
          255 * (l + a * (C * cosh + D * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function constant$2(x) {
      return function() {
        return x;
      };
    }

    function linear(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue(a, b) {
      var d = b - a;
      return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$2(isNaN(a) ? b : a);
    }

    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential(a, b, y) : constant$2(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear(a, d) : constant$2(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function array(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date(a, b) {
      var d = new Date;
      return a = +a, b -= a, function(t) {
        return d.setTime(a + b * t), d;
      };
    }

    function reinterpolate(a, b) {
      return a = +a, b -= a, function(t) {
        return a + b * t;
      };
    }

    function object(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolateValue(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: reinterpolate(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolateValue(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$2(b)
          : (t === "number" ? reinterpolate
          : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color ? interpolateRgb
          : b instanceof Date ? date
          : Array.isArray(b) ? array
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
          : reinterpolate)(a, b);
    }

    function interpolateRound(a, b) {
      return a = +a, b -= a, function(t) {
        return Math.round(a + b * t);
      };
    }

    var degrees = 180 / Math.PI;

    var identity = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var cssNode,
        cssRoot,
        cssView,
        svgNode;

    function parseCss(value) {
      if (value === "none") return identity;
      if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
      cssNode.style.transform = value;
      value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
      cssRoot.removeChild(cssNode);
      value = value.slice(7, -1).split(",");
      return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
    }

    function parseSvg(value) {
      if (value == null) return identity;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: reinterpolate(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: reinterpolate(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var rho = Math.SQRT2;

    function cubehelix$1(hue) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix$1(start, end) {
          var h = hue((start = cubehelix(start)).h, (end = cubehelix(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix$1.gamma = cubehelixGamma;

        return cubehelix$1;
      })(1);
    }

    cubehelix$1(hue);
    var cubehelixLong = cubehelix$1(nogamma);

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set$1(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set$1(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and we’re done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get$1(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set$1(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get$1(node, id).value[name];
      };
    }

    function interpolate(a, b) {
      var c;
      return (typeof b === "number" ? reinterpolate
          : b instanceof color ? interpolateRgb
          : (c = color(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS$1(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction$1(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS$1(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i(t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i(t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get$1(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set$1(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set$1(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get$1(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set$1(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get$1(this.node(), id).ease;
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set$1;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get$1(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection$1 = selection.prototype.constructor;

    function transition_selection() {
      return new Selection$1(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction$1(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set$1(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove$1(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove$1(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction$1(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant$1(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i(t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction$1(tweenValue(this, "text", value))
          : textConstant$1(value == null ? "" : value + ""));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get$1(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set$1(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and we’re done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      end: transition_end
    };

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var pi = Math.PI;

    var tau = 2 * Math.PI;

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          return defaultTiming.time = now(), defaultTiming;
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var css$6 = ".layout_Carousel>div{position:relative;overflow:hidden}.layout_Carousel>div>.carouselItem{position:absolute}";
    styleInject(css$6);

    var Carousel = /** @class */ (function (_super) {
        __extends(Carousel, _super);
        function Carousel() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._prevActive = 0;
            return _this;
        }
        Carousel.prototype.activeWidget = function () {
            return this.widgets()[this.active()];
        };
        Carousel.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            this._root = element.append("div")
                .attr("id", this.id() + "_root");
        };
        Carousel.prototype.update = function (domNode, element) {
            var _this = this;
            _super.prototype.update.call(this, domNode, element);
            var active = this.active();
            var width = this.width();
            this._root
                .style("width", width + "px")
                .style("height", this.height() + "px");
            var widgetElements = this._root.selectAll("#" + this.id() + "_root > .carouselItem").data(this.widgets(), function (d) { return d.id(); });
            var update = widgetElements.enter().append("div")
                .attr("class", "carouselItem")
                .each(function (w) {
                w.target(this);
            })
                .merge(widgetElements)
                .style("left", function (d, i) { return (i - _this._prevActive) * width + "px"; })
                .style("width", width + "px");
            if (this._prevActive !== active) {
                update
                    .style("display", function (d, i) { return i === _this._prevActive || i === active ? null : "none"; }) //  Must be called before render callback (not inside transition)
                    .transition().duration(this.transitionDuration())
                    .style("left", function (d, i) { return (i - active) * width + "px"; })
                    .on("end", function (d, i) {
                    d3Select(this).style("display", function () { return i === active ? null : "none"; });
                });
                this._prevActive = active;
            }
            widgetElements.exit()
                .each(function (w) {
                w.target(null);
            })
                .remove();
        };
        Carousel.prototype.exit = function (domNode, element) {
            this.widgets().forEach(function (w) { return w.target(null); });
            _super.prototype.exit.call(this, domNode, element);
        };
        Carousel.prototype.render = function (callback) {
            var _this = this;
            return _super.prototype.render.call(this, function (w) {
                if (!_this.visible() || _this.isDOMHidden()) {
                    if (callback) {
                        callback(w);
                    }
                }
                else {
                    _this.activeWidget()
                        .resize(_this.size())
                        .render(function (w2) {
                        if (callback) {
                            callback(w);
                        }
                    });
                }
            });
        };
        return Carousel;
    }(common.HTMLWidget));
    Carousel.prototype._class += " layout_Carousel";
    Carousel.prototype.publish("widgets", [], "widgetArray", "Widgets", null, { render: false });
    Carousel.prototype.publish("active", 0, "number", "Active widget");
    Carousel.prototype.publish("transitionDuration", 500, "number", "Transition duration");

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimal(1.23) returns ["123", 0].
    function formatDecimal(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      return new FormatSpecifier(specifier);
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      this.fill = match[1] || " ";
      this.align = match[2] || ">";
      this.sign = match[3] || "-";
      this.symbol = match[4] || "";
      this.zero = !!match[5];
      this.width = match[6] && +match[6];
      this.comma = !!match[7];
      this.precision = match[8] && +match[8].slice(1);
      this.trim = !!match[9];
      this.type = match[10] || "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width == null ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimal(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimal(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": function(x, p) { return (x * 100).toFixed(p); },
      "b": function(x) { return Math.round(x).toString(2); },
      "c": function(x) { return x + ""; },
      "d": function(x) { return Math.round(x).toString(10); },
      "e": function(x, p) { return x.toExponential(p); },
      "f": function(x, p) { return x.toFixed(p); },
      "g": function(x, p) { return x.toPrecision(p); },
      "o": function(x) { return Math.round(x).toString(8); },
      "p": function(x, p) { return formatRounded(x * 100, p); },
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
      "x": function(x) { return Math.round(x).toString(16); }
    };

    function identity$1(x) {
      return x;
    }

    var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale(locale) {
      var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$1,
          currency = locale.currency,
          decimal = locale.decimal,
          numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$1,
          percent = locale.percent || "%";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision == null ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Perform the initial formatting.
            var valueNegative = value < 0;
            value = formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero during formatting, treat as positive.
            if (valueNegative && +value === 0) valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale;
    var format;
    var formatPrefix;

    defaultLocale({
      decimal: ".",
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      format = locale.format;
      formatPrefix = locale.formatPrefix;
      return locale;
    }

    function ascending$1(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector(compare) {
      if (compare.length === 1) compare = ascendingComparator(compare);
      return {
        left: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          }
          return lo;
        },
        right: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0) hi = mid;
            else lo = mid + 1;
          }
          return lo;
        }
      };
    }

    function ascendingComparator(f) {
      return function(d, x) {
        return ascending$1(f(d), x);
      };
    }

    var ascendingBisect = bisector(ascending$1);

    var prefix = "$";

    function Map() {}

    Map.prototype = map.prototype = {
      constructor: Map,
      has: function(key) {
        return (prefix + key) in this;
      },
      get: function(key) {
        return this[prefix + key];
      },
      set: function(key, value) {
        this[prefix + key] = value;
        return this;
      },
      remove: function(key) {
        var property = prefix + key;
        return property in this && delete this[property];
      },
      clear: function() {
        for (var property in this) if (property[0] === prefix) delete this[property];
      },
      keys: function() {
        var keys = [];
        for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
        return keys;
      },
      values: function() {
        var values = [];
        for (var property in this) if (property[0] === prefix) values.push(this[property]);
        return values;
      },
      entries: function() {
        var entries = [];
        for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
        return entries;
      },
      size: function() {
        var size = 0;
        for (var property in this) if (property[0] === prefix) ++size;
        return size;
      },
      empty: function() {
        for (var property in this) if (property[0] === prefix) return false;
        return true;
      },
      each: function(f) {
        for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
      }
    };

    function map(object, f) {
      var map = new Map;

      // Copy constructor.
      if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

      // Index array by numeric index or specified key function.
      else if (Array.isArray(object)) {
        var i = -1,
            n = object.length,
            o;

        if (f == null) while (++i < n) map.set(i, object[i]);
        else while (++i < n) map.set(f(o = object[i], i, object), o);
      }

      // Convert object to map.
      else if (object) for (var key in object) map.set(key, object[key]);

      return map;
    }

    function Set() {}

    var proto = map.prototype;

    Set.prototype = set$2.prototype = {
      constructor: Set,
      has: proto.has,
      add: function(value) {
        value += "";
        this[prefix + value] = value;
        return this;
      },
      remove: proto.remove,
      clear: proto.clear,
      values: proto.keys,
      size: proto.size,
      empty: proto.empty,
      each: proto.each
    };

    function set$2(object, f) {
      var set = new Set;

      // Copy constructor.
      if (object instanceof Set) object.each(function(value) { set.add(value); });

      // Otherwise, assume it’s an array.
      else if (object) {
        var i = -1, n = object.length;
        if (f == null) while (++i < n) set.add(object[i]);
        else while (++i < n) set.add(f(object[i], i, object));
      }

      return set;
    }

    var array$1 = Array.prototype;
    var slice = array$1.slice;

    var implicit = {name: "implicit"};

    function ordinal(range) {
      var index = map(),
          domain = [],
          unknown = implicit;

      range = range == null ? [] : slice.call(range);

      function scale(d) {
        var key = d + "", i = index.get(key);
        if (!i) {
          if (unknown !== implicit) return unknown;
          index.set(key, i = domain.push(d));
        }
        return range[(i - 1) % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = map();
        var i = -1, n = _.length, d, key;
        while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = slice.call(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return scale;
    }

    var t0$1 = new Date,
        t1$1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = new Date(+date)), date;
      }

      interval.floor = interval;

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [];
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {} // eslint-disable-line no-empty
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0$1.setTime(+start), t1$1.setTime(+end);
          floori(t0$1), floori(t1$1);
          return Math.floor(count(t0$1, t1$1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };

    var durationSecond = 1e3;
    var durationMinute = 6e4;
    var durationHour = 36e5;
    var durationDay = 864e5;
    var durationWeek = 6048e5;

    var second = newInterval(function(date) {
      date.setTime(Math.floor(date / durationSecond) * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });

    var minute = newInterval(function(date) {
      date.setTime(Math.floor(date / durationMinute) * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });

    var hour = newInterval(function(date) {
      var offset = date.getTimezoneOffset() * durationMinute % durationHour;
      if (offset < 0) offset += durationHour;
      date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });

    var day = newInterval(function(date) {
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setDate(date.getDate() + step);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
    }, function(date) {
      return date.getDate() - 1;
    });

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newYear(y) {
      return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale$1(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, newDate) {
        return function(string) {
          var d = newYear(1900),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day$1;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newYear(d.y)), day$1 = week.getUTCDay();
              week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = newDate(newYear(d.y)), day$1 = week.getDay();
              week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
              week = day.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return newDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", localDate);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier, utcDate);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      var map = {}, i = -1, n = names.length;
      while (++i < n) map[names[i].toLowerCase()] = i;
      return map;
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + day.count(year(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(year(d), d), p, 2);
    }

    function formatWeekNumberISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
      return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(year(d), d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d), d), p, 2);
    }

    function formatUTCWeekNumberISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d), d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale$1;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale$1({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      timeFormat = locale$1.format;
      timeParse = locale$1.parse;
      utcFormat = locale$1.utcFormat;
      utcParse = locale$1.utcParse;
      return locale$1;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    function colors(s) {
      return s.match(/.{6}/g).map(function(x) {
        return "#" + x;
      });
    }

    colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

    colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

    colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

    cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

    var rainbow = cubehelix();

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    var pi$1 = Math.PI,
        tau$1 = 2 * pi$1,
        epsilon = 1e-6,
        tauEpsilon = tau$1 - epsilon;

    function Path() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }

    function path() {
      return new Path;
    }

    Path.prototype = path.prototype = {
      constructor: Path,
      moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
          this._ += "L" + x0 + "," + y0;
        }

        // Is this arc empty? We’re done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$1 + tau$1;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon) {
          this._ += "A" + r + "," + r + ",0," + (+(da >= pi$1)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
      },
      toString: function() {
        return this._;
      }
    };

    function constant$3(x) {
      return function constant() {
        return x;
      };
    }

    var pi$2 = Math.PI;
    var tau$2 = 2 * pi$2;

    var d3SymbolCircle = {
      draw: function(context, size) {
        var r = Math.sqrt(size / pi$2);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau$2);
      }
    };

    function d3Symbol() {
      var type = constant$3(d3SymbolCircle),
          size = constant$3(64),
          context = null;

      function symbol() {
        var buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$3(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$3(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function sign(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point$1(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point$1(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point$1(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point$1(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    var xhtml$1 = "http://www.w3.org/1999/xhtml";

    var namespaces$1 = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml$1,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace$1(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces$1.hasOwnProperty(prefix) ? {space: namespaces$1[prefix], local: name} : name;
    }

    function creatorInherit$1(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml$1 && document.documentElement.namespaceURI === xhtml$1
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed$1(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator$1(name) {
      var fullname = namespace$1(name);
      return (fullname.local
          ? creatorFixed$1
          : creatorInherit$1)(fullname);
    }

    var matcher$1 = function(selector) {
      return function() {
        return this.matches(selector);
      };
    };

    if (typeof document !== "undefined") {
      var element$1 = document.documentElement;
      if (!element$1.matches) {
        var vendorMatches = element$1.webkitMatchesSelector
            || element$1.msMatchesSelector
            || element$1.mozMatchesSelector
            || element$1.oMatchesSelector;
        matcher$1 = function(selector) {
          return function() {
            return vendorMatches.call(this, selector);
          };
        };
      }
    }

    var matcher$2 = matcher$1;

    var filterEvents$1 = {};

    if (typeof document !== "undefined") {
      var element$2 = document.documentElement;
      if (!("onmouseenter" in element$2)) {
        filterEvents$1 = {mouseenter: "mouseover", mouseleave: "mouseout"};
      }
    }

    function filterContextListener$1(listener, index, group) {
      listener = contextListener$1(listener, index, group);
      return function(event) {
        var related = event.relatedTarget;
        if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
          listener.call(this, event);
        }
      };
    }

    function contextListener$1(listener, index, group) {
      return function(event1) {
        try {
          listener.call(this, this.__data__, index, group);
        } finally {
        }
      };
    }

    function parseTypenames$2(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove$1(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd$1(typename, value, capture) {
      var wrap = filterEvents$1.hasOwnProperty(typename.type) ? filterContextListener$1 : contextListener$1;
      return function(d, i, group) {
        var on = this.__on, o, listener = wrap(value, i, group);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
            this.addEventListener(o.type, o.listener = listener, o.capture = capture);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, capture);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on$1(typename, value, capture) {
      var typenames = parseTypenames$2(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd$1 : onRemove$1;
      if (capture == null) capture = false;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
      return this;
    }

    function none$1() {}

    function selector$1(selector) {
      return selector == null ? none$1 : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select$1(select) {
      if (typeof select !== "function") select = selector$1(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$2(subgroups, this._parents);
    }

    function empty$1() {
      return [];
    }

    function selectorAll$1(selector) {
      return selector == null ? empty$1 : function() {
        return this.querySelectorAll(selector);
      };
    }

    function selection_selectAll$1(select) {
      if (typeof select !== "function") select = selectorAll$1(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$2(subgroups, parents);
    }

    function selection_filter$1(match) {
      if (typeof match !== "function") match = matcher$2(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$2(subgroups, this._parents);
    }

    function sparse$1(update) {
      return new Array(update.length);
    }

    function selection_enter$1() {
      return new Selection$2(this._enter || this._groups.map(sparse$1), this._parents);
    }

    function EnterNode$1(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode$1.prototype = {
      constructor: EnterNode$1,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$4(x) {
      return function() {
        return x;
      };
    }

    var keyPrefix$1 = "$"; // Protect against keys like “__proto__”.

    function bindIndex$1(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode$1(parent, data[i]);
        }
      }

      // Put any non-null nodes that don’t fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey$1(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = {},
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = keyPrefix$1 + key.call(node, node.__data__, i, group);
          if (keyValue in nodeByKeyValue) {
            exit[i] = node;
          } else {
            nodeByKeyValue[keyValue] = node;
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = keyPrefix$1 + key.call(parent, data[i], i, data);
        if (node = nodeByKeyValue[keyValue]) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue[keyValue] = null;
        } else {
          enter[i] = new EnterNode$1(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
          exit[i] = node;
        }
      }
    }

    function selection_data$1(value, key) {
      if (!value) {
        data = new Array(this.size()), j = -1;
        this.each(function(d) { data[++j] = d; });
        return data;
      }

      var bind = key ? bindKey$1 : bindIndex$1,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$4(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = value.call(parent, parent && parent.__data__, j, parents),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$2(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    function selection_exit$1() {
      return new Selection$2(this._exit || this._groups.map(sparse$1), this._parents);
    }

    function selection_merge$1(selection) {

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$2(merges, this._parents);
    }

    function selection_order$1() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort$1(compare) {
      if (!compare) compare = ascending$2;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$2(sortgroups, this._parents).order();
    }

    function ascending$2(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call$1() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes$1() {
      var nodes = new Array(this.size()), i = -1;
      this.each(function() { nodes[++i] = this; });
      return nodes;
    }

    function selection_node$1() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size$1() {
      var size = 0;
      this.each(function() { ++size; });
      return size;
    }

    function selection_empty$1() {
      return !this.node();
    }

    function selection_each$1(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$2(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$2(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$2(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$2(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$2(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$2(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr$1(name, value) {
      var fullname = namespace$1(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$2 : attrRemove$2) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$2 : attrFunction$2)
          : (fullname.local ? attrConstantNS$2 : attrConstant$2)))(fullname, value));
    }

    function defaultView$1(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$2(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$2(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$2(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style$1(name, value, priority) {
      var node;
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$2 : typeof value === "function"
                ? styleFunction$2
                : styleConstant$2)(name, value, priority == null ? "" : priority))
          : defaultView$1(node = this.node())
              .getComputedStyle(node, null)
              .getPropertyValue(name);
    }

    function propertyRemove$1(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant$1(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property$1(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove$1 : typeof value === "function"
              ? propertyFunction$1
              : propertyConstant$1)(name, value))
          : this.node()[name];
    }

    function classArray$1(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList$1(node) {
      return node.classList || new ClassList$1(node);
    }

    function ClassList$1(node) {
      this._node = node;
      this._names = classArray$1(node.getAttribute("class") || "");
    }

    ClassList$1.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd$1(node, names) {
      var list = classList$1(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove$1(node, names) {
      var list = classList$1(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue$1(names) {
      return function() {
        classedAdd$1(this, names);
      };
    }

    function classedFalse$1(names) {
      return function() {
        classedRemove$1(this, names);
      };
    }

    function classedFunction$1(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd$1 : classedRemove$1)(this, names);
      };
    }

    function selection_classed$1(name, value) {
      var names = classArray$1(name + "");

      if (arguments.length < 2) {
        var list = classList$1(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction$1 : value
          ? classedTrue$1
          : classedFalse$1)(names, value));
    }

    function textRemove$1() {
      this.textContent = "";
    }

    function textConstant$2(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$2(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text$1(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove$1 : (typeof value === "function"
              ? textFunction$2
              : textConstant$2)(value))
          : this.node().textContent;
    }

    function htmlRemove$1() {
      this.innerHTML = "";
    }

    function htmlConstant$1(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html$1(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove$1 : (typeof value === "function"
              ? htmlFunction$1
              : htmlConstant$1)(value))
          : this.node().innerHTML;
    }

    function raise$1() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise$1() {
      return this.each(raise$1);
    }

    function lower$1() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower$1() {
      return this.each(lower$1);
    }

    function selection_append$1(name) {
      var create = typeof name === "function" ? name : creator$1(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull$1() {
      return null;
    }

    function selection_insert$1(name, before) {
      var create = typeof name === "function" ? name : creator$1(name),
          select = before == null ? constantNull$1 : typeof before === "function" ? before : selector$1(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove$1() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove$1() {
      return this.each(remove$1);
    }

    function selection_datum$1(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    function dispatchEvent$1(node, type, params) {
      var window = defaultView$1(node),
          event = window.CustomEvent;

      if (event) {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant$1(type, params) {
      return function() {
        return dispatchEvent$1(this, type, params);
      };
    }

    function dispatchFunction$1(type, params) {
      return function() {
        return dispatchEvent$1(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch$1(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction$1
          : dispatchConstant$1)(type, params));
    }

    var root$1 = [null];

    function Selection$2(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection$1() {
      return new Selection$2([[document.documentElement]], root$1);
    }

    Selection$2.prototype = selection$1.prototype = {
      constructor: Selection$2,
      select: selection_select$1,
      selectAll: selection_selectAll$1,
      filter: selection_filter$1,
      data: selection_data$1,
      enter: selection_enter$1,
      exit: selection_exit$1,
      merge: selection_merge$1,
      order: selection_order$1,
      sort: selection_sort$1,
      call: selection_call$1,
      nodes: selection_nodes$1,
      node: selection_node$1,
      size: selection_size$1,
      empty: selection_empty$1,
      each: selection_each$1,
      attr: selection_attr$1,
      style: selection_style$1,
      property: selection_property$1,
      classed: selection_classed$1,
      text: selection_text$1,
      html: selection_html$1,
      raise: selection_raise$1,
      lower: selection_lower$1,
      append: selection_append$1,
      insert: selection_insert$1,
      remove: selection_remove$1,
      datum: selection_datum$1,
      on: selection_on$1,
      dispatch: selection_dispatch$1
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$2([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$2([[selector]], root$1);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimal(1.23) returns ["123", 0].
    function formatDecimal$1(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent$1(x) {
      return x = formatDecimal$1(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup$1(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatDefault(x, p) {
      x = x.toPrecision(p);

      out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (x[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          case "e": break out;
          default: if (i0 > 0) i0 = 0; break;
        }
      }

      return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
    }

    var prefixExponent$1;

    function formatPrefixAuto$1(x, p) {
      var d = formatDecimal$1(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent$1 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimal$1(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded$1(x, p) {
      var d = formatDecimal$1(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes$1 = {
      "": formatDefault,
      "%": function(x, p) { return (x * 100).toFixed(p); },
      "b": function(x) { return Math.round(x).toString(2); },
      "c": function(x) { return x + ""; },
      "d": function(x) { return Math.round(x).toString(10); },
      "e": function(x, p) { return x.toExponential(p); },
      "f": function(x, p) { return x.toFixed(p); },
      "g": function(x, p) { return x.toPrecision(p); },
      "o": function(x) { return Math.round(x).toString(8); },
      "p": function(x, p) { return formatRounded$1(x * 100, p); },
      "r": formatRounded$1,
      "s": formatPrefixAuto$1,
      "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
      "x": function(x) { return Math.round(x).toString(16); }
    };

    // [[fill]align][sign][symbol][0][width][,][.precision][type]
    var re$1 = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

    function formatSpecifier$1(specifier) {
      return new FormatSpecifier$1(specifier);
    }

    function FormatSpecifier$1(specifier) {
      if (!(match = re$1.exec(specifier))) throw new Error("invalid format: " + specifier);

      var match,
          fill = match[1] || " ",
          align = match[2] || ">",
          sign = match[3] || "-",
          symbol = match[4] || "",
          zero = !!match[5],
          width = match[6] && +match[6],
          comma = !!match[7],
          precision = match[8] && +match[8].slice(1),
          type = match[9] || "";

      // The "n" type is an alias for ",g".
      if (type === "n") comma = true, type = "g";

      // Map invalid types to the default format.
      else if (!formatTypes$1[type]) type = "";

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

      this.fill = fill;
      this.align = align;
      this.sign = sign;
      this.symbol = symbol;
      this.zero = zero;
      this.width = width;
      this.comma = comma;
      this.precision = precision;
      this.type = type;
    }

    FormatSpecifier$1.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width == null ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
          + this.type;
    };

    var prefixes$1 = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function identity$2(x) {
      return x;
    }

    function formatLocale$2(locale) {
      var group = locale.grouping && locale.thousands ? formatGroup$1(locale.grouping, locale.thousands) : identity$2,
          currency = locale.currency,
          decimal = locale.decimal;

      function newFormat(specifier) {
        specifier = formatSpecifier$1(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            type = specifier.type;

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes$1[type],
            maybeSuffix = !type || /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision == null ? (type ? 6 : 12)
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Convert negative to positive, and compute the prefix.
            // Note that -0 is not less than 0, but 1 / -0 is!
            var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);

            // Perform the initial formatting.
            value = formatType(value, precision);

            // If the original value was negative, it may be rounded to zero during
            // formatting; treat this as (positive) zero.
            if (valueNegative) {
              i = -1, n = value.length;
              valueNegative = false;
              while (++i < n) {
                if (c = value.charCodeAt(i), (48 < c && c < 58)
                    || (type === "x" && 96 < c && c < 103)
                    || (type === "X" && 64 < c && c < 71)) {
                  valueNegative = true;
                  break;
                }
              }
            }

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = valueSuffix + (type === "s" ? prefixes$1[8 + prefixExponent$1 / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": return valuePrefix + value + valueSuffix + padding;
            case "=": return valuePrefix + padding + value + valueSuffix;
            case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          }
          return padding + valuePrefix + value + valueSuffix;
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier$1(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes$1[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$2;
    var format$1;
    var formatPrefix$1;

    defaultLocale$2({
      decimal: ".",
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale$2(definition) {
      locale$2 = formatLocale$2(definition);
      format$1 = locale$2.format;
      formatPrefix$1 = locale$2.formatPrefix;
      return locale$2;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent$1(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
    }

    var noop$1 = {value: function() {}};

    function dispatch$1() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch$1(_);
    }

    function Dispatch$1(_) {
      this._ = _;
    }

    function parseTypenames$3(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch$1.prototype = dispatch$1.prototype = {
      constructor: Dispatch$1,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$3(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$2(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$3(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$3(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch$1(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$2(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$3(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    function ascending$3(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector$1(compare) {
      if (compare.length === 1) compare = ascendingComparator$1(compare);
      return {
        left: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          }
          return lo;
        },
        right: function(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0) hi = mid;
            else lo = mid + 1;
          }
          return lo;
        }
      };
    }

    function ascendingComparator$1(f) {
      return function(d, x) {
        return ascending$3(f(d), x);
      };
    }

    var ascendingBisect$1 = bisector$1(ascending$3);
    var bisectRight = ascendingBisect$1.right;

    function sequence(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var step = tickStep(start, stop, count);
      return sequence(
        Math.ceil(start / step) * step,
        Math.floor(stop / step) * step + step / 2, // inclusive
        step
      );
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function sum(array, f) {
      var s = 0,
          n = array.length,
          a,
          i = -1;

      if (f == null) {
        while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.
      }

      else {
        while (++i < n) if (a = +f(array[i], i, array)) s += a;
      }

      return s;
    }

    var array$2 = Array.prototype;

    var map$1 = array$2.map;
    var slice$1 = array$2.slice;

    function constant$5(x) {
      return function() {
        return x;
      };
    }

    function number(x) {
      return +x;
    }

    var unit = [0, 1];

    function deinterpolateLinear(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constant$5(b);
    }

    function deinterpolateClamp(deinterpolate) {
      return function(a, b) {
        var d = deinterpolate(a = +a, b = +b);
        return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
      };
    }

    function reinterpolateClamp(reinterpolate) {
      return function(a, b) {
        var r = reinterpolate(a = +a, b = +b);
        return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
      };
    }

    function bimap(domain, range, deinterpolate, reinterpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
      else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, deinterpolate, reinterpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = deinterpolate(domain[i], domain[i + 1]);
        r[i] = reinterpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisectRight(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp());
    }

    // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
    function continuous(deinterpolate, reinterpolate) {
      var domain = unit,
          range = unit,
          interpolate = interpolateValue,
          clamp = false,
          piecewise,
          output,
          input;

      function rescale() {
        piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
      }

      scale.invert = function(y) {
        return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = map$1.call(_, number), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = slice$1.call(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = slice$1.call(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, rescale()) : clamp;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      return rescale();
    }

    function tickFormat(domain, count, specifier) {
      var start = domain[0],
          stop = domain[domain.length - 1],
          step = tickStep(start, stop, count == null ? 10 : count),
          precision;
      specifier = formatSpecifier$1(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix$1(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format$1(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        return tickFormat(domain(), count, specifier);
      };

      scale.nice = function(count) {
        var d = domain(),
            i = d.length - 1,
            n = count == null ? 10 : count,
            start = d[0],
            stop = d[i],
            step = tickStep(start, stop, n);

        if (step) {
          step = tickStep(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);
          d[0] = Math.floor(start / step) * step;
          d[i] = Math.ceil(stop / step) * step;
          domain(d);
        }

        return scale;
      };

      return scale;
    }

    function linear$1() {
      var scale = continuous(deinterpolateLinear, reinterpolate);

      scale.copy = function() {
        return copy(scale, linear$1());
      };

      return linearish(scale);
    }

    function colors$1(s) {
      return s.match(/.{6}/g).map(function(x) {
        return "#" + x;
      });
    }

    colors$1("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    colors$1("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

    colors$1("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

    colors$1("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

    cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

    var warm$1 = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

    var cool$1 = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

    var rainbow$1 = cubehelix();

    function ramp$1(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    ramp$1(colors$1("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma$1 = ramp$1(colors$1("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno$1 = ramp$1(colors$1("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma$1 = ramp$1(colors$1("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var d3_identity = function d3_identity(d) {
      return d;
    };

    var d3_reverse = function d3_reverse(arr) {
      var mirror = [];
      for (var i = 0, l = arr.length; i < l; i++) {
        mirror[i] = arr[l - i - 1];
      }
      return mirror;
    };

    //Text wrapping code adapted from Mike Bostock
    var d3_textWrapping = function d3_textWrapping(text, width) {
      text.each(function () {
        var text = select(this),
            words = text.text().split(/\s+/).reverse(),
            word,
            line = [],
            lineHeight = 1.2,
            //ems
        y = text.attr("y"),
            dy = parseFloat(text.attr("dy")) || 0,
            tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", dy + "em");

        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > width && line.length > 1) {
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + dy + "em").text(word);
          }
        }
      });
    };

    var d3_mergeLabels = function d3_mergeLabels() {
      var gen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var labels = arguments[1];
      var domain = arguments[2];
      var range = arguments[3];


      if ((typeof labels === 'undefined' ? 'undefined' : _typeof(labels)) === "object") {
        if (labels.length === 0) return gen;

        var i = labels.length;
        for (; i < gen.length; i++) {
          labels.push(gen[i]);
        }
        return labels;
      } else if (typeof labels === "function") {
        var customLabels = [];
        var genLength = gen.length;
        for (var _i = 0; _i < genLength; _i++) {
          customLabels.push(labels({
            i: _i,
            genLength: genLength,
            generatedLabels: gen,
            domain: domain,
            range: range }));
        }
        return customLabels;
      }

      return gen;
    };

    var d3_linearLegend = function d3_linearLegend(scale, cells, labelFormat) {
      var data = [];

      if (cells.length > 1) {
        data = cells;
      } else {
        var domain = scale.domain(),
            increment = (domain[domain.length - 1] - domain[0]) / (cells - 1);
        var i = 0;

        for (; i < cells; i++) {
          data.push(domain[0] + i * increment);
        }
      }

      var labels = data.map(labelFormat);
      return { data: data,
        labels: labels,
        feature: function feature(d) {
          return scale(d);
        } };
    };

    var d3_quantLegend = function d3_quantLegend(scale, labelFormat, labelDelimiter) {
      var labels = scale.range().map(function (d) {
        var invert = scale.invertExtent(d);
        return labelFormat(invert[0]) + " " + labelDelimiter + " " + labelFormat(invert[1]);
      });

      return { data: scale.range(),
        labels: labels,
        feature: d3_identity
      };
    };

    var d3_ordinalLegend = function d3_ordinalLegend(scale) {
      return { data: scale.domain(),
        labels: scale.domain(),
        feature: function feature(d) {
          return scale(d);
        } };
    };

    var d3_cellOver = function d3_cellOver(cellDispatcher, d, obj) {
      cellDispatcher.call("cellover", obj, d);
    };

    var d3_cellOut = function d3_cellOut(cellDispatcher, d, obj) {
      cellDispatcher.call("cellout", obj, d);
    };

    var d3_cellClick = function d3_cellClick(cellDispatcher, d, obj) {
      cellDispatcher.call("cellclick", obj, d);
    };

    var helper = {

      d3_drawShapes: function d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path) {
        if (shape === "rect") {
          shapes.attr("height", shapeHeight).attr("width", shapeWidth);
        } else if (shape === "circle") {
          shapes.attr("r", shapeRadius);
        } else if (shape === "line") {
          shapes.attr("x1", 0).attr("x2", shapeWidth).attr("y1", 0).attr("y2", 0);
        } else if (shape === "path") {
          shapes.attr("d", path);
        }
      },

      d3_addText: function d3_addText(svg, enter, labels, classPrefix, labelWidth) {
        enter.append("text").attr("class", classPrefix + "label");
        var text = svg.selectAll('g.' + classPrefix + 'cell text.' + classPrefix + 'label').data(labels).text(d3_identity);

        if (labelWidth) {
          svg.selectAll('g.' + classPrefix + 'cell text.' + classPrefix + 'label').call(d3_textWrapping, labelWidth);
        }

        return text;
      },

      d3_calcType: function d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter) {
        var type = scale.invertExtent ? d3_quantLegend(scale, labelFormat, labelDelimiter) : scale.ticks ? d3_linearLegend(scale, cells, labelFormat) : d3_ordinalLegend(scale);

        //for d3.scaleSequential that doesn't have a range function
        var range = scale.range && scale.range() || scale.domain();
        type.labels = d3_mergeLabels(type.labels, labels, scale.domain(), range);

        if (ascending) {
          type.labels = d3_reverse(type.labels);
          type.data = d3_reverse(type.data);
        }

        return type;
      },

      d3_filterCells: function d3_filterCells(type, cellFilter) {
        var filterCells = type.data.map(function (d, i) {
          return { data: d, label: type.labels[i] };
        }).filter(cellFilter);
        var dataValues = filterCells.map(function (d) {
          return d.data;
        });
        var labelValues = filterCells.map(function (d) {
          return d.label;
        });
        type.data = type.data.filter(function (d) {
          return dataValues.indexOf(d) !== -1;
        });
        type.labels = type.labels.filter(function (d) {
          return labelValues.indexOf(d) !== -1;
        });
        return type;
      },

      d3_placement: function d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign) {
        cell.attr("transform", cellTrans);
        text.attr("transform", textTrans);
        if (orient === "horizontal") {
          text.style("text-anchor", labelAlign);
        }
      },

      d3_addEvents: function d3_addEvents(cells, dispatcher) {
        cells.on("mouseover.legend", function (d) {
          d3_cellOver(dispatcher, d, this);
        }).on("mouseout.legend", function (d) {
          d3_cellOut(dispatcher, d, this);
        }).on("click.legend", function (d) {
          d3_cellClick(dispatcher, d, this);
        });
      },

      d3_title: function d3_title(svg, title, classPrefix, titleWidth) {
        if (title !== "") {

          var titleText = svg.selectAll('text.' + classPrefix + 'legendTitle');

          titleText.data([title]).enter().append('text').attr('class', classPrefix + 'legendTitle');

          svg.selectAll('text.' + classPrefix + 'legendTitle').text(title);

          if (titleWidth) {
            svg.selectAll('text.' + classPrefix + 'legendTitle').call(d3_textWrapping, titleWidth);
          }

          var cellsSvg = svg.select('.' + classPrefix + 'legendCells');
          var yOffset = svg.select('.' + classPrefix + 'legendTitle').nodes().map(function (d) {
            return d.getBBox().height;
          })[0],
              xOffset = -cellsSvg.nodes().map(function (d) {
            return d.getBBox().x;
          })[0];
          cellsSvg.attr('transform', 'translate(' + xOffset + ',' + yOffset + ')');
        }
      },

      d3_defaultLocale: {
        format: format$1,
        formatPrefix: formatPrefix$1
      },

      d3_defaultFormatSpecifier: '.01f',

      d3_defaultDelimiter: 'to'
    };

    function color$1() {
      var scale = linear$1(),
          shape = "rect",
          shapeWidth = 15,
          shapeHeight = 15,
          shapeRadius = 10,
          shapePadding = 2,
          cells = [5],
          cellFilter = void 0,
          labels = [],
          classPrefix = "",
          useClass = false,
          title = "",
          locale = helper.d3_defaultLocale,
          specifier = helper.d3_defaultFormatSpecifier,
          labelOffset = 10,
          labelAlign = "middle",
          labelDelimiter = helper.d3_defaultDelimiter,
          labelWrap = void 0,
          orient = "vertical",
          ascending = false,
          path = void 0,
          titleWidth = void 0,
          legendDispatcher = dispatch$1("cellover", "cellout", "cellclick");

      function legend(svg) {
        var type = helper.d3_calcType(scale, ascending, cells, labels, locale.format(specifier), labelDelimiter),
            legendG = svg.selectAll("g").data([scale]);

        legendG.enter().append("g").attr("class", classPrefix + "legendCells");

        if (cellFilter) {
          helper.d3_filterCells(type, cellFilter);
        }

        var cell = svg.select("." + classPrefix + "legendCells").selectAll("." + classPrefix + "cell").data(type.data);

        var cellEnter = cell.enter().append("g").attr("class", classPrefix + "cell");
        cellEnter.append(shape).attr("class", classPrefix + "swatch");

        var shapes = svg.selectAll("g." + classPrefix + "cell " + shape + "." + classPrefix + "swatch").data(type.data);

        //add event handlers
        helper.d3_addEvents(cellEnter, legendDispatcher);

        cell.exit().transition().style("opacity", 0).remove();
        shapes.exit().transition().style("opacity", 0).remove();

        shapes = shapes.merge(shapes);

        helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path);
        var text = helper.d3_addText(svg, cellEnter, type.labels, classPrefix, labelWrap);

        // we need to merge the selection, otherwise changes in the legend (e.g. change of orientation) are applied only to the new cells and not the existing ones.
        cell = cellEnter.merge(cell);

        // sets placement
        var textSize = text.nodes().map(function (d) {
          return d.getBBox();
        }),
            shapeSize = shapes.nodes().map(function (d) {
          return d.getBBox();
        });
        //sets scale
        //everything is fill except for line which is stroke,
        if (!useClass) {
          if (shape == "line") {
            shapes.style("stroke", type.feature);
          } else {
            shapes.style("fill", type.feature);
          }
        } else {
          shapes.attr("class", function (d) {
            return classPrefix + "swatch " + type.feature(d);
          });
        }

        var cellTrans = void 0,
            textTrans = void 0,
            textAlign = labelAlign == "start" ? 0 : labelAlign == "middle" ? 0.5 : 1;

        //positions cells and text
        if (orient === "vertical") {
          (function () {
            var cellSize = textSize.map(function (d, i) {
              return Math.max(d.height, shapeSize[i].height);
            });

            cellTrans = function cellTrans(d, i) {
              var height = sum(cellSize.slice(0, i));
              return "translate(0, " + (height + i * shapePadding) + ")";
            };

            textTrans = function textTrans(d, i) {
              return "translate( " + (shapeSize[i].width + shapeSize[i].x + labelOffset) + ", " + (shapeSize[i].y + shapeSize[i].height / 2 + 5) + ")";
            };
          })();
        } else if (orient === "horizontal") {
          cellTrans = function cellTrans(d, i) {
            return "translate(" + i * (shapeSize[i].width + shapePadding) + ",0)";
          };
          textTrans = function textTrans(d, i) {
            return "translate(" + (shapeSize[i].width * textAlign + shapeSize[i].x) + ",\n          " + (shapeSize[i].height + shapeSize[i].y + labelOffset + 8) + ")";
          };
        }

        helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
        helper.d3_title(svg, title, classPrefix, titleWidth);

        cell.transition().style("opacity", 1);
      }

      legend.scale = function (_) {
        if (!arguments.length) return scale;
        scale = _;
        return legend;
      };

      legend.cells = function (_) {
        if (!arguments.length) return cells;
        if (_.length > 1 || _ >= 2) {
          cells = _;
        }
        return legend;
      };

      legend.cellFilter = function (_) {
        if (!arguments.length) return cellFilter;
        cellFilter = _;
        return legend;
      };

      legend.shape = function (_, d) {
        if (!arguments.length) return shape;
        if (_ == "rect" || _ == "circle" || _ == "line" || _ == "path" && typeof d === "string") {
          shape = _;
          path = d;
        }
        return legend;
      };

      legend.shapeWidth = function (_) {
        if (!arguments.length) return shapeWidth;
        shapeWidth = +_;
        return legend;
      };

      legend.shapeHeight = function (_) {
        if (!arguments.length) return shapeHeight;
        shapeHeight = +_;
        return legend;
      };

      legend.shapeRadius = function (_) {
        if (!arguments.length) return shapeRadius;
        shapeRadius = +_;
        return legend;
      };

      legend.shapePadding = function (_) {
        if (!arguments.length) return shapePadding;
        shapePadding = +_;
        return legend;
      };

      legend.labels = function (_) {
        if (!arguments.length) return labels;
        labels = _;
        return legend;
      };

      legend.labelAlign = function (_) {
        if (!arguments.length) return labelAlign;
        if (_ == "start" || _ == "end" || _ == "middle") {
          labelAlign = _;
        }
        return legend;
      };

      legend.locale = function (_) {
        if (!arguments.length) return locale;
        locale = formatLocale$2(_);
        return legend;
      };

      legend.labelFormat = function (_) {
        if (!arguments.length) return legend.locale().format(specifier);
        specifier = formatSpecifier$1(_);
        return legend;
      };

      legend.labelOffset = function (_) {
        if (!arguments.length) return labelOffset;
        labelOffset = +_;
        return legend;
      };

      legend.labelDelimiter = function (_) {
        if (!arguments.length) return labelDelimiter;
        labelDelimiter = _;
        return legend;
      };

      legend.labelWrap = function (_) {
        if (!arguments.length) return labelWrap;
        labelWrap = _;
        return legend;
      };

      legend.useClass = function (_) {
        if (!arguments.length) return useClass;
        if (_ === true || _ === false) {
          useClass = _;
        }
        return legend;
      };

      legend.orient = function (_) {
        if (!arguments.length) return orient;
        _ = _.toLowerCase();
        if (_ == "horizontal" || _ == "vertical") {
          orient = _;
        }
        return legend;
      };

      legend.ascending = function (_) {
        if (!arguments.length) return ascending;
        ascending = !!_;
        return legend;
      };

      legend.classPrefix = function (_) {
        if (!arguments.length) return classPrefix;
        classPrefix = _;
        return legend;
      };

      legend.title = function (_) {
        if (!arguments.length) return title;
        title = _;
        return legend;
      };

      legend.titleWidth = function (_) {
        if (!arguments.length) return titleWidth;
        titleWidth = _;
        return legend;
      };

      legend.textWrap = function (_) {
        if (!arguments.length) return textWrap;
        textWrap = _;
        return legend;
      };

      legend.on = function () {
        var value = legendDispatcher.on.apply(legendDispatcher, arguments);
        return value === legendDispatcher ? legend : value;
      };

      return legend;
    }

    var Legend = /** @class */ (function (_super) {
        __extends(Legend, _super);
        function Legend(owner) {
            var _this = _super.call(this) || this;
            _this._disabled = [];
            _this._owner = owner;
            _this._drawStartPos = "origin";
            var context = _this;
            _this._legendOrdinal = color$1()
                .shape("path", d3Symbol().type(d3SymbolCircle).size(150)())
                .shapePadding(10)
                .shapeRadius(10)
                .on("cellclick", function (d) {
                context.onClick(d, this);
            })
                .on("cellover", function (d) {
                context.onOver(d, _this);
            })
                .on("cellout", function (d) {
                context.onOut(d, _this);
            });
            return _this;
        }
        Legend.prototype.isDisabled = function (d) {
            if (typeof d === "undefined") {
                return false;
            }
            else if (typeof d === "string") {
                return d.indexOf("__") === 0 || this._disabled.indexOf(d) >= 0;
            }
            else if (d instanceof common.Database.Field) {
                return d.id().indexOf("__") === 0 || this._disabled.indexOf(d.id()) >= 0;
            }
            return this._disabled.indexOf(d) >= 0;
        };
        Legend.prototype.filteredFields = function () {
            var _this = this;
            switch (this.dataFamily()) {
                case "2D":
                    return this.fields();
                case "ND":
                    return this.fields().filter(function (d) { return !_this.isDisabled(d); });
            }
            return this.fields();
        };
        Legend.prototype.filteredColumns = function () {
            var _this = this;
            switch (this.dataFamily()) {
                case "2D":
                    return this.columns();
                case "ND":
                    return this.columns().filter(function (d) { return !_this.isDisabled(d); });
            }
            return this.columns();
        };
        Legend.prototype.filteredData = function () {
            var _this = this;
            switch (this.dataFamily()) {
                case "2D":
                    return this.data().filter(function (row) { return !_this.isDisabled(row[0]); });
                case "ND":
                    var disabledCols_1 = {};
                    var anyDisabled_1 = false;
                    this.columns().forEach(function (col, idx) {
                        var disabled = _this.isDisabled(col);
                        disabledCols_1[idx] = disabled;
                        if (disabled) {
                            anyDisabled_1 = true;
                        }
                    });
                    return !anyDisabled_1 ? this.data() : this.data().map(function (row) {
                        return row.filter(function (cell, idx) { return !disabledCols_1[idx]; });
                    });
            }
            return this.data();
        };
        Legend.prototype.isRainbow = function () {
            var widget = this.getWidget();
            return widget && widget._palette && widget._palette.type() === "rainbow";
        };
        Legend.prototype.targetWidget = function (_) {
            if (!arguments.length)
                return this._targetWidget;
            this._targetWidget = _;
            if (this._targetWidgetMonitor) {
                this._targetWidgetMonitor.remove();
                delete this._targetWidgetMonitor;
            }
            if (this._targetWidget) {
                var context_1 = this;
                this._targetWidgetMonitor = this._targetWidget.monitor(function (key, newProp, oldProp, source) {
                    switch (key) {
                        case "chart":
                        case "columns":
                        case "data":
                        case "paletteID":
                            context_1.lazyRender();
                            break;
                    }
                });
            }
            return this;
        };
        Legend.prototype.getWidget = function () {
            if (this._targetWidget) {
                switch (this._targetWidget.classID()) {
                    case "composite_MultiChart":
                        return this._targetWidget.chart();
                }
            }
            return this._targetWidget;
        };
        Legend.prototype.getPalette = function () {
            var widget = this.getWidget();
            if (widget && widget._palette) {
                switch (widget._palette.type()) {
                    case "ordinal":
                        return common.Palette.ordinal(widget._palette.id());
                    case "rainbow":
                        return common.Palette.rainbow(widget._palette.id());
                }
            }
            return common.Palette.ordinal("default");
        };
        Legend.prototype.getPaletteType = function () {
            return this.getPalette().type();
        };
        Legend.prototype.fillColorFunc = function () {
            var widget = this.getWidget();
            if (widget && widget.fillColor) {
                //  Legend will render before the widget, so its possible the widgets palette will not have switched yet...
                if (widget._palette && widget.paletteID && widget._palette.name !== widget.paletteID()) {
                    widget._palette = widget._palette.switch(widget.paletteID());
                }
                return function (row, col, sel) {
                    return widget.fillColor(row, col, sel);
                };
            }
            var palette = common.Palette.ordinal(widget && widget.paletteID ? widget.paletteID() || "default" : "default");
            return function (row, col, sel) {
                return palette(col);
            };
        };
        Legend.prototype.fillColor = function (row, col, sel) {
            return this.fillColorFunc()(row, col, sel);
        };
        Legend.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            this._g = element.append("g")
                .attr("class", "legendOrdinal");
        };
        Legend.prototype.update = function (domNode, element) {
            var _this = this;
            _super.prototype.update.call(this, domNode, element);
            var dataArr = [];
            if (this._targetWidget) {
                switch (this.getPaletteType()) {
                    case "ordinal":
                        var fillColor_1 = this.fillColorFunc();
                        switch (this.dataFamily()) {
                            case "2D":
                                dataArr = this.data().map(function (n) {
                                    return [fillColor_1(n, n[0], false), n[0]];
                                }, this);
                                break;
                            case "ND":
                                var widgetColumns = this.columns().filter(function (col) { return col.indexOf("__") !== 0; });
                                dataArr = widgetColumns.filter(function (n, i) { return i > 0; }).map(function (n) {
                                    return [fillColor_1(undefined, n, false), n];
                                }, this);
                                break;
                            default:
                                var widgetColumns2 = this.columns();
                                dataArr = widgetColumns2.map(function (n) {
                                    return [fillColor_1(undefined, n, false), n];
                                }, this);
                                break;
                        }
                        break;
                    case "rainbow":
                        var palette = this.getPalette();
                        var format$1 = format(this.rainbowFormat());
                        var widget = this.getWidget();
                        var steps = this.rainbowBins();
                        var weightMin = widget._dataMinWeight;
                        var weightMax = widget._dataMaxWeight;
                        var stepWeightDiff = (weightMax - weightMin) / (steps - 1);
                        dataArr.push([palette(weightMin, weightMin, weightMax), format$1(weightMin)]);
                        for (var x = 1; x < steps - 1; ++x) {
                            var mid = stepWeightDiff * x;
                            if (Math.floor(mid) > parseInt(dataArr[0][1])) {
                                mid = Math.floor(mid);
                            }
                            dataArr.push([palette(mid, weightMin, weightMax), format$1(mid)]);
                        }
                        dataArr.push([palette(weightMax, weightMin, weightMax), format$1(weightMax)]);
                        break;
                }
            }
            var ordinal$1 = ordinal()
                .domain(dataArr.map(function (row) { return row[1]; }))
                .range(dataArr.map(function (row) { return row[0]; }));
            var total = 0;
            var colLength = this.columns().length;
            this._legendOrdinal
                .orient(this.orientation())
                .title(this.title())
                .labelWrap(this.labelMaxWidth())
                .scale(ordinal$1)
                .labels(function (d) {
                var val = 0;
                switch (_this.dataFamily()) {
                    case "ND":
                        val = _this.data().reduce(function (acc, n) { return acc + n[d.i + 1]; }, 0);
                        break;
                    case "2D":
                        val = _this.data()[d.i].slice(1, colLength).reduce(function (acc, n) { return acc + n; }, 0);
                        break;
                }
                var disabled = _this.isDisabled(d.domain[d.i]);
                if (!disabled) {
                    total += val;
                }
                return d.domain[d.i] + (!disabled && _this.showSeriesTotal() ? " (" + val + ")" : "");
            });
            this._g.call(this._legendOrdinal);
            this.updateDisabled(element, dataArr);
            var bbox = this.getBBox(true, true);
            this._g.attr("transform", "translate(5,8)");
            this.pos({
                x: this.width() / 2 - bbox.width / 2,
                y: this.height() / 2 - bbox.height / 2
            });
            var legendCellsBbox = this._g.select(".legendCells").node().getBBox();
            var legendCellHeight = legendCellsBbox.height / (dataArr.length || 1);
            var legendTotal = this._g.selectAll(".legendTotal").data(dataArr.length && this.showLegendTotal() ? [total] : []);
            var firstLabel = this._g.select(".label");
            var totalTranslate = "translate(0";
            if (!firstLabel.empty()) {
                var firstLabelTransformSplit = firstLabel.attr("transform").split(",");
                if (firstLabelTransformSplit.length === 1) {
                    totalTranslate = firstLabel.attr("transform").split(" ");
                }
            }
            legendTotal
                .enter()
                .append("text")
                .classed("legendTotal", true)
                .merge(legendTotal)
                .attr("transform", totalTranslate + ", " + (legendCellsBbox.height + (legendCellHeight / (3 / 2))) + ")")
                .text("Total: " + total);
            legendTotal.exit().remove();
        };
        Legend.prototype.updateDisabled = function (element, dataArr) {
            var _this = this;
            element
                .style("cursor", "pointer")
                .selectAll("path.swatch").filter(function (d, i) { return i < dataArr.length; })
                .style("stroke", function (d, i) { return dataArr[i][0]; })
                .style("fill", function (d, i) {
                return _this._disabled.indexOf(d) < 0 ? dataArr[i][0] : "white";
            });
        };
        Legend.prototype.exit = function (domNode, element) {
            _super.prototype.exit.call(this, domNode, element);
        };
        Legend.prototype.onClick = function (d, domNode) {
            switch (this.getPaletteType()) {
                case "ordinal":
                    switch (this.dataFamily()) {
                        case "2D":
                        case "ND":
                            var disabledIdx = this._disabled.indexOf(d);
                            if (disabledIdx < 0) {
                                this._disabled.push(d);
                            }
                            else {
                                this._disabled.splice(disabledIdx, 1);
                            }
                            this._owner.refreshColumns();
                            this._owner.refreshData();
                            this._owner.render();
                            break;
                    }
                    break;
            }
        };
        Legend.prototype.onOver = function (d, domNode) {
            if (api.instanceOfIHighlight(this._owner)) {
                switch (this.getPaletteType()) {
                    case "ordinal":
                        switch (this.dataFamily()) {
                            case "2D":
                            case "ND":
                                if (this._disabled.indexOf(d) < 0) {
                                    this._owner.highlightColumn(d);
                                }
                                break;
                        }
                        break;
                }
            }
        };
        Legend.prototype.onOut = function (d, domNode) {
            if (api.instanceOfIHighlight(this._owner)) {
                switch (this.getPaletteType()) {
                    case "ordinal":
                        switch (this.dataFamily()) {
                            case "2D":
                            case "ND":
                                this._owner.highlightColumn();
                                break;
                        }
                        break;
                }
            }
        };
        Legend.prototype.onDblClick = function (rowData, rowIdx) {
            console.log("Legend onDblClick method");
            console.log("rowData: " + rowData);
            console.log("rowIdx: " + rowIdx);
        };
        Legend.prototype.onMouseOver = function (rowData, rowIdx) {
            console.log("Legend onMouseOver method");
            console.log("rowData: " + rowData);
            console.log("rowIdx: " + rowIdx);
        };
        return Legend;
    }(common.SVGWidget));
    Legend.prototype._class += " layout_Legend";
    Legend.prototype.publish("title", "", "string", "Title");
    Legend.prototype.publish("labelMaxWidth", null, "number", "Max Label Width (pxiels)", null, { optional: true });
    Legend.prototype.publish("orientation", "vertical", "set", "Orientation of Legend rows", ["vertical", "horizontal"], { tags: ["Private"] });
    Legend.prototype.publish("dataFamily", "ND", "set", "Type of data", ["1D", "2D", "ND", "map", "graph", "any"], { tags: ["Private"] });
    Legend.prototype.publish("rainbowFormat", ",", "string", "Rainbow number formatting", null, { tags: ["Private"], optional: true, disable: function (w) { return !w.isRainbow(); } });
    Legend.prototype.publish("rainbowBins", 8, "number", "Number of rainbow bins", null, { tags: ["Private"], disable: function (w) { return !w.isRainbow(); } });
    Legend.prototype.publish("showSeriesTotal", false, "boolean", "Show value next to series");
    Legend.prototype.publish("showLegendTotal", false, "boolean", "Show a total of the series values under the legend", null);

    var css$7 = ".layout_Modal-header{background-color:#3f51b5;overflow:hidden}.layout_Modal-body{background-color:#fff;overflow-y:scroll;overflow-x:hidden}.layout_Modal-annotations,.layout_Modal-title{position:absolute}.layout_Modal-closeButton{cursor:pointer}.layout_Modal-closeButton:hover{opacity:.7}.layout_Modal-closeButton:active{opacity:.5}.layout_Modal-fade{position:fixed;background-color:#000;opacity:.5;z-index:10000}.layout_Modal-content{position:fixed;background-color:#fff;z-index:10100}.layout_Modal-fade-hidden{display:none}.layout_Modal-fadeClickable{cursor:pointer}";
    styleInject(css$7);

    var Modal = /** @class */ (function (_super) {
        __extends(Modal, _super);
        function Modal() {
            var _this = _super.call(this) || this;
            _this._tag = "div";
            return _this;
        }
        Modal.prototype.closeModal = function () {
            this.visible(false);
        };
        Modal.prototype.getRelativeTarget = function () {
            var relativeTarget;
            if (this.relativeTargetId()) {
                relativeTarget = document.getElementById(this.relativeTargetId());
                if (relativeTarget) {
                    return relativeTarget;
                }
            }
            if (!relativeTarget) {
                relativeTarget = this.locateAncestor("layout_Grid");
                if (relativeTarget && relativeTarget.element) {
                    return relativeTarget.element().node();
                }
            }
            return document.body;
        };
        Modal.prototype.setModalSize = function () {
            if (this.fixedHeight() !== null && this.fixedWidth() !== null) {
                this._modal
                    .style("height", this.fixedHeight())
                    .style("width", this.fixedWidth())
                    .style("min-height", null)
                    .style("min-width", null)
                    .style("max-height", null)
                    .style("max-width", null);
            }
            else if (this.minHeight() || this.minWidth()) {
                this._modal
                    .style("min-height", this.minHeight())
                    .style("min-width", this.minWidth())
                    .style("max-height", this.maxHeight())
                    .style("max-width", this.maxWidth());
            }
            var modalRect = this._modal.node().getBoundingClientRect();
            var headerRect = this._modalHeader.node().getBoundingClientRect();
            this._modalBody
                .style("height", (modalRect.height - headerRect.height) + "px")
                .style("width", modalRect.width);
            return modalRect;
        };
        Modal.prototype.setFadePosition = function (rect) {
            this._fade
                .style("top", rect.top + "px")
                .style("left", rect.left + "px")
                .style("width", rect.width + "px")
                .style("height", rect.height + "px");
        };
        Modal.prototype.setModalPosition = function (rect) {
            var modalRect = this.setModalSize();
            if (this.fixedTop() !== null && this.fixedLeft() !== null) {
                this._modal
                    .style("top", "calc(" + this.fixedTop() + " + " + rect.top + "px)")
                    .style("left", "calc(" + this.fixedLeft() + " + " + rect.left + "px)");
            }
            else if (this.fixedHeight() !== null && this.fixedWidth() !== null) {
                this._modal
                    .style("top", (rect.top + (rect.height / 2) - (modalRect.height / 2)) + "px")
                    .style("left", (rect.left + (rect.width / 2) - (modalRect.width / 2)) + "px");
            }
            else if (this.minHeight() || this.minWidth()) {
                var contentRect = this._modal.node().getBoundingClientRect();
                this._modal
                    .style("top", (rect.top + (rect.height / 2) - (contentRect.height / 2)) + "px")
                    .style("left", (rect.left + (rect.width / 2) - (contentRect.width / 2)) + "px");
            }
        };
        Modal.prototype.resize = function (size) {
            _super.prototype.resize.call(this);
            if (this._modal)
                this.setModalSize();
            return this;
        };
        Modal.prototype.enter = function (domNode, element) {
            var _this = this;
            _super.prototype.enter.call(this, domNode, element);
            this._fade = element.append("div")
                .classed("layout_Modal-fade", true)
                .classed("layout_Modal-fadeClickable", this.enableClickFadeToClose())
                .classed("layout_Modal-fade-hidden", !this.showFade());
            var header_h = this.titleFontSize() * 2;
            this._modal = element.append("div")
                .classed("layout_Modal-content", true);
            this._modalHeader = this._modal.append("div")
                .classed("layout_Modal-header", true)
                .style("color", this.titleFontColor())
                .style("font-size", this.titleFontSize() + "px")
                .style("height", header_h + "px");
            this._modalBody = this._modal.append("div")
                .classed("layout_Modal-body", true)
                .style("height", "calc( 100% - " + header_h + "px )")
                .style("overflow-x", this.overflowX())
                .style("overflow-y", this.overflowY());
            this._modalHeader.append("div")
                .classed("layout_Modal-title", true)
                .style("line-height", this.titleFontSize() + "px")
                .style("top", (this.titleFontSize() / 2) + "px")
                .style("left", (this.titleFontSize() / 2) + "px")
                .text(this.formattedTitle());
            this._modalHeaderAnnotations = this._modalHeader.append("div")
                .classed("layout_Modal-annotations", true);
            this._modalHeaderCloseButton = this._modalHeaderAnnotations.append("div")
                .classed("layout_Modal-closeButton", true)
                .html("<i class=\"fa fa-close\"></i>");
            this._modalHeaderAnnotations
                .style("line-height", this.titleFontSize() + "px")
                .style("right", (this.titleFontSize() / 2) + "px")
                .style("top", (this.titleFontSize() / 2) + "px");
            this._modalHeaderCloseButton.on("click", function () {
                _this.closeModal();
            });
            this._fade.on("click", function (n) {
                if (_this.enableClickFadeToClose()) {
                    _this.closeModal();
                }
            });
        };
        Modal.prototype.update = function (domNode, element) {
            _super.prototype.update.call(this, domNode, element);
            element.style("display", this.show() ? null : "none");
            this._fade.classed("layout_Modal-fade-hidden", !this.showFade());
            this._relativeTarget = this.getRelativeTarget();
            this.setModalSize();
            var rect = this._relativeTarget.getBoundingClientRect();
            this.setFadePosition(rect);
            this.setModalPosition(rect);
            if (this.show()) {
                if (!this._widget.target()) {
                    this._widget.target(this._modalBody.node());
                }
                this._widget.resize().render();
            }
            else {
                this._widget
                    .target(null)
                    .render();
            }
        };
        Modal.prototype.exit = function (domNode, element) {
            if (this._widget) {
                this._widget.target(null);
            }
            _super.prototype.exit.call(this, domNode, element);
        };
        Modal.prototype.formattedTitle = function () {
            var title = this.title().trim();
            if (title.length > 0 && title.slice(0, 1) === "(" && title.slice(-1) === ")") {
                return title.slice(1, -1);
            }
            return this.title();
        };
        return Modal;
    }(common.HTMLWidget));
    Modal.prototype._class += " layout_Modal";
    Modal.prototype.publish("title", null, "string", "title");
    Modal.prototype.publish("widget", null, "widget", "widget");
    Modal.prototype.publish("titleFontSize", 18, "number", "titleFontSize (in pixels)");
    Modal.prototype.publish("titleFontColor", "#ffffff", "html-color", "titleFontColor");
    Modal.prototype.publish("relativeTargetId", null, "string", "relativeTargetId");
    Modal.prototype.publish("show", true, "boolean", "show");
    Modal.prototype.publish("showFade", true, "boolean", "showFade");
    Modal.prototype.publish("enableClickFadeToClose", true, "boolean", "enableClickFadeToClose");
    Modal.prototype.publish("minWidth", "400px", "string", "minWidth");
    Modal.prototype.publish("minHeight", "400px", "string", "minHeight");
    Modal.prototype.publish("maxWidth", "800px", "string", "maxWidth");
    Modal.prototype.publish("maxHeight", "800px", "string", "maxHeight");
    Modal.prototype.publish("fixedWidth", null, "string", "fixedWidth");
    Modal.prototype.publish("fixedHeight", null, "string", "fixedHeight");
    Modal.prototype.publish("fixedTop", null, "string", "fixedTop");
    Modal.prototype.publish("fixedLeft", null, "string", "fixedLeft");
    Modal.prototype.publish("overflowX", "hidden", "string", "overflowX");
    Modal.prototype.publish("overflowY", "scroll", "string", "overflowY");

    var css$8 = ".layout_ChartPanel .series.highlight{stroke-width:2px;opacity:1}.layout_ChartPanel .series.lowlight{opacity:.3!important}";
    styleInject(css$8);

    var ChartPanel = /** @class */ (function (_super) {
        __extends(ChartPanel, _super);
        function ChartPanel() {
            var _this = _super.call(this) || this;
            _this._legend = new Legend(_this).enableOverflow(true);
            _this._progressBar = new common.ProgressBar();
            _this._autoScale = false;
            _this._resolutions = {
                tiny: { width: 100, height: 100 },
                small: { width: 300, height: 300 }
            };
            _this._modal = new Modal();
            _this._toggleInfo = new common.ToggleButton().faChar("fa-info-circle").tooltip(".Description")
                .selected(false)
                .on("enabled", function () {
                return _this.description() !== "";
            })
                .on("click", function () {
                if (_this._toggleInfo.selected()) {
                    _this._modal
                        .title(_this.title())
                        .widget(new common.Text().text(_this.description()))
                        .show(true)
                        .render();
                    var origCloseFunc_1 = _this._modal._close;
                    _this._modal._close = function () {
                        _this._toggleInfo
                            .selected(false)
                            .render();
                        _this._modal._close = origCloseFunc_1;
                    };
                }
            })
                .on("mouseMove", function () {
                /*
                this._modal.showPreview(true).render(n => {
                    n.resize().render();
                });
                */
            })
                .on("mouseOut", function () {
                /*
                if (this._modal.showPreview()) {
                    this._modal.show(false).showPreview(false).render();
                }
                */
            });
            _this._toggleData = new common.ToggleButton().faChar("fa-table").tooltip("Data")
                .on("click", function () {
                _this.dataVisible(_this._toggleData.selected());
                _this.render();
            });
            _this._buttonDownload = new common.Button().faChar("fa-download").tooltip("Download")
                .on("click", function () {
                _this.downloadCSV();
            });
            _this._buttonDownloadImage = new common.Button().faChar("fa-image").tooltip("Download Image")
                .on("click", function () {
                _this.downloadPNG();
            });
            _this._toggleLegend = new common.ToggleButton().faChar("fa-list-ul").tooltip("Legend")
                .selected(false)
                .on("click", function () {
                _this.legendVisible(_this._toggleLegend.selected());
                _this.render();
            });
            _this._spacer = new common.Spacer();
            _this._titleBar = new common.TitleBar().buttons([_this._toggleData, _this._buttonDownload, _this._buttonDownloadImage, _this._spacer, _this._toggleLegend]);
            _this._carousel = new Carousel();
            _this._table = new dgrid.Table();
            _this._hideLegendToggleList = ["dgrid_Table"];
            _this._tag = "div";
            return _this;
        }
        ChartPanel.prototype.fields = function (_) {
            if (!arguments.length)
                return _super.prototype.fields.call(this);
            _super.prototype.fields.call(this, _);
            this._legend.fields(_);
            this.refreshFields();
            return this;
        };
        ChartPanel.prototype.refreshFields = function () {
            this._widget.fields(this._legend.filteredFields());
            this._table.fields(this._legend.filteredFields());
            return this;
        };
        ChartPanel.prototype.columns = function (_, asDefault) {
            if (!arguments.length)
                return _super.prototype.columns.call(this);
            _super.prototype.columns.call(this, _, asDefault);
            this._legend.columns(_, asDefault);
            this.refreshColumns();
            return this;
        };
        ChartPanel.prototype.refreshColumns = function () {
            this._widget.columns(this._legend.filteredColumns());
            this._table.columns(this._legend.filteredColumns());
            return this;
        };
        ChartPanel.prototype.data = function (_) {
            if (!arguments.length)
                return _super.prototype.data.call(this);
            _super.prototype.data.call(this, _);
            this._legend.data(_);
            this.refreshData();
            return this;
        };
        ChartPanel.prototype.refreshData = function () {
            this._widget.data(this._legend.filteredData());
            this._table.data(this._legend.filteredData());
            return this;
        };
        ChartPanel.prototype.highlight = function (_) {
            if (!arguments.length)
                return this._highlight;
            this._highlight = _;
            return this;
        };
        ChartPanel.prototype.startProgress = function () {
            this._progressBar.start();
        };
        ChartPanel.prototype.finishProgress = function () {
            this._progressBar.finish();
        };
        ChartPanel.prototype.buttons = function (_) {
            if (!arguments.length)
                return this._titleBar.buttons();
            this._titleBar.buttons(_);
            return this;
        };
        ChartPanel.prototype.downloadCSV = function () {
            var namePrefix = this.downloadTitle() ? this.downloadTitle() : this.title() ? this.title() : "data";
            var nameSuffix = this.downloadTimestampSuffix() ? "_" + common.Utility.timestamp() : "";
            common.Utility.downloadString("CSV", this._widget.export("CSV"), namePrefix + nameSuffix);
            return this;
        };
        ChartPanel.prototype.downloadPNG = function () {
            var widget = this.widget();
            if (widget instanceof common.SVGWidget) {
                if (!this.legendVisible()) {
                    widget.downloadPNG(this.title());
                }
                else {
                    widget.downloadPNG(this.title(), this._legend);
                }
            }
            return this;
        };
        ChartPanel.prototype.highlightColumn = function (column) {
            if (column) {
                var cssTag_1 = "series-" + this.cssTag(column);
                this._centerWA.element().selectAll(".series")
                    .each(function () {
                    var element = d3Select(this);
                    var highlight = element.classed(cssTag_1);
                    element
                        .classed("highlight", highlight)
                        .classed("lowlight", !highlight);
                });
            }
            else {
                this._centerWA.element().selectAll(".series")
                    .classed("highlight", false)
                    .classed("lowlight", false);
            }
            return this;
        };
        ChartPanel.prototype.getResponsiveMode = function () {
            if (!this.enableAutoscaling())
                return "none";
            if (!this._autoScale)
                return "regular";
            if (this.size().width <= this._resolutions.tiny.width || this.size().height <= this._resolutions.tiny.height) {
                return "tiny";
            }
            else if (this.size().width <= this._resolutions.small.width || this.size().height <= this._resolutions.small.height) {
                return "small";
            }
            return "regular";
        };
        ChartPanel.prototype.setOrigSize = function () {
            this._orig_size = JSON.parse(JSON.stringify(this.size()));
        };
        ChartPanel.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            this._modal
                .target(this.target())
                .relativeTargetId(this.id());
            this.top(this._titleBar);
            this.center(this._carousel);
            this.right(this._legend);
            this._legend
                .targetWidget(this._widget)
                .orientation("vertical")
                .title("")
                .visible(false);
            this._progressBar.enter(domNode, element);
            this.setOrigSize();
        };
        ChartPanel.prototype.preUpdateTiny = function (element) {
            element.selectAll("div.body,div.title-text,div.icon-bar").style("display", "none");
        };
        ChartPanel.prototype.preUpdateSmall = function (element) {
            var scale_x = this._orig_size.width / this._resolutions.small.width;
            var scale_y = this._orig_size.height / this._resolutions.small.height;
            this._scale = Math.min(scale_x, scale_y);
            var x_is_smaller = this._scale === scale_x;
            this.size({
                width: x_is_smaller ? this._resolutions.small.width : this._orig_size.width * (1 / this._scale),
                height: !x_is_smaller ? this._resolutions.small.height : this._orig_size.height * (1 / this._scale)
            });
            element.select("div.title-icon").style("position", "static");
            element.selectAll("lhs").style("display", "none");
            element.selectAll("div.body,div.title-text,div.icon-bar").style("display", "");
            element.selectAll("div.data-count").style("visibility", "hidden");
            element.style("transform", "scale(" + this._scale + ")");
        };
        ChartPanel.prototype.preUpdateRegular = function (element) {
            element.selectAll("div.body,div.title-text,div.icon-bar").style("display", "");
            element.selectAll("div.data-count").style("visibility", "hidden");
            element.select("div.title-icon").style("position", "static");
            element.style("transform", "translate(0px,0px) scale(1)");
        };
        ChartPanel.prototype.update = function (domNode, element) {
            if (this._prevdataVisible !== this.dataVisible()) {
                this._prevdataVisible = this.dataVisible();
                this._toggleData.selected(this._prevdataVisible);
                this._carousel.active(this._prevdataVisible ? 1 : 0);
            }
            if (this._prevlegendVisible !== this.legendVisible()) {
                this._prevlegendVisible = this.legendVisible();
                this._toggleLegend.selected(this._prevlegendVisible);
                this._legend.visible(this._prevlegendVisible);
            }
            var _responsiveMode = this.getResponsiveMode();
            switch (_responsiveMode) {
                case "tiny":
                    this.preUpdateTiny(element);
                    break;
                case "small":
                    this.preUpdateSmall(element);
                    break;
                case "regular":
                    this.preUpdateRegular(element);
                    break;
            }
            var chart = this._widget.classID() === "composite_MultiChart" ? this._widget["chart"]() : this._widget;
            this._legend.dataFamily(chart._dataFamily || "any");
            if (this._prevChartDataFamily !== this._legend.dataFamily()) {
                this._prevChartDataFamily = this._legend.dataFamily();
                switch (this._prevChartDataFamily) {
                    case "any":
                        this._toggleLegend.selected(false);
                        this._legend.visible(false);
                        break;
                }
            }
            element.style("box-shadow", this.highlight() ? "inset 0px 0px 0px " + this.highlightSize() + "px " + this.highlightColor() : "none");
            if (this._hideLegendToggleList.indexOf(chart.classID()) !== -1) {
                this._spacer.visible(false);
                this._toggleLegend.visible(false);
            }
            else {
                this._spacer.visible(true);
                this._toggleLegend.visible(true);
            }
            if (this._prevChart !== chart) {
                this._prevChart = chart;
                var widgetIconBar = chart ? chart["_titleBar"] || chart["_iconBar"] : undefined;
                if (widgetIconBar && widgetIconBar instanceof common.IconBar) {
                    this._prevButtons = this._prevButtons || this.buttons().slice();
                    var buttons = widgetIconBar.buttons().concat([
                        new common.Spacer()
                    ], this._prevButtons);
                    widgetIconBar.buttons([]).render();
                    this.buttons(buttons);
                }
                else if (this._prevButtons) {
                    this.buttons(this._prevButtons);
                }
            }
            var hiddenButtons = [];
            if (!this.dataButtonVisible())
                hiddenButtons.push(this._toggleData);
            if (!this.downloadButtonVisible())
                hiddenButtons.push(this._buttonDownload);
            if (!this.downloadImageButtonVisible())
                hiddenButtons.push(this._buttonDownloadImage);
            if (!this.legendButtonVisible())
                hiddenButtons.push(this._toggleLegend);
            this._buttonDownloadImage.enabled(this.widget() instanceof common.SVGWidget);
            this._titleBar
                .hiddenButtons(hiddenButtons)
                .visible(this.titleVisible());
            this.topOverlay(this.titleOverlay() || !this.titleVisible());
            _super.prototype.update.call(this, domNode, element);
            switch (_responsiveMode) {
                case "tiny":
                    this.postUpdateTiny(element);
                    break;
                case "small":
                    this.postUpdateSmall(element);
                    break;
                case "regular":
                    this.postUpdateRegular(element);
                    break;
            }
        };
        ChartPanel.prototype.postUpdateTiny = function (element) {
            element.selectAll("div.body,div.title-text,div.icon-bar").style("display", "none");
            element.selectAll("div.data-count")
                .style("visibility", "visible")
                .style("font-size", (this.titleIconFontSize() / 3) + "px")
                .style("line-height", (this.titleIconFontSize() / 3) + "px")
                .style("left", this.titleIconFontSize() + "px")
                .text(this.data().length);
            element.style("transform", "translate(0px,0px) scale(1)");
            var iconDiv = element.selectAll("div.title-icon");
            var _node = iconDiv.node();
            var _container = element.node().parentElement;
            var containerRect = _container.getBoundingClientRect();
            if (_node) {
                var rect = iconDiv.node().getBoundingClientRect();
                var icon_top = containerRect.height / 2;
                iconDiv
                    .style("position", "absolute")
                    .style("left", "calc(50% - " + rect.width / 2 + "px)")
                    .style("top", icon_top - (rect.height / 2) + "px");
                element.selectAll("div.data-count")
                    .style("position", "absolute")
                    .style("left", "calc(50% + " + rect.width / 2 + "px)")
                    .style("top", icon_top - (rect.height / 2) + "px");
            }
        };
        ChartPanel.prototype.postUpdateSmall = function (element) {
            element.selectAll("lhs").style("display", "none"); // TODO: a bug in Border2?
            element.selectAll("div.title-icon").style("position", "static");
            element.selectAll("div.body,div.title-text,div.icon-bar").style("display", "");
            element.selectAll("div.data-count").style("visibility", "hidden");
            var rect = element.node().getBoundingClientRect();
            var parentRect = element.node().parentElement.getBoundingClientRect();
            element.style("transform", "translate(" + (parentRect.x - rect.x) + "px, " + (parentRect.y - rect.y) + "px) scale(" + this._scale + ")");
        };
        ChartPanel.prototype.postUpdateRegular = function (element) {
            element.selectAll("div.title-icon").style("position", "static");
            element.selectAll("div.body,div.title-text,div.icon-bar").style("display", "");
            element.selectAll("div.data-count").style("visibility", "hidden");
        };
        ChartPanel.prototype.exit = function (domNode, element) {
            this._progressBar.exit(domNode, element);
            this.right(null);
            this._legend.target(null);
            this.center(null);
            this._carousel.target(null);
            this.top(null);
            this._titleBar.target(null);
            this._modal.target(null);
            delete this._prevChart;
            delete this._prevButtons;
            delete this._prevChartDataFamily;
            delete this._prevPos;
            delete this._prevdataVisible;
            delete this._prevlegendVisible;
            _super.prototype.exit.call(this, domNode, element);
        };
        //  Event Handlers  ---
        //  Events  ---
        ChartPanel.prototype.click = function (row, column, selected) {
            // console.log("Click:  " + JSON.stringify(row) + ", " + column + ", " + selected);
        };
        ChartPanel.prototype.dblclick = function (row, column, selected) {
            // console.log("Double click:  " + JSON.stringify(row) + ", " + column + ", " + selected);
        };
        ChartPanel.prototype.vertex_click = function (row, col, sel, more) {
            if (more && more.vertex) ;
        };
        ChartPanel.prototype.vertex_dblclick = function (row, col, sel, more) {
            if (more && more.vertex) ;
        };
        ChartPanel.prototype.edge_click = function (row, col, sel, more) {
            if (more && more.edge) ;
        };
        ChartPanel.prototype.edge_dblclick = function (row, col, sel, more) {
            if (more && more.edge) ;
        };
        return ChartPanel;
    }(Border2));
    ChartPanel.prototype._class += " layout_ChartPanel";
    ChartPanel.prototype.publishReset();
    ChartPanel.prototype.publishProxy("title", "_titleBar");
    ChartPanel.prototype.publish("titleVisible", true, "boolean");
    ChartPanel.prototype.publish("titleOverlay", false, "boolean");
    ChartPanel.prototype.publishProxy("titleIcon", "_titleBar");
    ChartPanel.prototype.publishProxy("titleIconFont", "_titleBar");
    ChartPanel.prototype.publishProxy("titleFont", "_titleBar");
    ChartPanel.prototype.publishProxy("titleIconFontSize", "_titleBar");
    ChartPanel.prototype.publishProxy("titleFontSize", "_titleBar");
    ChartPanel.prototype.publishProxy("description", "_titleBar");
    ChartPanel.prototype.publishProxy("descriptionFont", "_titleBar");
    ChartPanel.prototype.publishProxy("descriptionFontSize", "_titleBar");
    ChartPanel.prototype.publish("dataVisible", false, "boolean", "Show data table");
    ChartPanel.prototype.publish("dataButtonVisible", true, "boolean", "Show data table button");
    ChartPanel.prototype.publish("downloadButtonVisible", true, "boolean", "Show data download button");
    ChartPanel.prototype.publish("downloadImageButtonVisible", false, "boolean", "Show image download button");
    ChartPanel.prototype.publish("downloadTitle", "", "string", "File name when downloaded");
    ChartPanel.prototype.publish("downloadTimestampSuffix", true, "boolean", "Use timestamp as file name suffix");
    ChartPanel.prototype.publish("legendVisible", false, "boolean", "Show legend");
    ChartPanel.prototype.publish("legendButtonVisible", true, "boolean", "Show legend button");
    ChartPanel.prototype.publishProxy("legend_labelMaxWidth", "_legend", "labelMaxWidth");
    ChartPanel.prototype.publishProxy("legend_showSeriesTotal", "_legend", "showSeriesTotal");
    ChartPanel.prototype.publishProxy("legend_showLegendTotal", "_legend", "showLegendTotal");
    ChartPanel.prototype.publish("widget", null, "widget", "Widget", undefined, { render: false });
    ChartPanel.prototype.publish("enableAutoscaling", false, "boolean");
    ChartPanel.prototype.publish("highlightSize", 4, "number");
    ChartPanel.prototype.publish("highlightColor", "#e67e22", "html-color");
    ChartPanel.prototype.publishProxy("progress_halfLife", "_progressBar", "halfLife");
    ChartPanel.prototype.publishProxy("progress_decay", "_progressBar", "decay");
    ChartPanel.prototype.publishProxy("progress_size", "_progressBar", "size");
    ChartPanel.prototype.publishProxy("progress_color", "_progressBar", "color");
    ChartPanel.prototype.publishProxy("progress_blurBar", "_progressBar", "blurBar");
    ChartPanel.prototype.publishProxy("progress_blurSize", "_progressBar", "blurSize");
    ChartPanel.prototype.publishProxy("progress_blurColor", "_progressBar", "blurColor");
    ChartPanel.prototype.publishProxy("progress_blurOpacity", "_progressBar", "blurOpacity");
    ChartPanel.prototype.widget = function (_) {
        if (!arguments.length)
            return this._widget;
        this._carousel.widgets([_, this._table]);
        this._widget = _;
        this._widget
            .fields(this._legend.filteredFields())
            .data(this._legend.filteredData());
        var context = this;
        var tmpAny = this._widget;
        tmpAny.click = function () {
            context.click.apply(context, arguments);
        };
        tmpAny.dblclick = function () {
            context.dblclick.apply(context, arguments);
        };
        tmpAny.vertex_click = function () {
            context.vertex_click.apply(context, arguments);
        };
        tmpAny.vertex_dblclick = function () {
            context.vertex_dblclick.apply(context, arguments);
        };
        tmpAny.edge_click = function () {
            context.edge_click.apply(context, arguments);
        };
        tmpAny.edge_dblclick = function () {
            context.edge_dblclick.apply(context, arguments);
        };
        return this;
    };

    var css$9 = ".layout_FlexGrid{display:flex}.FlexGrid-list-item{overflow:hidden;border-style:solid;flex-grow:1}";
    styleInject(css$9);

    var FlexGrid = /** @class */ (function (_super) {
        __extends(FlexGrid, _super);
        function FlexGrid() {
            return _super.call(this) || this;
        }
        FlexGrid.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            d3Select(domNode.parentNode)
                .style("height", "100%")
                .style("width", "100%");
        };
        FlexGrid.prototype.update = function (domNode, element) {
            var _this = this;
            _super.prototype.update.call(this, domNode, element);
            var context = this;
            var cachedSizes = [];
            this.updateFlexParent(element);
            var listItems = element.selectAll(".FlexGrid-list-item").data(this.widgets(), function (w) { return w.id(); });
            listItems.enter()
                .append("div")
                .classed("FlexGrid-list-item", true)
                .each(function (w) {
                w.target(this);
            })
                .merge(listItems)
                .style("min-height", this.itemMinHeight() + "px")
                .style("min-width", this.itemMinWidth() + "px")
                .style("flex-basis", function (n, i) {
                var flexBasis = _this.widgetsFlexBasis()[i];
                return typeof flexBasis !== "undefined" ? flexBasis : _this.flexBasis();
            })
                .style("flex-grow", function (n, i) {
                var flexGrow = _this.widgetsFlexGrow()[i];
                return typeof flexGrow !== "undefined" ? flexGrow : _this.flexGrow();
            })
                .style("border-width", this.borderWidth() + "px")
                .style("border-color", this.itemBorderColor())
                .each(function () {
                this.firstChild.style.display = "none";
            })
                .each(function () {
                var rect = this.getBoundingClientRect();
                cachedSizes.push([
                    rect.width,
                    rect.height
                ]);
            })
                .each(function (w, i) {
                this.firstChild.style.display = "block";
                w.resize({
                    width: cachedSizes[i][0] - (2 * context.borderWidth()),
                    height: cachedSizes[i][1] - (2 * context.borderWidth())
                });
            });
            listItems.exit().remove();
        };
        FlexGrid.prototype.exit = function (domNode, element) {
            _super.prototype.exit.call(this, domNode, element);
        };
        FlexGrid.prototype.updateFlexParent = function (element) {
            var _this = this;
            element
                .style("height", "100%")
                .style("flex-direction", this.orientation() === "horizontal" ? "row" : "column")
                .style("flex-wrap", this.flexWrap())
                .style("align-items", this.alignItems())
                .style("align-content", this.alignContent())
                .style("overflow-x", function () {
                if (_this.forceXScroll() || (_this.orientation() === "horizontal" && _this.flexWrap() === "nowrap" && !_this.disableScroll())) {
                    return "scroll";
                }
                return "hidden";
            })
                .style("overflow-y", function () {
                if (_this.forceYScroll() || (_this.orientation() === "vertical" && _this.flexWrap() === "nowrap" && !_this.disableScroll())) {
                    return "scroll";
                }
                return "hidden";
            });
        };
        return FlexGrid;
    }(common.HTMLWidget));
    FlexGrid.prototype._class += " layout_FlexGrid";
    FlexGrid.prototype.publish("itemBorderColor", "transparent", "html-color", "Color of list item borders");
    FlexGrid.prototype.publish("borderWidth", 0, "number", "Width of list item borders (pixels)");
    FlexGrid.prototype.publish("orientation", "horizontal", "set", "Controls the flex-direction of the list items", ["horizontal", "vertical"]);
    FlexGrid.prototype.publish("flexWrap", "wrap", "set", "Controls the line wrap when overflow occurs", ["nowrap", "wrap", "wrap-reverse"]);
    FlexGrid.prototype.publish("disableScroll", false, "boolean", "If false, scrollbar will show (when flexWrap is set to 'nowrap')", null, { disable: function (w) { return w.flexWrap() !== "nowrap"; } });
    FlexGrid.prototype.publish("forceXScroll", false, "boolean", "If true, horzontal scrollbar will show");
    FlexGrid.prototype.publish("forceYScroll", false, "boolean", "If true, vertical scrollbar will show");
    FlexGrid.prototype.publish("itemMinHeight", 64, "number", "Minimum height of a list item (pixels)");
    FlexGrid.prototype.publish("itemMinWidth", 64, "number", "Minimum width of a list item (pixels)");
    FlexGrid.prototype.publish("alignItems", "stretch", "set", "Controls normal alignment of items", ["flex-start", "center", "flex-end", "stretch"]);
    FlexGrid.prototype.publish("alignContent", "stretch", "set", "Controls normal alignment of item rows", ["flex-start", "center", "flex-end", "stretch", "space-between", "space-around"]);
    FlexGrid.prototype.publish("flexGrow", 1, "number", "Default flex-grow style for all list items");
    FlexGrid.prototype.publish("flexBasis", "10%", "string", "Default flex-basis style for all list items");
    FlexGrid.prototype.publish("widgetsFlexGrow", [], "array", "Array of flex-grow values keyed on the widgets array");
    FlexGrid.prototype.publish("widgetsFlexBasis", [], "array", "Array of flex-basis values keyed on the widgets array");
    FlexGrid.prototype.publish("widgets", [], "widgetArray", "Array of widgets to be rendered as list items");

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var gridList = createCommonjsModule(function (module, exports) {
    (function (root, factory) {
      {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
      }
    }(commonjsGlobal, function() {

    var GridList = function(items, options) {
      /**
       * A GridList manages the two-dimensional positions from a list of items,
       * within a virtual matrix.
       *
       * The GridList's main function is to convert the item positions from one
       * grid size to another, maintaining as much of their order as possible.
       *
       * The GridList's second function is to handle collisions when moving an item
       * over another.
       *
       * The positioning algorithm places items in columns. Starting from left to
       * right, going through each column top to bottom.
       *
       * The size of an item is expressed using the number of cols and rows it
       * takes up within the grid (w and h)
       *
       * The position of an item is express using the col and row position within
       * the grid (x and y)
       *
       * An item is an object of structure:
       * {
       *   w: 3, h: 1,
       *   x: 0, y: 1
       * }
       */

      this._options = options;
      for (var k in this.defaults) {
        if (!this._options.hasOwnProperty(k)) {
          this._options[k] = this.defaults[k];
        }
      }

      this.items = items;

      this._adjustSizeOfItems();

      this.generateGrid();
    };

    GridList.cloneItems = function(items, _items) {
      /**
       * Clone items with a deep level of one. Items are not referenced but their
       * properties are
       */
      var i,
          k;
      if (_items === undefined) {
        _items = [];
      }
      for (i = 0; i < items.length; i++) {
        // XXX: this is good because we don't want to lose item reference, but
        // maybe we should clear their properties since some might be optional
        if (!_items[i]) {
          _items[i] = {};
        }
        for (k in items[i]) {
          _items[i][k] = items[i][k];
        }
      }
      return _items;
    };

    GridList.prototype = {

      defaults: {
        lanes: 5,
        direction: 'horizontal'
      },

      /**
       * Illustates grid as text-based table, using a number identifier for each
       * item. E.g.
       *
       *  #|  0  1  2  3  4  5  6  7  8  9 10 11 12 13
       *  --------------------------------------------
       *  0| 00 02 03 04 04 06 08 08 08 12 12 13 14 16
       *  1| 01 -- 03 05 05 07 09 10 11 11 -- 13 15 --
       *
       * Warn: Does not work if items don't have a width or height specified
       * besides their position in the grid.
       */
      toString: function() {
        var widthOfGrid = this.grid.length,
            output = '\n #|',
            border = '\n --',
            item,
            i,
            j;

        // Render the table header
        for (i = 0; i < widthOfGrid; i++) {
          output += ' ' + this._padNumber(i, ' ');
          border += '---';
        }    output += border;

        // Render table contents row by row, as we go on the y axis
        for (i = 0; i < this._options.lanes; i++) {
          output += '\n' + this._padNumber(i, ' ') + '|';
          for (j = 0; j < widthOfGrid; j++) {
            output += ' ';
            item = this.grid[j][i];
            output += item ? this._padNumber(this.items.indexOf(item), '0') : '--';
          }
        }    output += '\n';
        return output;
      },

      generateGrid: function() {
        /**
         * Build the grid structure from scratch, with the current item positions
         */
        var i;
        this._resetGrid();
        for (i = 0; i < this.items.length; i++) {
          this._markItemPositionToGrid(this.items[i]);
        }
      },

      resizeGrid: function(lanes) {
        var currentColumn = 0;

        this._options.lanes = lanes;
        this._adjustSizeOfItems();

        this._sortItemsByPosition();
        this._resetGrid();

        // The items will be sorted based on their index within the this.items array,
        // that is their "1d position"
        for (var i = 0; i < this.items.length; i++) {
          var item = this.items[i],
              position = this._getItemPosition(item);

          this._updateItemPosition(
            item, this.findPositionForItem(item, {x: currentColumn, y: 0}));

          // New items should never be placed to the left of previous items
          currentColumn = Math.max(currentColumn, position.x);
        }

        this._pullItemsToLeft();
      },

      findPositionForItem: function(item, start, fixedRow) {
        /**
         * This method has two options for the position we want for the item:
         * - Starting from a certain row/column number and only looking for
         *   positions to its right
         * - Accepting positions for a certain row number only (use-case: items
         *   being shifted to the left/right as a result of collisions)
         *
         * @param {Object<x:Number, y:Number, w:Number, h:Number} item
         * @param {Object<x:Number, y:Number} start Position from which to start
         *     the search.
         * @param {Number} [fixedRow] If provided, we're going to try to find a
         *     position for the new item on it. If doesn't fit there, we're going
         *     to put it on the first row.
         *
         * @returns {Number[2]} x and y.
         */

        var x, y, position;

        // Start searching for a position from the horizontal position of the
        // rightmost item from the grid
        for (x = start.x; x < this.grid.length; x++) {
          if (fixedRow !== undefined) {
            position = [x, fixedRow];

            if (this._itemFitsAtPosition(item, position)) {
              return position;
            }
          } else {
            for (y = start.y; y < this._options.lanes; y++) {
              position = [x, y];

              if (this._itemFitsAtPosition(item, position)) {
                return position;
              }
            }
          }
        }

        // If we've reached this point, we need to start a new column
        var newCol = this.grid.length,
            newRow = 0;

        if (fixedRow !== undefined &&
            this._itemFitsAtPosition(item, [newCol, fixedRow])) {
          newRow = fixedRow;
        }

        return [newCol, newRow];
      },

      moveItemToPosition: function(item, newPosition) {
        var position = this._getItemPosition({
          x: newPosition[0],
          y: newPosition[1],
          w: item.w,
          h: item.h
        });

        this._updateItemPosition(item, [position.x, position.y]);
        this._resolveCollisions(item);
      },

      resizeItem: function(item, size) {
        /**
         * Resize an item and resolve collisions.
         *
         * @param {Object} item A reference to an item that's part of the grid.
         * @param {Object} size
         * @param {Number} [size.w=item.w] The new width.
         * @param {Number} [size.h=item.h] The new height.
         */

        var width = size.w || item.w,
            height = size.h || item.h;

        this._updateItemSize(item, width, height);

        this._resolveCollisions(item);

        this._pullItemsToLeft();
      },

      getChangedItems: function(initialItems, idAttribute) {
        /**
         * Compare the current items against a previous snapshot and return only
         * the ones that changed their attributes in the meantime. This includes both
         * position (x, y) and size (w, h)
         *
         * Since both their position and size can change, the items need an
         * additional identifier attribute to match them with their previous state
         */
        var changedItems = [];

        for (var i = 0; i < initialItems.length; i++) {
          var item = this._getItemByAttribute(idAttribute,
                                              initialItems[i][idAttribute]);

          if (item.x !== initialItems[i].x ||
              item.y !== initialItems[i].y ||
              item.w !== initialItems[i].w ||
              item.h !== initialItems[i].h) {
            changedItems.push(item);
          }
        }

        return changedItems;
      },

      _sortItemsByPosition: function() {
        this.items.sort(function(item1, item2) {
          var position1 = this._getItemPosition(item1),
              position2 = this._getItemPosition(item2);

          // Try to preserve columns.
          if (position1.x != position2.x) {
            return position1.x - position2.x;
          }

          if (position1.y != position2.y) {
            return position1.y - position2.y;
          }

          // The items are placed on the same position.
          return 0;
        }.bind(this));
      },

      _adjustSizeOfItems: function() {
        /**
         * Some items can have 100% height or 100% width. Those dimmensions are
         * expressed as 0. We need to ensure a valid width and height for each of
         * those items as the number of items per lane.
         */

        for (var i = 0; i < this.items.length; i++) {
          var item = this.items[i];

          // This can happen only the first time items are checked.
          // We need the property to have a value for all the items so that the
          // `cloneItems` method will merge the properties properly. If we only set
          // it to the items that need it then the following can happen:
          //
          // cloneItems([{id: 1, autoSize: true}, {id: 2}],
          //            [{id: 2}, {id: 1, autoSize: true}]);
          //
          // will result in
          //
          // [{id: 1, autoSize: true}, {id: 2, autoSize: true}]
          if (item.autoSize === undefined) {
            item.autoSize = item.w === 0 || item.h === 0;
          }

          if (item.autoSize) {
            if (this._options.direction === 'horizontal') {
              item.h = this._options.lanes;
            } else {
              item.w = this._options.lanes;
            }
          }
        }
      },

      _resetGrid: function() {
        this.grid = [];
      },

      _itemFitsAtPosition: function(item, newPosition) {
        /**
         * Check that an item wouldn't overlap with another one if placed at a
         * certain position within the grid
         */

        var position = this._getItemPosition(item),
            x, y;

        // No coordonate can be negative
        if (newPosition[0] < 0 || newPosition[1] < 0) {
          return false;
        }

        // Make sure the item isn't larger than the entire grid
        if (newPosition[1] + position.h > this._options.lanes) {
          return false;
        }

        // Make sure the position doesn't overlap with an already positioned
        // item.
        for (x = newPosition[0]; x < newPosition[0] + position.w; x++) {
          var col = this.grid[x];

          // Surely a column that hasn't even been created yet is available
          if (!col) {
            continue;
          }

          for (y = newPosition[1]; y < newPosition[1] + position.h; y++) {
            // Any space occupied by an item can continue to be occupied by the
            // same item.
            if (col[y] && col[y] !== item) {
              return false;
            }
          }
        }

        return true;
      },

      _updateItemPosition: function(item, position) {
        if (item.x !== null && item.y !== null) {
          this._deleteItemPositionFromGrid(item);
        }

        this._setItemPosition(item, position);

        this._markItemPositionToGrid(item);
      },

      _updateItemSize: function(item, width, height) {
        /**
         * @param {Object} item A reference to a grid item.
         * @param {Number} width The new width.
         * @param {Number} height The new height.
         */

        if (item.x !== null && item.y !== null) {
          this._deleteItemPositionFromGrid(item);
        }

        item.w = width;
        item.h = height;

        this._markItemPositionToGrid(item);
      },

      _markItemPositionToGrid: function(item) {
        /**
         * Mark the grid cells that are occupied by an item. This prevents items
         * from overlapping in the grid
         */

        var position = this._getItemPosition(item),
            x, y;

        // Ensure that the grid has enough columns to accomodate the current item.
        this._ensureColumns(position.x + position.w);

        for (x = position.x; x < position.x + position.w; x++) {
          for (y = position.y; y < position.y + position.h; y++) {
            this.grid[x][y] = item;
          }
        }
      },

      _deleteItemPositionFromGrid: function(item) {
        var position = this._getItemPosition(item),
            x, y;

        for (x = position.x; x < position.x + position.w; x++) {
          // It can happen to try to remove an item from a position not generated
          // in the grid, probably when loading a persisted grid of items. No need
          // to create a column to be able to remove something from it, though
          if (!this.grid[x]) {
            continue;
          }

          for (y = position.y; y < position.y + position.h; y++) {
            // Don't clear the cell if it's been occupied by a different widget in
            // the meantime (e.g. when an item has been moved over this one, and
            // thus by continuing to clear this item's previous position you would
            // cancel the first item's move, leaving it without any position even)
            if (this.grid[x][y] == item) {
              this.grid[x][y] = null;
            }
          }
        }
      },

      _ensureColumns: function(N) {
        /**
         * Ensure that the grid has at least N columns available.
         */
        var i;
        for (i = 0; i < N; i++) {
          if (!this.grid[i]) {
            this.grid.push(new GridCol(this._options.lanes));
          }
        }
      },

      _getItemsCollidingWithItem: function(item) {
        var collidingItems = [];
        for (var i = 0; i < this.items.length; i++) {
          if (item != this.items[i] &&
              this._itemsAreColliding(item, this.items[i])) {
            collidingItems.push(i);
          }
        }
        return collidingItems;
      },

      _itemsAreColliding: function(item1, item2) {
        var position1 = this._getItemPosition(item1),
            position2 = this._getItemPosition(item2);

        return !(position2.x >= position1.x + position1.w ||
                 position2.x + position2.w <= position1.x ||
                 position2.y >= position1.y + position1.h ||
                 position2.y + position2.h <= position1.y);
      },

      _resolveCollisions: function(item) {
        if (!this._tryToResolveCollisionsLocally(item)) {
          this._pullItemsToLeft(item);
        }
        this._pullItemsToLeft();
      },

      _tryToResolveCollisionsLocally: function(item) {
        /**
         * Attempt to resolve the collisions after moving a an item over one or more
         * other items within the grid, by shifting the position of the colliding
         * items around the moving one. This might result in subsequent collisions,
         * in which case we will revert all position permutations. To be able to
         * revert to the initial item positions, we create a virtual grid in the
         * process
         */
        var collidingItems = this._getItemsCollidingWithItem(item);
        if (!collidingItems.length) {
          return true;
        }
        var _gridList = new GridList([], this._options),
            leftOfItem,
            rightOfItem,
            aboveOfItem,
            belowOfItem;

        GridList.cloneItems(this.items, _gridList.items);
        _gridList.generateGrid();

        for (var i = 0; i < collidingItems.length; i++) {
          var collidingItem = _gridList.items[collidingItems[i]],
              collidingPosition = this._getItemPosition(collidingItem);

          // We use a simple algorithm for moving items around when collisions occur:
          // In this prioritized order, we try to move a colliding item around the
          // moving one:
          // 1. to its left side
          // 2. above it
          // 3. under it
          // 4. to its right side
          var position = this._getItemPosition(item);

          leftOfItem = [position.x - collidingPosition.w, collidingPosition.y];
          rightOfItem = [position.x + position.w, collidingPosition.y];
          aboveOfItem = [collidingPosition.x, position.y - collidingPosition.h];
          belowOfItem = [collidingPosition.x, position.y + position.h];

          if (_gridList._itemFitsAtPosition(collidingItem, leftOfItem)) {
            _gridList._updateItemPosition(collidingItem, leftOfItem);
          } else if (_gridList._itemFitsAtPosition(collidingItem, aboveOfItem)) {
            _gridList._updateItemPosition(collidingItem, aboveOfItem);
          } else if (_gridList._itemFitsAtPosition(collidingItem, belowOfItem)) {
            _gridList._updateItemPosition(collidingItem, belowOfItem);
          } else if (_gridList._itemFitsAtPosition(collidingItem, rightOfItem)) {
            _gridList._updateItemPosition(collidingItem, rightOfItem);
          } else {
            // Collisions failed, we must use the pullItemsToLeft method to arrange
            // the other items around this item with fixed position. This is our
            // plan B for when local collision resolving fails.
            return false;
          }
        }
        // If we reached this point it means we managed to resolve the collisions
        // from one single iteration, just by moving the colliding items around. So
        // we accept this scenario and marge the brached-out grid instance into the
        // original one
        GridList.cloneItems(_gridList.items, this.items);
        this.generateGrid();
        return true;
      },

      _pullItemsToLeft: function(fixedItem) {
        /**
         * Build the grid from scratch, by using the current item positions and
         * pulling them as much to the left as possible, removing as space between
         * them as possible.
         *
         * If a "fixed item" is provided, its position will be kept intact and the
         * rest of the items will be layed around it.
         */


        // Start a fresh grid with the fixed item already placed inside
        this._sortItemsByPosition();
        this._resetGrid();

        // Start the grid with the fixed item as the first positioned item
        if (fixedItem) {
          var fixedPosition = this._getItemPosition(fixedItem);
          this._updateItemPosition(fixedItem, [fixedPosition.x, fixedPosition.y]);
        }

        for (var i = 0; i < this.items.length; i++) {
          var item = this.items[i],
              position = this._getItemPosition(item);

          // The fixed item keeps its exact position
          if (fixedItem && item == fixedItem) {
            continue;
          }

          var x = this._findLeftMostPositionForItem(item),
              newPosition = this.findPositionForItem(
                item, {x: x, y: 0}, position.y);

          this._updateItemPosition(item, newPosition);
        }
      },

      _findLeftMostPositionForItem: function(item) {
        /**
         * When pulling items to the left, we need to find the leftmost position for
         * an item, with two considerations in mind:
         * - preserving its current row
         * - preserving the previous horizontal order between items
         */

        var tail = 0,
            position = this._getItemPosition(item);

        for (var i = 0; i < this.grid.length; i++) {
          for (var j = position.y; j < position.y + position.h; j++) {
            var otherItem = this.grid[i][j];

            if (!otherItem) {
              continue;
            }

            var otherPosition = this._getItemPosition(otherItem);

            if (this.items.indexOf(otherItem) < this.items.indexOf(item)) {
              tail = otherPosition.x + otherPosition.w;
            }
          }
        }

        return tail;
      },

      _getItemByAttribute: function(key, value) {
        for (var i = 0; i < this.items.length; i++) {
          if (this.items[i][key] === value) {
            return this.items[i];
          }
        }
        return null;
      },

      _padNumber: function(nr, prefix) {
        // Currently works for 2-digit numbers (<100)
        return nr >= 10 ? nr : prefix + nr;
      },

      _getItemPosition: function(item) {
        /**
         * If the direction is vertical we need to rotate the grid 90 deg to the
         * left. Thus, we simulate the fact that items are being pulled to the top.
         *
         * Since the items have widths and heights, if we apply the classic
         * counter-clockwise 90 deg rotation
         *
         *     [0 -1]
         *     [1  0]
         *
         * then the top left point of an item will become the bottom left point of
         * the rotated item. To adjust for this, we need to subtract from the y
         * position the height of the original item - the width of the rotated item.
         *
         * However, if we do this then we'll reverse some actions: resizing the
         * width of an item will stretch the item to the left instead of to the
         * right; resizing an item that doesn't fit into the grid will push the
         * items around it instead of going on a new row, etc.
         *
         * We found it better to do a vertical flip of the grid after rotating it.
         * This restores the direction of the actions and greatly simplifies the
         * transformations.
         */

        if (this._options.direction === 'horizontal') {
          return item;
        } else {
          return {
            x: item.y,
            y: item.x,
            w: item.h,
            h: item.w
          };
        }
      },

      _setItemPosition: function(item, position) {
        /**
         * See _getItemPosition.
         */

        if (this._options.direction === 'horizontal') {
          item.x = position[0];
          item.y = position[1];
        } else {
          // We're supposed to subtract the rotated item's height which is actually
          // the non-rotated item's width.
          item.x = position[1];
          item.y = position[0];
        }
      }
    };

    var GridCol = function(lanes) {
      for (var i = 0; i < lanes; i++) {
        this.push(null);
      }
    };

    // Extend the Array prototype
    GridCol.prototype = [];

    // This module will have direct access to the GridList class
    return GridList;

    }));
    });

    var _GridList = /*#__PURE__*/Object.freeze({
        'default': gridList,
        __moduleExports: gridList
    });

    var css$a = ".layout_Grid>.ddCell{position:absolute}.layout_Grid>.laneBackground{position:absolute;border-style:solid;border-width:1px;background:#f5f5f5}.layout_Grid>.lane{position:absolute;border-style:none;opacity:.25;border-radius:0;pointer-events:none}.layout_Grid>.ddCell.draggable{border-style:solid;border-width:1px;background-color:#f8f8ff;border-radius:0;cursor:move}.layout_Grid>.ddCell.draggable>.resizeHandle{bottom:0;right:0;width:8px;height:8px;border-style:none;position:absolute;cursor:nwse-resize}.layout_Grid>.ddCell.draggable .resizeHandleDisplay{bottom:2px;right:2px;width:4px;height:4px;border-color:#a9a9a9;border-style:solid;border-width:0 2px 2px 0;background-color:none;position:absolute}.layout_Grid>.ddCell.draggable .resizeHandleDisplay:hover{border-color:orange}.layout_Grid>.dragging{background:repeating-linear-gradient(-45deg,transparent,transparent 4px,hsla(0,0%,39.2%,.1) 0,hsla(0,0%,39.2%,.1) 8px)}.layout_Grid>.dragging,.layout_Grid>.resizing{border:1px solid grey;border-radius:0;position:absolute}.layout_Grid>.resizing{background-color:orange;opacity:.3;background:repeating-linear-gradient(-45deg,transparent,transparent 4px,orange 0,orange 8px)}.layout_Grid>.ddCell.draggable .common_Widget.selected{border:1px solid red;background-color:grey;border-radius:0;position:absolute;background:repeating-linear-gradient(-45deg,transparent,transparent 4px,rgba(100,0,0,.1) 0,rgba(100,0,0,.1) 8px)}.layout_Grid #drag-me:before{content:\"#\" attr(id);font-weight:700}";
    styleInject(css$a);

    var GridList = (_GridList && gridList) || _GridList;
    var Grid = /** @class */ (function (_super) {
        __extends(Grid, _super);
        function Grid() {
            var _this = _super.call(this) || this;
            _this._tag = "div";
            _this._selectionBag = new common.Utility.Selection(_this);
            _this.content([]);
            return _this;
        }
        Grid.prototype.getDimensions = function () {
            var size = { width: 0, height: 0 };
            this.content().forEach(function (cell) {
                if (size.width < cell.gridCol() + cell.gridColSpan()) {
                    size.width = cell.gridCol() + cell.gridColSpan();
                }
                if (size.height < cell.gridRow() + cell.gridRowSpan()) {
                    size.height = cell.gridRow() + cell.gridRowSpan();
                }
            }, this);
            return size;
        };
        Grid.prototype.clearContent = function (widget) {
            this.content(this.content().filter(function (contentWidget) {
                if (!widget) {
                    contentWidget.target(null);
                    return false;
                }
                var w = contentWidget;
                while (w) {
                    if (widget === w) {
                        contentWidget.target(null);
                        return false;
                    }
                    w = w.widget ? w.widget() : null;
                }
                return true;
            }));
        };
        Grid.prototype.setContent = function (row, col, widget, title, rowSpan, colSpan) {
            rowSpan = rowSpan || 1;
            colSpan = colSpan || 1;
            title = title || "";
            this.content(this.content().filter(function (contentWidget) {
                if (contentWidget.gridRow() === row && contentWidget.gridCol() === col) {
                    contentWidget.target(null);
                    return false;
                }
                return true;
            }));
            if (widget) {
                var cell = new Cell()
                    .gridRow(row)
                    .gridCol(col)
                    .widget(widget)
                    .title(title)
                    .gridRowSpan(rowSpan)
                    .gridColSpan(colSpan);
                this.content().push(cell);
            }
            return this;
        };
        Grid.prototype.sortedContent = function () {
            return this.content().sort(function (l, r) {
                if (l.gridRow() === r.gridRow()) {
                    return l.gridCol() - r.gridCol();
                }
                return l.gridRow() - r.gridRow();
            });
        };
        Grid.prototype.getCell = function (row, col) {
            var retVal = null;
            this.content().some(function (cell) {
                if (row >= cell.gridRow() && row < cell.gridRow() + cell.gridRowSpan() &&
                    col >= cell.gridCol() && col < cell.gridCol() + cell.gridColSpan()) {
                    retVal = cell;
                    return true;
                }
                return false;
            });
            return retVal;
        };
        Grid.prototype.getWidgetCell = function (id) {
            var retVal = null;
            this.content().some(function (cell) {
                if (cell.widget().id() === id) {
                    retVal = cell;
                    return true;
                }
                return false;
            });
            return retVal;
        };
        Grid.prototype.getContent = function (id) {
            var retVal = null;
            this.content().some(function (cell) {
                if (cell.widget().id() === id) {
                    retVal = cell.widget();
                    return true;
                }
                return false;
            });
            return retVal;
        };
        Grid.prototype.cellToGridItem = function (cell) {
            return {
                x: cell.gridCol(),
                y: cell.gridRow(),
                w: cell.gridColSpan(),
                h: cell.gridRowSpan(),
                id: cell.id(),
                cell: cell
            };
        };
        Grid.prototype.gridItemToCell = function (item) {
            item.cell
                .gridCol(item.x)
                .gridRow(item.y)
                .gridColSpan(item.w)
                .gridRowSpan(item.h);
        };
        Grid.prototype.resetItemsPos = function () {
            this.origItems.forEach(function (origItem) {
                var item = this.itemsMap[origItem.id];
                item.x = origItem.x;
                item.y = origItem.y;
            }, this);
        };
        Grid.prototype.initGridList = function () {
            this.itemsMap = {};
            this.items = this.content().map(function (cell) {
                var retVal = this.cellToGridItem(cell);
                this.itemsMap[retVal.id] = retVal;
                return retVal;
            }, this);
            this.origItems = this.content().map(this.cellToGridItem);
            this.gridList = new GridList(this.items, {
                direction: this.snapping(),
                lanes: this.snapping() === "horizontal" ? this.snappingRows() : this.snappingColumns()
            });
        };
        Grid.prototype.killGridList = function () {
            this.gridList = null;
            delete this.items;
            delete this.itemsMap;
        };
        Grid.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            this._scrollBarWidth = common.Platform.getScrollbarWidth();
            var context = this;
            this._d3Drag = d3Drag()
                .subject(function (_d) {
                var d = context.cellToGridItem(_d);
                return { x: d.x * context.cellWidth, y: d.y * context.cellHeight };
            })
                .on("start", function (_d) {
                if (!context.designMode())
                    return;
                event.sourceEvent.stopPropagation();
                context.initGridList();
                var d = context.itemsMap[_d.id()];
                context.dragItem = element.append("div")
                    .attr("class", "dragging")
                    .style("transform", function () { return "translate(" + d.x * context.cellWidth + "px, " + d.y * context.cellHeight + "px)"; })
                    .style("width", function () { return d.w * context.cellWidth - context.gutter() + "px"; })
                    .style("height", function () { return d.h * context.cellHeight - context.gutter() + "px"; });
                context.selectionBagClick(_d);
            })
                .on("drag", function (_d) {
                if (!context.designMode())
                    return;
                event.sourceEvent.stopPropagation();
                var d = context.itemsMap[_d.id()];
                if (event.x < 0) {
                    event.x = 0;
                }
                if (event.x + d.w * context.cellWidth > context.snappingColumns() * context.cellWidth) {
                    event.x = context.snappingColumns() * context.cellWidth - d.w * context.cellWidth;
                }
                if (event.y < 0) {
                    event.y = 0;
                }
                if (event.y + d.h * context.cellWidth > context.snappingRows() * context.cellWidth) {
                    event.y = context.snappingRows() * context.cellWidth - d.h * context.cellWidth;
                }
                var pos = [Math.max(0, Math.floor((event.x + context.cellWidth / 2) / context.cellWidth)), Math.max(0, Math.floor((event.y + context.cellHeight / 2) / context.cellHeight))];
                if (d.x !== pos[0] || d.y !== pos[1]) {
                    if (context.snapping() !== "none") {
                        context.resetItemsPos();
                        context.gridList.moveItemToPosition(d, pos);
                    }
                    else {
                        d.x = pos[0];
                        d.y = pos[1];
                    }
                    if (_d.gridCol() !== d.x || _d.gridRow() !== d.y) {
                        context.items.forEach(context.gridItemToCell);
                        context.updateGrid(false, 100);
                    }
                }
                context.dragItem
                    .style("transform", function () { return "translate(" + event.x + "px, " + event.y + "px)"; })
                    .style("width", function () { return d.w * context.cellWidth + "px"; })
                    .style("height", function () { return d.h * context.cellHeight + "px"; });
            })
                .on("end", function () {
                if (!context.designMode())
                    return;
                event.sourceEvent.stopPropagation();
                context.dragItem.remove();
                context.dragItem = null;
                context.killGridList();
            });
            this._d3DragResize = d3Drag()
                .subject(function (_d) {
                var d = context.cellToGridItem(_d);
                return { x: (d.x + d.w - 1) * context.cellWidth, y: (d.y + d.h - 1) * context.cellHeight };
            })
                .on("start", function (_d) {
                if (!context.designMode())
                    return;
                event.sourceEvent.stopPropagation();
                context.initGridList();
                var d = context.itemsMap[_d.id()];
                context.dragItem = element.append("div")
                    .attr("class", "resizing")
                    .style("transform", function () { return "translate(" + d.x * context.cellWidth + "px, " + d.y * context.cellHeight + "px)"; })
                    .style("width", function () { return d.w * context.cellWidth - context.gutter() + "px"; })
                    .style("height", function () { return d.h * context.cellHeight - context.gutter() + "px"; });
                context.dragItemPos = { x: d.x, y: d.y };
            })
                .on("drag", function (_d) {
                if (!context.designMode())
                    return;
                event.sourceEvent.stopPropagation();
                var d = context.itemsMap[_d.id()];
                var pos = [Math.max(0, Math.round(event.x / context.cellWidth)), Math.max(0, Math.round(event.y / context.cellHeight))];
                var size = {
                    w: Math.max(1, pos[0] - d.x + 1),
                    h: Math.max(1, pos[1] - d.y + 1)
                };
                if (d.w !== size.w || d.h !== size.h) {
                    if (context.snapping() !== "none") {
                        context.resetItemsPos();
                        context.gridList.resizeItem(d, size);
                    }
                    else {
                        d.w = size.w;
                        d.h = size.h;
                    }
                    if (_d.gridColSpan() !== d.w || _d.gridRowSpan() !== d.h) {
                        context.items.forEach(context.gridItemToCell);
                        context.updateGrid(d.id, 100);
                    }
                }
                context.dragItem
                    .style("width", function () { return (-d.x + 1) * context.cellWidth + event.x - context.gutter() + "px"; })
                    .style("height", function () { return (-d.y + 1) * context.cellHeight + event.y - context.gutter() + "px"; });
            })
                .on("end", function () {
                if (!context.designMode())
                    return;
                event.sourceEvent.stopPropagation();
                context.dragItem.remove();
                context.dragItem = null;
                context.killGridList();
            });
        };
        Grid.prototype.updateGrid = function (resize, transitionDuration, _noRender) {
            if (transitionDuration === void 0) { transitionDuration = 0; }
            transitionDuration = transitionDuration || 0;
            var context = this;
            this.divItems
                .classed("draggable", this.designMode())
                .transition().duration(transitionDuration)
                .style("left", function (d) { return d.gridCol() * context.cellWidth + context.gutter() / 2 + "px"; })
                .style("top", function (d) { return d.gridRow() * context.cellHeight + context.gutter() / 2 + "px"; })
                .style("width", function (d) { return d.gridColSpan() * context.cellWidth - context.gutter() + "px"; })
                .style("height", function (d) { return d.gridRowSpan() * context.cellHeight - context.gutter() + "px"; })
                .on("end", function (d) {
                d
                    .surfaceShadow_default(context.surfaceShadow())
                    .surfacePadding_default(context.surfacePadding())
                    .surfaceBorderWidth_default(context.surfaceBorderWidth())
                    .surfaceBackgroundColor_default(context.surfaceBackgroundColor());
                if (resize === true || resize === d.id()) {
                    d
                        .resize()
                        .lazyRender();
                }
            });
        };
        Grid.prototype.update = function (domNode, element2) {
            _super.prototype.update.call(this, domNode, element2);
            this._placeholderElement.style("overflow-x", this.fitTo() === "width" ? "hidden" : null);
            this._placeholderElement.style("overflow-y", this.fitTo() === "width" ? "scroll" : null);
            var dimensions = this.getDimensions();
            var clientWidth = this.width() - (this.fitTo() === "width" ? this._scrollBarWidth : 0);
            this.cellWidth = clientWidth / dimensions.width;
            this.cellHeight = this.fitTo() === "all" ? this.height() / dimensions.height : this.cellWidth;
            if (this.designMode()) {
                var cellLaneRatio = Math.min(this.width() / this.snappingColumns(), this.height() / this.snappingRows());
                var laneWidth = Math.floor(cellLaneRatio);
                this.cellWidth = laneWidth;
                this.cellHeight = this.cellWidth;
            }
            //  Grid  ---
            var context = this;
            var divItems = element2.selectAll("#" + this.id() + " > .ddCell").data(this.content(), function (d) { return d.id(); });
            this.divItems = divItems.enter().append("div")
                .attr("class", "ddCell")
                .each(function (d) {
                d.target(this);
                d.__grid_watch = d.monitor(function (key, newVal, oldVal) {
                    if (context._renderCount && (key === "snapping" || key.indexOf("grid") === 0) && newVal !== oldVal) {
                        if (!context.gridList) {
                            //  API Call  (only needed when not dragging) ---
                            context.initGridList();
                            if (context.snapping() !== "none") {
                                context.gridList.resizeGrid(context.snapping() === "horizontal" ? context.snappingRows() : context.snappingColumns());
                            }
                            context.items.forEach(context.gridItemToCell);
                            context.updateGrid(d.id(), 100);
                            context.killGridList();
                        }
                    }
                });
                var element = d3Select(this);
                element.append("div")
                    .attr("class", "resizeHandle")
                    .call(context._d3DragResize)
                    .append("div")
                    .attr("class", "resizeHandleDisplay");
            }).merge(divItems);
            this.divItems.each(function (d) {
                var element = d3Select(this);
                if (context.designMode()) {
                    element.call(context._d3Drag);
                }
                else {
                    element
                        .on("mousedown.drag", null)
                        .on("touchstart.drag", null);
                }
            });
            this.divItems.select(".resizeHandle")
                .style("display", this.designMode() ? null : "none");
            this.updateGrid(true);
            divItems.exit()
                .each(function (d) {
                d.target(null);
                if (d.__grid_watch) {
                    d.__grid_watch.remove();
                }
            })
                .remove();
            //  Snapping  ---
            var lanesBackground = element2.selectAll("#" + this.id() + " > .laneBackground").data(this.designMode() ? [""] : []);
            lanesBackground.enter().insert("div", ":first-child")
                .attr("class", "laneBackground")
                .style("left", "1px")
                .style("top", "1px")
                .on("click", function () {
                context.selectionBagClear();
            })
                .merge(lanesBackground)
                .style("width", (this.snappingColumns() * this.cellWidth) + "px")
                .style("height", (this.snappingRows() * this.cellHeight) + "px");
            lanesBackground.exit()
                .each(function () {
                context.selectionBagClear();
            })
                .remove();
            var lanes = element2.selectAll("#" + this.id() + " > .lane").data(this.designMode() ? [""] : []);
            lanes.enter().append("div")
                .attr("class", "lane")
                .style("left", "1px")
                .style("top", "1px");
            lanes
                .style("display", this.showLanes() ? null : "none")
                .style("width", (this.snappingColumns() * this.cellWidth) + "px")
                .style("height", (this.snappingRows() * this.cellHeight) + "px")
                .style("background-image", "linear-gradient(to right, grey 1px, transparent 1px), linear-gradient(to bottom, grey 1px, transparent 1px)")
                .style("background-size", this.cellWidth + "px " + this.cellHeight + "px");
            lanes.exit()
                .remove();
        };
        Grid.prototype.exit = function (domNode, element) {
            this.content().forEach(function (w) { return w.target(null); });
            _super.prototype.exit.call(this, domNode, element);
        };
        Grid.prototype._createSelectionObject = function (d) {
            return {
                _id: d._id,
                element: function () {
                    return d._element;
                },
                widget: d
            };
        };
        Grid.prototype.selection = function (_) {
            if (!arguments.length)
                return this._selectionBag.get().map(function (d) { return d._id; });
            this._selectionBag.set(_.map(function (row) {
                return this._createSelectionObject(row);
            }, this));
            return this;
        };
        Grid.prototype.selectionBagClear = function () {
            if (!this._selectionBag.isEmpty()) {
                this._selectionBag.clear();
                this.postSelectionChange();
            }
        };
        Grid.prototype.selectionBagClick = function (d) {
            if (d !== null) {
                var selectionObj = this._createSelectionObject(d);
                if (event.sourceEvent.ctrlKey) {
                    if (this._selectionBag.isSelected(selectionObj)) {
                        this._selectionBag.remove(selectionObj);
                        this.postSelectionChange();
                    }
                    else {
                        this._selectionBag.append(selectionObj);
                        this.postSelectionChange();
                    }
                }
                else {
                    var selected = this._selectionBag.get();
                    if (selected.length === 1 && selected[0]._id === selectionObj._id) {
                        this.selectionBagClear();
                    }
                    else {
                        this._selectionBag.set([selectionObj]);
                    }
                    this.postSelectionChange();
                }
            }
        };
        Grid.prototype.postSelectionChange = function () {
        };
        Grid.prototype.applyLayout = function (layoutArr) {
            this.divItems.each(function (d, i) {
                if (layoutArr[i]) {
                    var _a = layoutArr[i], x = _a[0], y = _a[1], w = _a[2], h = _a[3];
                    d
                        .gridCol(x)
                        .gridRow(y)
                        .gridColSpan(w)
                        .gridRowSpan(h);
                }
            });
            this.updateGrid(true);
        };
        Grid.prototype.vizActivation = function (elem) {
        };
        return Grid;
    }(common.HTMLWidget));
    Grid.prototype._class += " layout_Grid";
    Grid.prototype.publish("designMode", false, "boolean", "Design Mode", null, { tags: ["Basic"] });
    Grid.prototype.publish("showLanes", true, "boolean", "Show snapping lanes when in design mode", null, { tags: ["Basic"], disable: function (w) { return !w.designMode(); } });
    Grid.prototype.publish("fitTo", "all", "set", "Sizing Strategy", ["all", "width"], { tags: ["Basic"] });
    Grid.prototype.publish("snapping", "vertical", "set", "Snapping Strategy", ["vertical", "horizontal", "none"]);
    Grid.prototype.publish("snappingColumns", 12, "number", "Snapping Columns");
    Grid.prototype.publish("snappingRows", 16, "number", "Snapping Rows");
    Grid.prototype.publish("gutter", 6, "number", "Gap Between Widgets", null, { tags: ["Basic"] });
    Grid.prototype.publish("surfaceShadow", true, "boolean", "3D Shadow");
    Grid.prototype.publish("surfacePadding", null, "string", "Cell Padding (px)", null, { tags: ["Intermediate"] });
    Grid.prototype.publish("surfaceBorderWidth", 1, "number", "Width (px) of Cell Border", null, { tags: ["Intermediate"] });
    Grid.prototype.publish("surfaceBackgroundColor", null, "html-color", "Surface Background Color", null, { tags: ["Advanced"] });
    Grid.prototype.publish("content", [], "widgetArray", "widgets", null, { tags: ["Basic"], render: false });

    var HorizontalList = /** @class */ (function (_super) {
        __extends(HorizontalList, _super);
        function HorizontalList() {
            var _this = _super.call(this) || this;
            _this.orientation_default("horizontal");
            _this.flexWrap_default("nowrap");
            return _this;
        }
        return HorizontalList;
    }(FlexGrid));
    HorizontalList.prototype._class += " layout_HorizontalList";

    var css$b = ".layout_Layered{pointer-events:none}.layout_Layered>.container>.content{position:absolute}.layout_Layered>.container>.content>div>.common_Widget,.layout_Layered>.container>.content>div>svg>.common_Widget{pointer-events:all}";
    styleInject(css$b);

    var Layered = /** @class */ (function (_super) {
        __extends(Layered, _super);
        function Layered() {
            var _this = _super.call(this) || this;
            _this._tag = "div";
            _this._widgetPlacements = [];
            _this._widgetRatios = [];
            return _this;
        }
        Layered.prototype.addLayer = function (widget, placement, widthRatio, heightRatio) {
            if (placement === void 0) { placement = "default"; }
            if (widthRatio === void 0) { widthRatio = 1; }
            if (heightRatio === void 0) { heightRatio = 1; }
            var widgets = this.widgets();
            widgets.push(widget ? widget : new common.Text().text("No widget defined for layer."));
            this.widgets(widgets);
            this._widgetPlacements.push(placement);
            this._widgetRatios.push([widthRatio, heightRatio]);
            return this;
        };
        Layered.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            this._contentContainer = element.append("div")
                .attr("class", "container");
        };
        Layered.prototype.update = function (domNode, element) {
            _super.prototype.update.call(this, domNode, element);
            var context = this;
            element.style("padding", this.surfacePadding() + "px");
            var content = this._contentContainer.selectAll(".content.id" + this.id()).data(this.widgets(), function (d) { return d.id(); });
            content.enter().append("div")
                .attr("class", "content id" + this.id())
                .each(function (widget, idx) {
                widget.target(this);
            })
                .merge(content)
                .each(function (widget, idx) {
                var clientSize = {
                    width: context.clientWidth(),
                    height: context.clientHeight()
                };
                var widgetSize = context.widgetSize(idx, clientSize);
                var widgetPosition = context.widgetPosition(idx, clientSize, widgetSize);
                console.log("widgetPosition", widgetPosition);
                this.style.top = widgetPosition.y + "px";
                this.style.left = widgetPosition.x + "px";
                widget
                    .resize(widgetSize)
                    .render();
            });
            content.exit()
                .each(function (widget, idx) {
                widget
                    .target(null);
            })
                .remove();
            content.order();
        };
        Layered.prototype.widgetSize = function (idx, clientSize) {
            if (this._widgetPlacements[idx] === "default") {
                return {
                    width: clientSize.width * this._widgetRatios[idx][0],
                    height: clientSize.height * this._widgetRatios[idx][1]
                };
            }
            else {
                return {
                    width: clientSize.width * this._widgetRatios[idx][0],
                    height: clientSize.height * this._widgetRatios[idx][1]
                };
            }
        };
        Layered.prototype.widgetPosition = function (idx, clientSize, widgetSize) {
            switch (this._widgetPlacements[idx]) {
                default:
                    return {
                        x: 0,
                        y: 0
                    };
                case "top":
                    return {
                        x: (clientSize.width / 2) - (widgetSize.width / 2),
                        y: 0
                    };
                case "bottom":
                    return {
                        x: (clientSize.width / 2) - (widgetSize.width / 2),
                        y: clientSize.height - widgetSize.height
                    };
                case "left":
                    return {
                        x: 0,
                        y: (clientSize.height / 2) - (widgetSize.height / 2)
                    };
                case "right":
                    return {
                        x: clientSize.width - widgetSize.width,
                        y: (clientSize.height / 2) - (widgetSize.height / 2)
                    };
                case "center":
                    return {
                        x: (clientSize.width / 2) - (widgetSize.width / 2),
                        y: (clientSize.height / 2) - (widgetSize.height / 2)
                    };
            }
        };
        return Layered;
    }(common.HTMLWidget));
    Layered.prototype._class += " layout_Layered";
    Layered.prototype.publish("surfacePadding", 0, "number", "Padding");
    Layered.prototype.publish("widgets", [], "widgetArray", "widgets", null, { tags: ["Private"] });

    var Popup = /** @class */ (function (_super) {
        __extends(Popup, _super);
        function Popup() {
            var _this = _super.call(this) || this;
            _this._tag = "div";
            _this._surfaceButtons = [];
            return _this;
        }
        Popup.prototype.updateState = function (visible) {
            visible = visible || !this.popupState();
            this.popupState(visible).render();
        };
        Popup.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            this.widget()
                .target(domNode);
            this._originalPosition = this.position();
        };
        Popup.prototype.update = function (domNode, element) {
            _super.prototype.update.call(this, domNode, element);
            element
                .style("visibility", this.popupState() ? null : "hidden")
                .style("opacity", this.popupState() ? null : 0)
                .style("width", this.shrinkWrap() ? this.widget().width() + "px" : this._size.width + "px")
                .style("height", this.shrinkWrap() ? this.widget().height() + "px" : this._size.height + "px");
            if (this.widget().size().height === 0) {
                this.widget().resize(this.size());
            }
        };
        Popup.prototype.postUpdate = function (domNode, element) {
            var left;
            var top;
            switch (this.centerPopup()) {
                case "container":
                    if (this._placeholderElement) {
                        left = parseInt(this._placeholderElement.style("width")) / 2 - this.widget().width() / 2;
                        top = parseInt(this._placeholderElement.style("height")) / 2 - this.widget().height() / 2;
                    }
                    this.position("absolute");
                    break;
                case "window":
                    left = window.innerWidth / 2 - this.widget().width() / 2;
                    top = window.innerHeight / 2 - this.widget().height() / 2;
                    this.position("fixed");
                    break;
                default:
                    left = 0;
                    top = 0;
                    this.position(this._originalPosition);
                    break;
            }
            this.pos({ x: left, y: top });
            _super.prototype.postUpdate.call(this, domNode, element);
            element
                .style("position", this.position())
                .style("left", this.left() + "px")
                .style("right", this.right() + "px")
                .style("top", this.top() + "px")
                .style("bottom", this.bottom() + "px");
        };
        Popup.prototype.exit = function (domNode, element) {
            if (this.widget()) {
                this.widget().target(null);
            }
            _super.prototype.exit.call(this, domNode, element);
        };
        Popup.prototype.click = function (obj) {
            console.log("Clicked: " + obj.id);
        };
        return Popup;
    }(common.HTMLWidget));
    Popup.prototype._class += " layout_Popup";
    Popup.prototype.publish("popupState", false, "boolean", "State of the popup, visible (true) or hidden (false)", null, {});
    Popup.prototype.publish("shrinkWrap", false, "boolean", "The popup parent container either shrinks to the size of its contents (true) or expands to fit thge popup's parentDiv (false)", null, {});
    Popup.prototype.publish("centerPopup", "none", "set", "Center the widget in its container element (target) or in the window", ["none", "container", "window"], {});
    Popup.prototype.publish("top", null, "number", "Top position property of popup", null, {});
    Popup.prototype.publish("bottom", null, "number", "Bottom position property of popup", null, {});
    Popup.prototype.publish("left", null, "number", "Left position property of popup", null, {});
    Popup.prototype.publish("right", null, "number", "Right position property of popup", null, {});
    Popup.prototype.publish("position", "relative", "set", "Value of the 'position' property", ["absolute", "relative", "fixed", "static", "initial", "inherit"], { tags: ["Private"] });
    Popup.prototype.publish("widget", null, "widget", "Widget", null, { tags: ["Private"] });

    var css$c = ".layout_Tabbed .tab-button{position:relative;top:1px;display:inline-block;border-left:1px solid #ddd;border-top:1px solid #ddd;border-right:1px solid #ddd;background-color:transparent;margin-right:4px;padding:2px 2px 4px;background-color:#ccc}.layout_Tabbed .tab-button.active{background-color:#fff;z-index:999}.layout_Tabbed .on_bottom .tab-button{border-bottom:1px solid #ddd;border-top:none;top:-1px}";
    styleInject(css$c);

    var Tabbed = /** @class */ (function (_super) {
        __extends(Tabbed, _super);
        function Tabbed() {
            var _this = _super.call(this) || this;
            _this._tag = "div";
            return _this;
        }
        Tabbed.prototype.clearTabs = function () {
            this.labels([]);
            this.widgets([]);
            return this;
        };
        Tabbed.prototype.addTab = function (widget, label, isActive, callback) {
            var widgetSize = widget.size();
            if (widgetSize.width === 0 && widgetSize.height === 0) {
                widget.size({ width: "100%", height: "100%" });
            }
            var labels = this.labels();
            var widgets = this.widgets();
            if (isActive) {
                this.activeTabIdx(this.widgets().length);
            }
            labels.push(label);
            var surface = new Surface().widget(widget ? widget : new common.Text().text("No widget defined for tab"));
            widgets.push(surface);
            this.labels(labels);
            this.widgets(widgets);
            if (callback) {
                callback(surface);
            }
            return this;
        };
        Tabbed.prototype.widgetSize = function (widgetDiv) {
            var width = this.clientWidth();
            var height = this.clientHeight();
            var tcBox = this._tabContainer.node().getBoundingClientRect();
            if (typeof (tcBox.height) !== "undefined") {
                height -= tcBox.height;
            }
            return { width: width, height: height };
        };
        Tabbed.prototype.enter = function (domNode, element) {
            _super.prototype.enter.call(this, domNode, element);
            this._tabContainer = element.append("div");
            this._contentContainer = element.append("div");
        };
        Tabbed.prototype.update = function (domNode, element) {
            _super.prototype.update.call(this, domNode, element);
            var context = this;
            element.style("padding", this.surfacePadding_exists() ? this.surfacePadding() + "px" : null);
            var tabs = this._tabContainer.selectAll(".tab-button.id" + this.id()).data(this.showTabs() ? this.labels() : [], function (d) { return d; });
            tabs.enter().append("span")
                .attr("class", "tab-button id" + this.id())
                .style("cursor", "pointer")
                .on("click", function (d, idx) {
                context.click(context.widgets()[idx].widget(), d, idx);
                context
                    .activeTabIdx(idx)
                    .render();
            }).merge(tabs)
                .classed("active", function (d, idx) { return context.activeTabIdx() === idx; })
                .text(function (d) { return d; });
            tabs.exit().remove();
            var content = this._contentContainer.selectAll(".tab-content.id" + this.id()).data(this.widgets(), function (d) { return d.id(); });
            content.enter().append("div")
                .attr("class", "tab-content id" + this.id())
                .each(function (widget, idx) {
                widget.target(this);
            }).merge(content)
                .classed("active", function (d, idx) { return context.activeTabIdx() === idx; })
                .style("display", function (d, idx) { return context.activeTabIdx() === idx ? "block" : "none"; })
                .each(function (surface, idx) {
                surface.visible(context.activeTabIdx() === idx);
                if (context.activeTabIdx() === idx) {
                    var wSize = context.widgetSize(d3Select(this));
                    surface
                        .surfaceBorderWidth(context.showTabs() ? null : 0)
                        .surfacePadding(context.showTabs() ? null : 0)
                        .resize(wSize);
                }
            });
            content.exit()
                .each(function (widget, idx) {
                widget
                    .target(null);
            })
                .remove();
            switch (this.tabLocation()) {
                case "bottom":
                    this._tabContainer
                        .attr("class", "on_bottom")
                        .style("top", (this._contentContainer.node().offsetHeight + this.surfacePadding()) + "px")
                        .style("position", "absolute");
                    this._contentContainer
                        .style("top", this.surfacePadding_exists() ? this.surfacePadding() + "px" : null)
                        .style("position", "absolute");
                    break;
                default:
                    this._tabContainer
                        .attr("class", "on_top")
                        .style("top", null)
                        .style("position", "relative");
                    this._contentContainer
                        .style("top", (this._tabContainer.node().offsetHeight + this.surfacePadding()) + "px")
                        .style("position", "absolute");
                    break;
            }
        };
        Tabbed.prototype.click = function (widget, column, idx) {
        };
        return Tabbed;
    }(common.HTMLWidget));
    Tabbed.prototype._class += " layout_Tabbed";
    Tabbed.prototype.publish("showTabs", true, "boolean", "Show Tabs", null, {});
    Tabbed.prototype.publish("surfacePadding", 4, "number", "Padding");
    Tabbed.prototype.publish("activeTabIdx", 0, "number", "Index of active tab", null, {});
    Tabbed.prototype.publish("labels", [], "array", "Array of tab labels sharing an index with ", null, { tags: ["Private"] });
    Tabbed.prototype.publish("tabLocation", "top", "set", "Position the tabs at the bottom of the widget", ["top", "bottom"], { tags: ["Private"] });
    Tabbed.prototype.publish("widgets", [], "widgetArray", "widgets", null, { tags: ["Private"] });

    var css$d = ".layout_Toolbar{height:100%;background-color:#ddd;white-space:nowrap;overflow:hidden}.layout_Toolbar .toolbar-title{display:inline-block;position:relative;top:50%;transform:translateY(-50%);-ms-transform:translateY(-50%);margin-left:4px;font-weight:700;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.layout_Toolbar .toolbar-child{position:relative;top:50%;transform:translateY(-50%);-ms-transform:translateY(-50%);float:right;margin-left:4px;margin-right:4px;line-height:16px}";
    styleInject(css$d);

    function Toolbar() {
        common.HTMLWidget.call(this);
        this._tag = "div";
    }
    Toolbar.prototype = Object.create(common.HTMLWidget.prototype);
    Toolbar.prototype.constructor = Toolbar;
    Toolbar.prototype._class += " layout_Toolbar";
    Toolbar.prototype.publish("title", "", "string", "Title", null, { tags: ["Intermediate"] });
    Toolbar.prototype.publish("fontSize", null, "number", "Title Font Size (px)", null, { tags: ["Advanced"], optional: true });
    Toolbar.prototype.publish("fontColor", null, "html-color", "Title Font Color", null, { tags: ["Advanced"], optional: true });
    Toolbar.prototype.publish("fontFamily", null, "string", "Title Font Family", null, { tags: ["Advanced"], optional: true });
    Toolbar.prototype.publish("fontBold", true, "boolean", "Enable Bold Title Font", null, { tags: ["Advanced"], optional: true });
    Toolbar.prototype.publish("backgroundColor", null, "html-color", "Background Color", null, { tags: ["Intermediate"], optional: true });
    Toolbar.prototype.publish("responsive", true, "boolean", "Adapts to pixel width", null, { tags: ["Basic"] });
    Toolbar.prototype.publish("widgets", [], "widgetArray", "Child widgets of the toolbar", null, { tags: ["Basic"] });
    Toolbar.prototype.publish("widgetClasses", [], "array", "Array of Html Element classes to be assigned to the child widgets (shares index with widgets param)", null, { tags: ["Basic"] });
    Toolbar.prototype.enter = function (domNode, element) {
        common.HTMLWidget.prototype.enter.apply(this, arguments);
    };
    Toolbar.prototype.update = function (domNode, element) {
        common.HTMLWidget.prototype.update.apply(this, arguments);
        var context = this;
        element
            .attr("title", context.title())
            .style("background-color", this.backgroundColor());
        var title = element.selectAll("div.toolbar-title")
            .data(this.title() ? [this.title()] : []);
        title.enter().append("div")
            .classed("toolbar-title", true)
            .append("span");
        title.selectAll("div.toolbar-title > span")
            .style("font-size", this.fontSize_exists() ? this.fontSize() + "px" : null)
            .style("color", this.fontColor_exists() ? this.fontColor() : null)
            .style("font-family", this.fontFamily_exists() ? this.fontFamily() : null)
            .style("font-weight", this.fontBold_exists() ? (this.fontBold() ? "bold" : "normal") : null)
            .style("background-color", this.backgroundColor_exists() ? this.backgroundColor() : null)
            .text(context.title());
        title.exit().remove();
        var childWidgets = element.selectAll("div.toolbar-child")
            .data(this.widgets() !== null ? this.widgets() : [], function (d) { return d.id(); });
        childWidgets.enter().insert("div", "div.toolbar-title")
            .each(function (d, i) {
            var widgetClass = context.widgetClasses()[i] ? context.widgetClasses()[i] + " toolbar-child" : "toolbar-child";
            d3Select(this).classed(widgetClass, true);
            d.target(this);
        });
        childWidgets.exit().each(function (d) {
            d.target(null);
        }).remove();
        childWidgets.order();
    };
    Toolbar.prototype.render = function (callback) {
        var context = this;
        common.HTMLWidget.prototype.render.call(this, function (w) {
            var toolbarBBox = context.element().node().getBoundingClientRect();
            var minX = toolbarBBox.left + toolbarBBox.width;
            context.element().selectAll("div.toolbar-child")
                .each(function (d, i) {
                var childBBox = this.getBoundingClientRect();
                if (minX > childBBox.left)
                    minX = childBBox.left;
            });
            context.element().select(".toolbar-title")
                .style("width", (minX - toolbarBBox.left - 4) + "px");
            if (callback) {
                callback(w);
            }
        });
    };
    Toolbar.prototype.exit = function (domNode, element) {
        common.HTMLWidget.prototype.exit.apply(this, arguments);
        this.widgets().forEach(function (w) {
            w.target(null);
        });
    };

    var VerticalList = /** @class */ (function (_super) {
        __extends(VerticalList, _super);
        function VerticalList() {
            var _this = _super.call(this) || this;
            _this.orientation_default("vertical");
            _this.flexWrap_default("nowrap");
            return _this;
        }
        return VerticalList;
    }(FlexGrid));
    VerticalList.prototype._class += " layout_VerticalList";

    exports.AbsoluteSurface = AbsoluteSurface;
    exports.Accordion = Accordion;
    exports.BUILD_VERSION = BUILD_VERSION;
    exports.Border = Border;
    exports.Border2 = Border2;
    exports.Carousel = Carousel;
    exports.Cell = Cell;
    exports.ChartPanel = ChartPanel;
    exports.FlexGrid = FlexGrid;
    exports.Grid = Grid;
    exports.HorizontalList = HorizontalList;
    exports.Layered = Layered;
    exports.Legend = Legend;
    exports.Modal = Modal;
    exports.PKG_NAME = PKG_NAME;
    exports.PKG_VERSION = PKG_VERSION;
    exports.Popup = Popup;
    exports.Surface = Surface;
    exports.Tabbed = Tabbed;
    exports.Toolbar = Toolbar;
    exports.VerticalList = VerticalList;
    exports.WidgetDiv = WidgetDiv;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.js.map
