import { IObserverHandle } from "./dispatch";
export interface IEvent {
    id: string;
    oldValue: any;
    newValue: any;
}
export declare type StatePropCallback = (changes: IEvent) => void;
export declare type StateCallback = (changes: IEvent[]) => void;
export declare type StateEvents = "propChanged" | "changed";
export declare class StateObject<U, I> {
    private _espState;
    private _dispatch;
    private _monitorHandle;
    protected _monitorTickCount: number;
    protected clear(newVals?: Partial<I>): void;
    protected get(): U;
    protected get<K extends keyof U>(key: K, defValue?: U[K]): U[K];
    protected set(newVals: I): void;
    protected set<K extends keyof U>(key: K, newVal: U[K], batchMode?: boolean): void;
    private setSingle;
    private setAll;
    protected has<K extends keyof U>(key: K): boolean;
    addObserver(eventID: StateEvents, callback: StateCallback): IObserverHandle;
    addObserver(eventID: StateEvents, propID: keyof U, callback: StatePropCallback): IObserverHandle;
    on(eventID: StateEvents, callback: StateCallback): this;
    on(eventID: StateEvents, propID: keyof U, callback: StatePropCallback): this;
    protected isCallback(propIDOrCallback: StateCallback | keyof U): propIDOrCallback is StateCallback;
    protected hasEventListener(): boolean;
    protected refresh(full?: boolean): Promise<this>;
    protected _monitor(): void;
    protected _monitorTimeoutDuraction(): number;
    watch(callback: StateCallback, triggerChange?: boolean): IObserverHandle;
}
//# sourceMappingURL=stateful.d.ts.map