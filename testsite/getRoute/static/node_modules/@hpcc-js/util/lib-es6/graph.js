import * as tslib_1 from "tslib";
var GraphItem = /** @class */ (function () {
    function GraphItem(graph, parent) {
        this.props = {};
        this._graph = graph;
        this.parent = parent;
    }
    return GraphItem;
}());
export { GraphItem };
var Subgraph = /** @class */ (function (_super) {
    tslib_1.__extends(Subgraph, _super);
    function Subgraph(graph, parent, _) {
        var _this = _super.call(this, graph, parent) || this;
        _this.subgraphs = [];
        _this.vertices = [];
        _this.edges = [];
        if (parent) { //  Only needed for dummy root
            parent._addSubgraph(_this);
        }
        _this._ = _;
        return _this;
    }
    Subgraph.prototype.remove = function (full) {
        if (full === void 0) { full = true; }
        this._graph.removeSubgraph(this, full);
    };
    Subgraph.prototype.createSubgraph = function (_) {
        return this._graph.createSubgraph(this, _);
    };
    Subgraph.prototype._addSubgraph = function (subgraph) {
        if (this.subgraphs.indexOf(subgraph) >= 0) {
            throw new Error("Subgraph already exists");
        }
        this.subgraphs.push(subgraph);
    };
    Subgraph.prototype._removeSubgraph = function (subgraph) {
        var idx = this.subgraphs.indexOf(subgraph);
        if (idx < 0) {
            throw new Error("Subgraph does not exist");
        }
        this.subgraphs.splice(idx, 1);
    };
    Subgraph.prototype.removeAllSubgraphs = function () {
        for (var i = this.subgraphs.length - 1; i >= 0; --i) {
            this._graph.removeSubgraph(this.subgraphs[i], true);
        }
    };
    Subgraph.prototype.createVertex = function (_) {
        return this._graph.createVertex(this, _);
    };
    Subgraph.prototype._addVertex = function (vertex) {
        if (this.vertices.indexOf(vertex) >= 0) {
            throw new Error("Vertex already exists");
        }
        this.vertices.push(vertex);
    };
    Subgraph.prototype._removeVertex = function (vertex) {
        var idx = this.vertices.indexOf(vertex);
        if (idx < 0) {
            throw new Error("Vertex does not exist");
        }
        this.vertices.splice(idx, 1);
    };
    Subgraph.prototype.removeAllVertices = function () {
        for (var i = this.vertices.length - 1; i >= 0; --i) {
            this._graph.removeVertex(this.vertices[i], true);
        }
    };
    Subgraph.prototype.createEdge = function (source, target, _) {
        return this._graph.createEdge(this, source, target, _);
    };
    Subgraph.prototype._addEdge = function (edge) {
        if (this.edges.indexOf(edge) >= 0) {
            throw new Error("Edge already exists");
        }
        this.edges.push(edge);
    };
    Subgraph.prototype._removeEdge = function (edge) {
        var idx = this.edges.indexOf(edge);
        if (idx < 0) {
            throw new Error("Edge does not exist");
        }
        this.edges.splice(idx, 1);
    };
    Subgraph.prototype._add = function (item) {
        if (item instanceof Subgraph) {
            this._addSubgraph(item);
        }
        else if (item instanceof Vertex) {
            this._addVertex(item);
        }
        else {
            this._addEdge(item);
        }
    };
    return Subgraph;
}(GraphItem));
export { Subgraph };
var Vertex = /** @class */ (function (_super) {
    tslib_1.__extends(Vertex, _super);
    function Vertex(graph, parent, _) {
        var _this = _super.call(this, graph, parent) || this;
        _this.inEdges = [];
        _this.outEdges = [];
        parent._addVertex(_this);
        _this._ = _;
        return _this;
    }
    Object.defineProperty(Vertex.prototype, "edges", {
        get: function () {
            return this.inEdges.concat(this.outEdges);
        },
        enumerable: true,
        configurable: true
    });
    Vertex.prototype.remove = function (full, _) {
        if (full === void 0) { full = true; }
        return this._graph.removeVertex(this, full, _);
    };
    Vertex.prototype.addInEdge = function (edge) {
        this.inEdges.push(edge);
    };
    Vertex.prototype.removeInEdge = function (edge) {
        var idx = this.inEdges.indexOf(edge);
        if (idx < 0) {
            throw new Error("In edge does not exist");
        }
        this.inEdges.splice(idx, 1);
    };
    Vertex.prototype.addOutEdge = function (edge) {
        this.outEdges.push(edge);
    };
    Vertex.prototype.removeOutEdge = function (edge) {
        var idx = this.outEdges.indexOf(edge);
        if (idx < 0) {
            throw new Error("Out edge does not exist");
        }
        this.outEdges.splice(idx, 1);
    };
    return Vertex;
}(GraphItem));
export { Vertex };
var Edge = /** @class */ (function (_super) {
    tslib_1.__extends(Edge, _super);
    function Edge(graph, parent, source, target, _) {
        var _this = _super.call(this, graph, parent) || this;
        if (!source) {
            throw new Error("Missing source vertex");
        }
        if (!target) {
            throw new Error("Missing target vertex");
        }
        parent._addEdge(_this);
        _this.source = source;
        _this.source.addOutEdge(_this);
        _this.target = target;
        _this.target.addInEdge(_this);
        _this._ = _;
        return _this;
    }
    Edge.prototype.remove = function () {
        this._graph.removeEdge(this);
    };
    return Edge;
}(GraphItem));
export { Edge };
var Graph = /** @class */ (function () {
    function Graph(idOf, _) {
        if (idOf === void 0) { idOf = function (item) { return "" + item._; }; }
        this._allSubgraphs = [];
        this._allSubgraphsMap = {};
        this._allVertices = [];
        this._allVerticesMap = {};
        this._allEdges = [];
        this._allEdgesMap = {};
        this.root = new Subgraph(this, null, _);
        this.idOf = idOf;
    }
    Graph.prototype.createSubgraph = function (parent, _) {
        var retVal = new Subgraph(this, parent || this.root, _);
        this._allSubgraphs.push(retVal);
        this._allSubgraphsMap[this.idOf(retVal)] = retVal;
        return retVal;
    };
    Graph.prototype.removeSubgraph = function (subgraph, full) {
        var _this = this;
        if (full === void 0) { full = true; }
        var idx = this._allSubgraphs.indexOf(subgraph);
        if (idx < 0) {
            throw new Error("Subgraph does not exist");
        }
        this._allSubgraphs.splice(idx, 1);
        delete this._allSubgraphsMap[this.idOf(subgraph)];
        if (subgraph.parent) {
            subgraph.parent._removeSubgraph(subgraph);
        }
        subgraph.edges.forEach(function (edge) { return full ? _this.removeEdge(edge) : subgraph.parent._addEdge(edge); });
        subgraph.vertices.forEach(function (vertex) { return full ? _this.removeVertex(vertex, full) : subgraph.parent._addVertex(vertex); });
        subgraph.subgraphs.forEach(function (childSubgraph) { return full ? _this.removeSubgraph(childSubgraph, full) : subgraph.parent._addSubgraph(childSubgraph); });
    };
    Object.defineProperty(Graph.prototype, "subgraphs", {
        get: function () {
            return this._allSubgraphs;
        },
        enumerable: true,
        configurable: true
    });
    Graph.prototype.subgraph = function (id) {
        return this._allSubgraphsMap[id];
    };
    Graph.prototype.createVertex = function (parent, _) {
        var retVal = new Vertex(this, parent, _);
        this._allVertices.push(retVal);
        this._allVerticesMap[this.idOf(retVal)] = retVal;
        return retVal;
    };
    Graph.prototype.removeVertex = function (vertex, full, _) {
        var _this = this;
        if (full === void 0) { full = true; }
        var idx = this._allVertices.indexOf(vertex);
        if (idx < 0) {
            throw new Error("Vertex does not exist");
        }
        this._allVertices.splice(idx, 1);
        delete this._allVerticesMap[this.idOf(vertex)];
        if (vertex.parent) {
            vertex.parent._removeVertex(vertex);
        }
        if (!full) {
            vertex.inEdges.forEach(function (inEdge) {
                vertex.outEdges.forEach(function (outEdge) {
                    _this.createEdge(_this.root, inEdge.source, outEdge.target, _ ? _(inEdge.source._, outEdge.target._) : undefined);
                });
            });
        }
        vertex.inEdges.forEach(function (edge) { return _this.removeEdge(edge); });
        vertex.outEdges.forEach(function (edge) { return _this.removeEdge(edge); });
    };
    Object.defineProperty(Graph.prototype, "vertices", {
        get: function () {
            return this._allVertices;
        },
        enumerable: true,
        configurable: true
    });
    Graph.prototype.vertex = function (id) {
        return this._allVerticesMap[id];
    };
    Graph.prototype.createEdge = function (parent, source, target, _) {
        var retVal = new Edge(this, parent, source, target, _);
        this._allEdges.push(retVal);
        this._allEdgesMap[this.idOf(retVal)] = retVal;
        return retVal;
    };
    Graph.prototype.removeEdge = function (edge) {
        var idx = this._allEdges.indexOf(edge);
        if (idx < 0) {
            throw new Error("Edge does not exist");
        }
        this._allEdges.splice(idx, 1);
        delete this._allEdgesMap[this.idOf(edge)];
        if (edge.parent) {
            edge.parent._removeEdge(edge);
        }
        edge.source.removeOutEdge(edge);
        edge.target.removeInEdge(edge);
    };
    Object.defineProperty(Graph.prototype, "edges", {
        get: function () {
            return this._allEdges;
        },
        enumerable: true,
        configurable: true
    });
    Graph.prototype.edge = function (id) {
        return this._allEdgesMap[id];
    };
    Graph.prototype._walk = function (parent, visitor) {
        for (var _i = 0, _a = parent.subgraphs; _i < _a.length; _i++) {
            var subgraph = _a[_i];
            switch (visitor(subgraph)) {
                case "abort":
                    return true;
                case "stepover":
                    break;
                default:
                    if (this._walk(subgraph, visitor))
                        return true;
            }
        }
        for (var _b = 0, _c = parent.vertices; _b < _c.length; _b++) {
            var vertex = _c[_b];
            if (visitor(vertex) === "abort")
                return true;
        }
    };
    Graph.prototype.walk = function (visitor) {
        this._walk(this.root, visitor);
        for (var _i = 0, _a = this._allEdges; _i < _a.length; _i++) {
            var edge = _a[_i];
            if (visitor(edge) === "abort")
                return true;
        }
    };
    Graph.prototype.clone = function () {
        var ctor = this.constructor;
        var retVal = new ctor(this.idOf, this.root._);
        var map = ObjMap();
        map.put(this.root, retVal.root);
        this.walk(function (item) {
            var parent = map.get(item.parent);
            if (item instanceof Subgraph) {
                map.put(item, parent.createSubgraph(item._));
            }
            else if (item instanceof Vertex) {
                map.put(item, parent.createVertex(item._));
            }
            else if (item instanceof Edge) {
                var source = map.get(item.source);
                var target = map.get(item.target);
                parent.createEdge(source, target, item._);
            }
        });
        return retVal;
    };
    return Graph;
}());
export { Graph };
function ObjMap() {
    var keys = [];
    var values = [];
    return {
        put: function (key, value) {
            var index = keys.indexOf(key);
            if (index === -1) {
                keys.push(key);
                values.push(value);
            }
            else {
                values[index] = value;
            }
        },
        get: function (key) {
            return values[keys.indexOf(key)];
        }
    };
}
//# sourceMappingURL=graph.js.map