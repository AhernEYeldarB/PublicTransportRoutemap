/**
 * inner - return inner property of Object
 * Usage:  inner("some.prop.to.locate", obj);
 *
 * @param prop - property to locate
 * @param obj - object to locate property in
 */
export function inner(prop, obj) {
    if (prop === void 0 || obj === void 0)
        return void 0;
    for (var _i = 0, _a = prop.split("."); _i < _a.length; _i++) {
        var item = _a[_i];
        if (!obj.hasOwnProperty(item)) {
            return undefined;
        }
        obj = obj[item];
    }
    return obj;
}
/**
 * exists - return true if inner property of Object exists
 * Usage:  exists("some.prop.to.locate", obj);
 *
 * @param prop - property to locate
 * @param obj - object to locate property in
 */
export function exists(prop, obj) {
    return inner(prop, obj) !== undefined;
}
function _mixin(dest, source) {
    var empty = {};
    for (var key in source) {
        var s = source[key];
        if (s instanceof Array) {
            //  TODO:  Do we need to support arrays?
        }
        else if (typeof s === "object") {
            s = deepMixin(dest[key], s);
        }
        if (!(key in dest) || (dest[key] !== s && (!(key in empty) || empty[key] !== s))) {
            dest[key] = s;
        }
    }
    return dest;
}
/**
 * deepMixin - combine several objects from right to left
 * Usage:  deepMixin({a: "a"}, {b: "b"});
 *
 * @param dest - target object to mix into.
 * @param sources - objects to mix in
 */
export function deepMixin(dest) {
    if (dest === void 0) { dest = {}; }
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    if (typeof dest !== "object")
        throw new Error("Destination \"" + dest + "\" must be an object.");
    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
        var source = sources_1[_a];
        _mixin(dest, source);
    }
    return dest;
}
/**
 * deepMixinT - combine several objects of Partial<T> from right to left
 * Usage:  deepMixinT<MyInterface>({a: "a"}, {b: "b"});
 *
 * Note:  Only provided as a convenience, so user gets auto completion based on destination type.
 *
 * @param dest - target object to mix into.
 * @param sources - objects to mix in
 */
export function deepMixinT(dest) {
    if (dest === void 0) { dest = {}; }
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return deepMixin.apply(void 0, [dest].concat(sources));
}
/**
 * safeStingify - JSONsimilar to .stringify, except ignores circular references.
 * Usage:  safeStingify(object);
 *
 * @param obj - any object.
 */
export function safeStringify(obj) {
    var cache = [];
    return JSON.stringify(obj, function (key, value) {
        if (typeof value === "object" && value !== null) {
            if (cache.indexOf(value) !== -1) {
                return;
            }
            cache.push(value);
        }
        return value;
    });
}
export function isArray(arg) {
    if (Array.isArray !== undefined) {
        return Array.isArray(arg);
    }
    return Object.prototype.toString.call(arg) === "[object Array]";
}
export function classID2Meta(classID) {
    var info = classID.split("_");
    var classInfo = info[1].split(".");
    return {
        module: "@hpcc-js/" + info[0],
        file: classInfo[0],
        class: classInfo[1] || classInfo[0]
    };
}
//# sourceMappingURL=object.js.map