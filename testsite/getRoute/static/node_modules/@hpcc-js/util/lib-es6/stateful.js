import * as tslib_1 from "tslib";
import { Dispatch, Message } from "./dispatch";
var PropChangedMessage = /** @class */ (function (_super) {
    tslib_1.__extends(PropChangedMessage, _super);
    function PropChangedMessage(property, newValue, oldValue) {
        var _this = _super.call(this) || this;
        _this.property = property;
        _this.newValue = newValue;
        _this.oldValue = oldValue;
        return _this;
    }
    Object.defineProperty(PropChangedMessage.prototype, "canConflate", {
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    PropChangedMessage.prototype.conflate = function (other) {
        if (this.property === other.property) {
            this.newValue = other.newValue;
            return true;
        }
        return false;
    };
    PropChangedMessage.prototype.void = function () {
        return this.newValue === this.oldValue;
    };
    return PropChangedMessage;
}(Message));
var StateObject = /** @class */ (function () {
    function StateObject() {
        this._espState = {};
        this._dispatch = new Dispatch();
        this._monitorTickCount = 0;
    }
    StateObject.prototype.clear = function (newVals) {
        this._espState = {};
        if (newVals !== void 0) {
            this.set(newVals);
        }
        this._monitorTickCount = 0;
    };
    StateObject.prototype.get = function (key, defValue) {
        if (key === void 0) {
            return this._espState;
        }
        return this.has(key) ? this._espState[key] : defValue;
    };
    StateObject.prototype.set = function (keyOrNewVals, newVal) {
        if (typeof keyOrNewVals === "string") {
            return this.setSingle(keyOrNewVals, newVal); //  TODO:  "as any" should not be needed (TS >= 3.1.x)
        }
        this.setAll(keyOrNewVals);
    };
    StateObject.prototype.setSingle = function (key, newVal) {
        var oldVal = this._espState[key];
        this._espState[key] = newVal;
        this._dispatch.post(new PropChangedMessage(key, newVal, oldVal));
    };
    StateObject.prototype.setAll = function (_) {
        for (var key in _) {
            if (_.hasOwnProperty(key)) {
                this.setSingle(key, _[key]);
            }
        }
    };
    StateObject.prototype.has = function (key) {
        return this._espState[key] !== void 0;
    };
    StateObject.prototype.addObserver = function (eventID, propIDOrCallback, callback) {
        if (this.isCallback(propIDOrCallback)) {
            if (eventID !== "changed")
                throw new Error("Invalid eventID:  " + eventID);
            return this._dispatch.attach(function (messages) {
                propIDOrCallback(messages.map(function (m) { return ({
                    id: m.property,
                    oldValue: m.oldValue,
                    newValue: m.newValue
                }); }));
            });
        }
        else {
            if (eventID !== "propChanged")
                throw new Error("Invalid eventID:  " + eventID);
            return this._dispatch.attach(function (messages) {
                var filteredMessages = messages.filter(function (m) { return m.property === propIDOrCallback; });
                if (filteredMessages.length) {
                    if (filteredMessages.length > 1) {
                        console.warn("Should only be 1 message?");
                    }
                    var event_1 = filteredMessages[filteredMessages.length - 1];
                    callback({
                        id: event_1.property,
                        oldValue: event_1.oldValue,
                        newValue: event_1.newValue
                    });
                }
            });
        }
    };
    StateObject.prototype.on = function (eventID, propIDOrCallback, callback) {
        this.addObserver(eventID, propIDOrCallback, callback);
        return this;
    };
    StateObject.prototype.isCallback = function (propIDOrCallback) {
        return (typeof propIDOrCallback === "function");
    };
    StateObject.prototype.hasEventListener = function () {
        return this._dispatch.hasObserver();
    };
    //  Monitoring  ---
    StateObject.prototype.refresh = function (full) {
        if (full === void 0) { full = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.resolve()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this];
                }
            });
        });
    };
    StateObject.prototype._monitor = function () {
        var _this = this;
        if (this._monitorHandle) {
            this._monitorTickCount = 0;
            return;
        }
        this._monitorHandle = setTimeout(function () {
            var refreshPromise = _this.hasEventListener() ? _this.refresh() : Promise.resolve();
            refreshPromise.then(function () {
                _this._monitor();
            });
            delete _this._monitorHandle;
        }, this._monitorTimeoutDuraction());
    };
    StateObject.prototype._monitorTimeoutDuraction = function () {
        ++this._monitorTickCount;
        if (this._monitorTickCount <= 1) { //  Once
            return 0;
        }
        return 30000;
    };
    StateObject.prototype.watch = function (callback, triggerChange) {
        var _this = this;
        if (triggerChange === void 0) { triggerChange = true; }
        if (typeof callback !== "function") {
            throw new Error("Invalid Callback");
        }
        if (triggerChange) {
            setTimeout(function () {
                var props = _this.get();
                var changes = [];
                for (var key in props) {
                    if (props.hasOwnProperty(props)) {
                        changes.push({ id: key, newValue: props[key], oldValue: undefined });
                    }
                }
                callback(changes);
            }, 0);
        }
        var retVal = this.addObserver("changed", callback);
        this._monitor();
        return retVal;
    };
    return StateObject;
}());
export { StateObject };
//# sourceMappingURL=stateful.js.map