var PKG_NAME = "@hpcc-js/util";
var PKG_VERSION = "2.8.2";
var BUILD_VERSION = "2.10.1";

// Based on:  https://tc39.github.io/ecma262/#sec-array.prototype.find
function find(o, predicate) {
    // 1. Let O be ? ToObject(this value).
    if (o == null) {
        throw new TypeError('"o" is null or not defined');
    }
    // 2. Let len be ? ToLength(? Get(O, "length")).
    // tslint:disable-next-line:no-bitwise
    var len = o.length >>> 0;
    // 3. If IsCallable(predicate) is false, throw a TypeError exception.
    if (typeof predicate !== "function") {
        throw new TypeError("predicate must be a function");
    }
    // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
    var thisArg = arguments[1];
    // 5. Let k be 0.
    var k = 0;
    // 6. Repeat, while k < len
    while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
            return kValue;
        }
        // e. Increase k by 1.
        k++;
    }
    // 7. Return undefined.
    return undefined;
}
function compare(before, after) {
    var retVal = {
        unchanged: [],
        removed: [],
        added: after.slice(0)
    };
    for (var _i = 0, before_1 = before; _i < before_1.length; _i++) {
        var row = before_1[_i];
        var otherIdx = retVal.added.indexOf(row);
        if (otherIdx >= 0) {
            retVal.unchanged.push(row);
            retVal.added.splice(otherIdx, 1);
        }
        else {
            retVal.removed.push(row);
        }
    }
    return retVal;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

//  Ported to TypeScript from:  https://github.com/bevacqua/hash-sum
function pad(hash, len) {
    while (hash.length < len) {
        hash = "0" + hash;
    }
    return hash;
}
function fold(hash, text) {
    if (text.length === 0) {
        return hash;
    }
    for (var i = 0; i < text.length; ++i) {
        var chr = text.charCodeAt(i);
        // tslint:disable:no-bitwise
        hash = ((hash << 5) - hash) + chr;
        hash |= 0;
        // tslint:enable:no-bitwise
    }
    return hash < 0 ? hash * -2 : hash;
}
function foldObject(hash, o, seen) {
    if (typeof o.hashSum === "function") {
        return o.hashSum();
    }
    return Object.keys(o).sort().reduce(function (input, key) {
        return foldValue(input, o[key], key, seen);
    }, hash);
}
function foldValue(input, value, key, seen) {
    var hash = fold(fold(fold(input, key), toString(value)), typeof value);
    if (value === null) {
        return fold(hash, "null");
    }
    if (value === undefined) {
        return fold(hash, "undefined");
    }
    if (typeof value === "object") {
        if (seen.indexOf(value) !== -1) {
            return fold(hash, "[Circular]" + key);
        }
        seen.push(value);
        return foldObject(hash, value, seen);
    }
    return fold(hash, value.toString());
}
function toString(o) {
    return Object.prototype.toString.call(o);
}
function hashSum(o) {
    return pad(foldValue(0, o, "", []).toString(16), 8);
}

var Cache = /** @class */ (function () {
    function Cache(calcID) {
        this._cache = {};
        this._calcID = calcID;
    }
    Cache.hash = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return hashSum(__assign({}, args));
    };
    Cache.prototype.has = function (espObj) {
        return this._calcID(espObj) in this._cache;
    };
    Cache.prototype.set = function (obj) {
        this._cache[this._calcID(obj)] = obj;
        return obj;
    };
    Cache.prototype.get = function (espObj, factory) {
        var retVal = this._cache[this._calcID(espObj)];
        if (!retVal) {
            return factory ? this.set(factory()) : null;
        }
        return retVal;
    };
    return Cache;
}());
var AsyncCache = /** @class */ (function () {
    function AsyncCache(calcID) {
        this._cache = {};
        this._calcID = calcID;
    }
    AsyncCache.hash = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return hashSum(__assign({}, args));
    };
    AsyncCache.prototype.has = function (espObj) {
        return this._calcID(espObj) in this._cache;
    };
    AsyncCache.prototype.set = function (espObj, obj) {
        this._cache[this._calcID(espObj)] = obj;
        return obj;
    };
    AsyncCache.prototype.get = function (espObj, factory) {
        var retVal = this._cache[this._calcID(espObj)];
        if (!retVal) {
            return factory ? this.set(espObj, factory()) : Promise.resolve(null);
        }
        return retVal;
    };
    return AsyncCache;
}());

function debounce(fn, timeout) {
    var promises = {};
    return function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var hash = hashSum(params);
        if (!promises[hash]) {
            promises[hash] = {
                clockStart: Date.now(),
                promise: fn.apply(void 0, params).then(function (response) {
                    if (timeout === undefined) {
                        promises[hash] = null;
                    }
                    else {
                        setTimeout(function () {
                            promises[hash] = null;
                        }, Math.max(timeout - (Date.now() - promises[hash].clockStart), 0));
                    }
                    return response;
                }).catch(function (e) {
                    promises[hash] = null;
                    throw e;
                })
            };
        }
        return promises[hash].promise;
    };
}
function promiseTimeout(ms, promise) {
    var id;
    var timeout = new Promise(function (resolve, reject) {
        id = setTimeout(function () {
            clearTimeout(id);
            reject("Timed out in " + ms + "ms.");
        }, ms);
    });
    return Promise.race([
        promise,
        timeout
    ]).then(function (response) {
        clearTimeout(id);
        return response;
    }).catch(function (e) {
        clearTimeout(id);
        throw e;
    });
}
var AsyncOrderedQueue = /** @class */ (function () {
    function AsyncOrderedQueue() {
        this._q = [];
    }
    AsyncOrderedQueue.prototype.isTop = function (p) {
        return this._q[0] === p;
    };
    AsyncOrderedQueue.prototype.push = function (p) {
        var _this = this;
        var retVal = p.then(function (response) {
            if (_this.isTop(retVal)) {
                _this._q.shift();
                return response;
            }
            return new Promise(function (resolve, reject) {
                var intervalHandler = setInterval(function () {
                    if (_this.isTop(retVal)) {
                        clearInterval(intervalHandler);
                        _this._q.shift();
                        resolve(response);
                    }
                }, 20);
            });
        });
        this._q.push(retVal);
        return retVal;
    };
    return AsyncOrderedQueue;
}());

var Dictionary = /** @class */ (function () {
    function Dictionary(attrs) {
        this.store = {};
        if (attrs) {
            for (var key in attrs) {
                this.set(key, attrs[key]);
            }
        }
    }
    Dictionary.prototype.set = function (key, value) {
        var retVal = this.store[key];
        this.store[key] = value;
        return retVal;
    };
    Dictionary.prototype.get = function (key) {
        return this.store[key];
    };
    Dictionary.prototype.has = function (key) {
        return this.store[key] !== undefined;
    };
    Dictionary.prototype.remove = function (key) {
        delete this.store[key];
    };
    Dictionary.prototype.keys = function () {
        var retVal = [];
        for (var key in this.store) {
            retVal.push(key);
        }
        return retVal;
    };
    Dictionary.prototype.values = function () {
        var retVal = [];
        for (var key in this.store) {
            retVal.push(this.store[key]);
        }
        return retVal;
    };
    return Dictionary;
}());
var DictionaryNoCase = /** @class */ (function (_super) {
    __extends(DictionaryNoCase, _super);
    function DictionaryNoCase(attrs) {
        return _super.call(this, attrs) || this;
    }
    DictionaryNoCase.prototype.set = function (key, value) {
        return _super.prototype.set.call(this, key.toLowerCase(), value);
    };
    DictionaryNoCase.prototype.get = function (key) {
        return _super.prototype.get.call(this, key.toLowerCase());
    };
    DictionaryNoCase.prototype.has = function (key) {
        return _super.prototype.has.call(this, key.toLowerCase());
    };
    DictionaryNoCase.prototype.remove = function (key) {
        return _super.prototype.remove.call(this, key.toLowerCase());
    };
    return DictionaryNoCase;
}(Dictionary));

function espTime2Seconds(duration) {
    if (!duration) {
        return 0;
    }
    else {
        if (!isNaN(Number(duration))) {
            return Number(duration);
        }
    }
    //  GH:  <n>ns or <m>ms or <s>s or [<d> days ][<h>:][<m>:]<s>[.<ms>]
    var nsIndex = duration.indexOf("ns");
    if (nsIndex !== -1) {
        return parseFloat(duration.substr(0, nsIndex)) / 1000000000;
    }
    var msIndex = duration.indexOf("ms");
    if (msIndex !== -1) {
        return parseFloat(duration.substr(0, msIndex)) / 1000;
    }
    var sIndex = duration.indexOf("s");
    if (sIndex !== -1 && duration.indexOf("days") === -1) {
        return parseFloat(duration.substr(0, sIndex));
    }
    var dayTimeParts = duration.split(" days ");
    var days = dayTimeParts.length > 1 ? parseFloat(dayTimeParts[0]) : 0.0;
    var time = dayTimeParts.length > 1 ? dayTimeParts[1] : dayTimeParts[0];
    var secs = 0.0;
    var timeParts = time.split(":").reverse();
    for (var j = 0; j < timeParts.length; ++j) {
        secs += parseFloat(timeParts[j]) * Math.pow(60, j);
    }
    return (days * 24 * 60 * 60) + secs;
}

var GraphItem = /** @class */ (function () {
    function GraphItem(graph, parent) {
        this.props = {};
        this._graph = graph;
        this.parent = parent;
    }
    return GraphItem;
}());
var Subgraph = /** @class */ (function (_super) {
    __extends(Subgraph, _super);
    function Subgraph(graph, parent, _) {
        var _this = _super.call(this, graph, parent) || this;
        _this.subgraphs = [];
        _this.vertices = [];
        _this.edges = [];
        if (parent) { //  Only needed for dummy root
            parent._addSubgraph(_this);
        }
        _this._ = _;
        return _this;
    }
    Subgraph.prototype.remove = function (full) {
        if (full === void 0) { full = true; }
        this._graph.removeSubgraph(this, full);
    };
    Subgraph.prototype.createSubgraph = function (_) {
        return this._graph.createSubgraph(this, _);
    };
    Subgraph.prototype._addSubgraph = function (subgraph) {
        if (this.subgraphs.indexOf(subgraph) >= 0) {
            throw new Error("Subgraph already exists");
        }
        this.subgraphs.push(subgraph);
    };
    Subgraph.prototype._removeSubgraph = function (subgraph) {
        var idx = this.subgraphs.indexOf(subgraph);
        if (idx < 0) {
            throw new Error("Subgraph does not exist");
        }
        this.subgraphs.splice(idx, 1);
    };
    Subgraph.prototype.removeAllSubgraphs = function () {
        for (var i = this.subgraphs.length - 1; i >= 0; --i) {
            this._graph.removeSubgraph(this.subgraphs[i], true);
        }
    };
    Subgraph.prototype.createVertex = function (_) {
        return this._graph.createVertex(this, _);
    };
    Subgraph.prototype._addVertex = function (vertex) {
        if (this.vertices.indexOf(vertex) >= 0) {
            throw new Error("Vertex already exists");
        }
        this.vertices.push(vertex);
    };
    Subgraph.prototype._removeVertex = function (vertex) {
        var idx = this.vertices.indexOf(vertex);
        if (idx < 0) {
            throw new Error("Vertex does not exist");
        }
        this.vertices.splice(idx, 1);
    };
    Subgraph.prototype.removeAllVertices = function () {
        for (var i = this.vertices.length - 1; i >= 0; --i) {
            this._graph.removeVertex(this.vertices[i], true);
        }
    };
    Subgraph.prototype.createEdge = function (source, target, _) {
        return this._graph.createEdge(this, source, target, _);
    };
    Subgraph.prototype._addEdge = function (edge) {
        if (this.edges.indexOf(edge) >= 0) {
            throw new Error("Edge already exists");
        }
        this.edges.push(edge);
    };
    Subgraph.prototype._removeEdge = function (edge) {
        var idx = this.edges.indexOf(edge);
        if (idx < 0) {
            throw new Error("Edge does not exist");
        }
        this.edges.splice(idx, 1);
    };
    Subgraph.prototype._add = function (item) {
        if (item instanceof Subgraph) {
            this._addSubgraph(item);
        }
        else if (item instanceof Vertex) {
            this._addVertex(item);
        }
        else {
            this._addEdge(item);
        }
    };
    return Subgraph;
}(GraphItem));
var Vertex = /** @class */ (function (_super) {
    __extends(Vertex, _super);
    function Vertex(graph, parent, _) {
        var _this = _super.call(this, graph, parent) || this;
        _this.inEdges = [];
        _this.outEdges = [];
        parent._addVertex(_this);
        _this._ = _;
        return _this;
    }
    Object.defineProperty(Vertex.prototype, "edges", {
        get: function () {
            return this.inEdges.concat(this.outEdges);
        },
        enumerable: true,
        configurable: true
    });
    Vertex.prototype.remove = function (full, _) {
        if (full === void 0) { full = true; }
        return this._graph.removeVertex(this, full, _);
    };
    Vertex.prototype.addInEdge = function (edge) {
        this.inEdges.push(edge);
    };
    Vertex.prototype.removeInEdge = function (edge) {
        var idx = this.inEdges.indexOf(edge);
        if (idx < 0) {
            throw new Error("In edge does not exist");
        }
        this.inEdges.splice(idx, 1);
    };
    Vertex.prototype.addOutEdge = function (edge) {
        this.outEdges.push(edge);
    };
    Vertex.prototype.removeOutEdge = function (edge) {
        var idx = this.outEdges.indexOf(edge);
        if (idx < 0) {
            throw new Error("Out edge does not exist");
        }
        this.outEdges.splice(idx, 1);
    };
    return Vertex;
}(GraphItem));
var Edge = /** @class */ (function (_super) {
    __extends(Edge, _super);
    function Edge(graph, parent, source, target, _) {
        var _this = _super.call(this, graph, parent) || this;
        if (!source) {
            throw new Error("Missing source vertex");
        }
        if (!target) {
            throw new Error("Missing target vertex");
        }
        parent._addEdge(_this);
        _this.source = source;
        _this.source.addOutEdge(_this);
        _this.target = target;
        _this.target.addInEdge(_this);
        _this._ = _;
        return _this;
    }
    Edge.prototype.remove = function () {
        this._graph.removeEdge(this);
    };
    return Edge;
}(GraphItem));
var Graph = /** @class */ (function () {
    function Graph(idOf, _) {
        if (idOf === void 0) { idOf = function (item) { return "" + item._; }; }
        this._allSubgraphs = [];
        this._allSubgraphsMap = {};
        this._allVertices = [];
        this._allVerticesMap = {};
        this._allEdges = [];
        this._allEdgesMap = {};
        this.root = new Subgraph(this, null, _);
        this.idOf = idOf;
    }
    Graph.prototype.createSubgraph = function (parent, _) {
        var retVal = new Subgraph(this, parent || this.root, _);
        this._allSubgraphs.push(retVal);
        this._allSubgraphsMap[this.idOf(retVal)] = retVal;
        return retVal;
    };
    Graph.prototype.removeSubgraph = function (subgraph, full) {
        var _this = this;
        if (full === void 0) { full = true; }
        var idx = this._allSubgraphs.indexOf(subgraph);
        if (idx < 0) {
            throw new Error("Subgraph does not exist");
        }
        this._allSubgraphs.splice(idx, 1);
        delete this._allSubgraphsMap[this.idOf(subgraph)];
        if (subgraph.parent) {
            subgraph.parent._removeSubgraph(subgraph);
        }
        subgraph.edges.forEach(function (edge) { return full ? _this.removeEdge(edge) : subgraph.parent._addEdge(edge); });
        subgraph.vertices.forEach(function (vertex) { return full ? _this.removeVertex(vertex, full) : subgraph.parent._addVertex(vertex); });
        subgraph.subgraphs.forEach(function (childSubgraph) { return full ? _this.removeSubgraph(childSubgraph, full) : subgraph.parent._addSubgraph(childSubgraph); });
    };
    Object.defineProperty(Graph.prototype, "subgraphs", {
        get: function () {
            return this._allSubgraphs;
        },
        enumerable: true,
        configurable: true
    });
    Graph.prototype.subgraph = function (id) {
        return this._allSubgraphsMap[id];
    };
    Graph.prototype.createVertex = function (parent, _) {
        var retVal = new Vertex(this, parent, _);
        this._allVertices.push(retVal);
        this._allVerticesMap[this.idOf(retVal)] = retVal;
        return retVal;
    };
    Graph.prototype.removeVertex = function (vertex, full, _) {
        var _this = this;
        if (full === void 0) { full = true; }
        var idx = this._allVertices.indexOf(vertex);
        if (idx < 0) {
            throw new Error("Vertex does not exist");
        }
        this._allVertices.splice(idx, 1);
        delete this._allVerticesMap[this.idOf(vertex)];
        if (vertex.parent) {
            vertex.parent._removeVertex(vertex);
        }
        if (!full) {
            vertex.inEdges.forEach(function (inEdge) {
                vertex.outEdges.forEach(function (outEdge) {
                    _this.createEdge(_this.root, inEdge.source, outEdge.target, _ ? _(inEdge.source._, outEdge.target._) : undefined);
                });
            });
        }
        vertex.inEdges.forEach(function (edge) { return _this.removeEdge(edge); });
        vertex.outEdges.forEach(function (edge) { return _this.removeEdge(edge); });
    };
    Object.defineProperty(Graph.prototype, "vertices", {
        get: function () {
            return this._allVertices;
        },
        enumerable: true,
        configurable: true
    });
    Graph.prototype.vertex = function (id) {
        return this._allVerticesMap[id];
    };
    Graph.prototype.createEdge = function (parent, source, target, _) {
        var retVal = new Edge(this, parent, source, target, _);
        this._allEdges.push(retVal);
        this._allEdgesMap[this.idOf(retVal)] = retVal;
        return retVal;
    };
    Graph.prototype.removeEdge = function (edge) {
        var idx = this._allEdges.indexOf(edge);
        if (idx < 0) {
            throw new Error("Edge does not exist");
        }
        this._allEdges.splice(idx, 1);
        delete this._allEdgesMap[this.idOf(edge)];
        if (edge.parent) {
            edge.parent._removeEdge(edge);
        }
        edge.source.removeOutEdge(edge);
        edge.target.removeInEdge(edge);
    };
    Object.defineProperty(Graph.prototype, "edges", {
        get: function () {
            return this._allEdges;
        },
        enumerable: true,
        configurable: true
    });
    Graph.prototype.edge = function (id) {
        return this._allEdgesMap[id];
    };
    Graph.prototype._walk = function (parent, visitor) {
        for (var _i = 0, _a = parent.subgraphs; _i < _a.length; _i++) {
            var subgraph = _a[_i];
            switch (visitor(subgraph)) {
                case "abort":
                    return true;
                case "stepover":
                    break;
                default:
                    if (this._walk(subgraph, visitor))
                        return true;
            }
        }
        for (var _b = 0, _c = parent.vertices; _b < _c.length; _b++) {
            var vertex = _c[_b];
            if (visitor(vertex) === "abort")
                return true;
        }
    };
    Graph.prototype.walk = function (visitor) {
        this._walk(this.root, visitor);
        for (var _i = 0, _a = this._allEdges; _i < _a.length; _i++) {
            var edge = _a[_i];
            if (visitor(edge) === "abort")
                return true;
        }
    };
    Graph.prototype.clone = function () {
        var ctor = this.constructor;
        var retVal = new ctor(this.idOf, this.root._);
        var map = ObjMap();
        map.put(this.root, retVal.root);
        this.walk(function (item) {
            var parent = map.get(item.parent);
            if (item instanceof Subgraph) {
                map.put(item, parent.createSubgraph(item._));
            }
            else if (item instanceof Vertex) {
                map.put(item, parent.createVertex(item._));
            }
            else if (item instanceof Edge) {
                var source = map.get(item.source);
                var target = map.get(item.target);
                parent.createEdge(source, target, item._);
            }
        });
        return retVal;
    };
    return Graph;
}());
function ObjMap() {
    var keys = [];
    var values = [];
    return {
        put: function (key, value) {
            var index = keys.indexOf(key);
            if (index === -1) {
                keys.push(key);
                values.push(value);
            }
            else {
                values[index] = value;
            }
        },
        get: function (key) {
            return values[keys.indexOf(key)];
        }
    };
}

var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;
function deepEquals(a, b) {
    if (a === b)
        return true;
    if (a && b && typeof a === "object" && typeof b === "object") {
        var arrA = isArray(a);
        var arrB = isArray(b);
        var i = void 0;
        var length_1;
        var key = void 0;
        if (arrA && arrB) {
            length_1 = a.length;
            if (length_1 !== b.length)
                return false;
            for (i = length_1; i-- !== 0;)
                if (!deepEquals(a[i], b[i]))
                    return false;
            return true;
        }
        if (arrA !== arrB)
            return false;
        var dateA = a instanceof Date;
        var dateB = b instanceof Date;
        if (dateA !== dateB)
            return false;
        if (dateA && dateB)
            return a.getTime() === b.getTime();
        var regexpA = a instanceof RegExp;
        var regexpB = b instanceof RegExp;
        if (regexpA !== regexpB)
            return false;
        if (regexpA && regexpB)
            return a.toString() === b.toString();
        var keys = keyList(a);
        length_1 = keys.length;
        if (length_1 !== keyList(b).length)
            return false;
        for (i = length_1; i-- !== 0;)
            if (!hasProp.call(b, keys[i]))
                return false;
        for (i = length_1; i-- !== 0;) {
            key = keys[i];
            if (!deepEquals(a[key], b[key]))
                return false;
        }
        return true;
    }
    return a !== a && b !== b;
}
function update(origItem, newItem) {
    return deepEquals(origItem, newItem) ? origItem : newItem;
}

//  @ts-ignore
var root = new Function("return this;")(); //  Prevent bundlers from messing with "this"
var isBrowser = typeof window !== "undefined" && root === window;
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var isTravis = isNode && process.env != null && process.env.TRAVIS != null;

/**
 * A generic Stack
 */
var Stack = /** @class */ (function () {
    function Stack() {
        this.stack = [];
    }
    /**
     * Push element onto the stack
     *
     * @param e - element to push
     */
    Stack.prototype.push = function (e) {
        this.stack.push(e);
        return e;
    };
    /**
     * Pop element off the stack
     */
    Stack.prototype.pop = function () {
        return this.stack.pop();
    };
    /**
     * Top item on the stack
     *
     * @returns Top element on the stack
     */
    Stack.prototype.top = function () {
        return this.stack.length ? this.stack[this.stack.length - 1] : undefined;
    };
    /**
     * Depth of stack
     *
     * @returns Depth
     */
    Stack.prototype.depth = function () {
        return this.stack.length;
    };
    return Stack;
}());

var Level;
(function (Level) {
    Level[Level["debug"] = 0] = "debug";
    Level[Level["info"] = 1] = "info";
    Level[Level["notice"] = 2] = "notice";
    Level[Level["warning"] = 3] = "warning";
    Level[Level["error"] = 4] = "error";
    Level[Level["critical"] = 5] = "critical";
    Level[Level["alert"] = 6] = "alert";
    Level[Level["emergency"] = 7] = "emergency";
})(Level || (Level = {}));
var colours = {
    debug: "cyan",
    info: "green",
    notice: "grey",
    warning: "blue",
    error: "red",
    critical: "magenta",
    alert: "magenta",
    emergency: "magenta"
};
var ConsoleWriter = /** @class */ (function () {
    function ConsoleWriter() {
    }
    ConsoleWriter.prototype.write = function (dateTime, level, id, msg) {
        if (isNode) {
            // tslint:disable-next-line:no-console
            console.log("[" + dateTime + "] " + Level[level].toUpperCase() + " " + id + ":  " + msg);
        }
        else {
            // tslint:disable-next-line:no-console
            console.log("[" + dateTime + "] %c" + Level[level].toUpperCase() + "%c " + id + ":  " + msg, "color:" + colours[Level[level]], "");
        }
    };
    return ConsoleWriter;
}());
var Logging = /** @class */ (function () {
    function Logging() {
        this._levelStack = new Stack();
        this._level = Level.info;
        this._filter = "";
        this._writer = new ConsoleWriter();
    }
    Logging.Instance = function () {
        return this._instance || (this._instance = new this());
    };
    Logging.prototype.stringify = function (obj) {
        var cache = [];
        return JSON.stringify(obj, function (_key, value) {
            if (typeof value === "object" && value !== null) {
                if (cache.indexOf(value) !== -1) {
                    return;
                }
                cache.push(value);
            }
            return value;
        }, 2);
    };
    Logging.prototype.writer = function (_) {
        if (_ === void 0)
            return this._writer;
        this._writer = _;
        return this;
    };
    Logging.prototype.log = function (level, id, msg) {
        if (level < this._level)
            return;
        if (this._filter && this._filter !== id)
            return;
        if (typeof msg !== "string") {
            msg = this.stringify(msg);
        }
        this._writer.write(new Date().toISOString(), level, id, msg);
    };
    Logging.prototype.debug = function (id, msg) {
        this.log(Level.debug, id, msg);
    };
    Logging.prototype.info = function (id, msg) {
        this.log(Level.info, id, msg);
    };
    Logging.prototype.notice = function (id, msg) {
        this.log(Level.notice, id, msg);
    };
    Logging.prototype.warning = function (id, msg) {
        this.log(Level.warning, id, msg);
    };
    Logging.prototype.error = function (id, msg) {
        this.log(Level.error, id, msg);
    };
    Logging.prototype.critical = function (id, msg) {
        this.log(Level.critical, id, msg);
    };
    Logging.prototype.alert = function (id, msg) {
        this.log(Level.alert, id, msg);
    };
    Logging.prototype.emergency = function (id, msg) {
        this.log(Level.emergency, id, msg);
    };
    Logging.prototype.level = function (_) {
        if (_ === void 0)
            return this._level;
        this._level = _;
        return this;
    };
    Logging.prototype.pushLevel = function (_) {
        this._levelStack.push(this._level);
        this._level = _;
        return this;
    };
    Logging.prototype.popLevel = function () {
        this._level = this._levelStack.pop();
        return this;
    };
    Logging.prototype.filter = function (_) {
        if (_ === void 0)
            return this._filter;
        this._filter = _;
        return this;
    };
    return Logging;
}());
var logger = Logging.Instance();
var ScopedLogging = /** @class */ (function () {
    function ScopedLogging(scopeID) {
        this._scopeID = scopeID;
    }
    ScopedLogging.prototype.debug = function (msg) {
        logger.debug(this._scopeID, msg);
    };
    ScopedLogging.prototype.info = function (msg) {
        logger.info(this._scopeID, msg);
    };
    ScopedLogging.prototype.notice = function (msg) {
        logger.notice(this._scopeID, msg);
    };
    ScopedLogging.prototype.warning = function (msg) {
        logger.warning(this._scopeID, msg);
    };
    ScopedLogging.prototype.error = function (msg) {
        logger.error(this._scopeID, msg);
    };
    ScopedLogging.prototype.critical = function (msg) {
        logger.critical(this._scopeID, msg);
    };
    ScopedLogging.prototype.alert = function (msg) {
        logger.alert(this._scopeID, msg);
    };
    ScopedLogging.prototype.emergency = function (msg) {
        logger.emergency(this._scopeID, msg);
    };
    ScopedLogging.prototype.pushLevel = function (_) {
        logger.pushLevel(_);
        return this;
    };
    ScopedLogging.prototype.popLevel = function () {
        logger.popLevel();
        return this;
    };
    return ScopedLogging;
}());
function scopedLogger(scopeID, filter) {
    if (filter === void 0) { filter = false; }
    if (filter) {
        logger.filter(scopeID);
    }
    return new ScopedLogging(scopeID);
}

/**
 * degreesToRadians - converts degrees to radians
 * Usage: degreesToRadians(1080);
 *
 * @param degrees
 * @returns Number radians
 */
function degreesToRadians(degrees) {
    return degrees * (Math.PI / 180);
}
/**
 * radiansToDegrees - converts radians to degrees
 * Usage: radiansToDegrees(7);
 *
 * @param radians
 * @returns Number degreees
 */
function radiansToDegrees(radians) {
    return radians * (180 / Math.PI);
}
/**
 * normalizeRadians - normalizes a radian value to within the provided range
 * Usage: normalizeRadians(7);
 *
 * @param radians value to be normalized
 * @param min lower limit
 * @param max upper limit
 * @returns Number normalized to within the provided range
 */
function normalizeRadians(radians, min, max) {
    if (min === void 0) { min = -Math.PI; }
    if (max === void 0) { max = Math.PI; }
    return normalize(radians, min, max);
}
/**
 * normalizeDegrees - normalizes a degree value to within the provided range
 * Usage: normalizeDegrees(1080);
 *
 * @param degrees value to be normalized
 * @param min lower limit
 * @param max upper limit
 * @returns Number normalized to within the provided range
 */
function normalizeDegrees(degrees, min, max) {
    if (min === void 0) { min = -180; }
    if (max === void 0) { max = 180; }
    return normalize(degrees, min, max);
}
/**
 * normalize - normalizes a value to within the provided range
 * Usage: normalize(1000, 0, 365);
 *
 * @param value value to be normalized
 * @param min lower limit
 * @param max upper limit
 * @returns Number normalized to within the provided range
 */
function normalize(value, min, max) {
    var spread = max - min;
    var offsetValue = value - min;
    return (offsetValue - (Math.floor(offsetValue / spread) * spread)) + min;
}

/**
 * inner - return inner property of Object
 * Usage:  inner("some.prop.to.locate", obj);
 *
 * @param prop - property to locate
 * @param obj - object to locate property in
 */
function inner(prop, obj) {
    if (prop === void 0 || obj === void 0)
        return void 0;
    for (var _i = 0, _a = prop.split("."); _i < _a.length; _i++) {
        var item = _a[_i];
        if (!obj.hasOwnProperty(item)) {
            return undefined;
        }
        obj = obj[item];
    }
    return obj;
}
/**
 * exists - return true if inner property of Object exists
 * Usage:  exists("some.prop.to.locate", obj);
 *
 * @param prop - property to locate
 * @param obj - object to locate property in
 */
function exists(prop, obj) {
    return inner(prop, obj) !== undefined;
}
function _mixin(dest, source) {
    var empty = {};
    for (var key in source) {
        var s = source[key];
        if (s instanceof Array) ;
        else if (typeof s === "object") {
            s = deepMixin(dest[key], s);
        }
        if (!(key in dest) || (dest[key] !== s && (!(key in empty) || empty[key] !== s))) {
            dest[key] = s;
        }
    }
    return dest;
}
/**
 * deepMixin - combine several objects from right to left
 * Usage:  deepMixin({a: "a"}, {b: "b"});
 *
 * @param dest - target object to mix into.
 * @param sources - objects to mix in
 */
function deepMixin(dest) {
    if (dest === void 0) { dest = {}; }
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    if (typeof dest !== "object")
        throw new Error("Destination \"" + dest + "\" must be an object.");
    for (var _a = 0, sources_1 = sources; _a < sources_1.length; _a++) {
        var source = sources_1[_a];
        _mixin(dest, source);
    }
    return dest;
}
/**
 * deepMixinT - combine several objects of Partial<T> from right to left
 * Usage:  deepMixinT<MyInterface>({a: "a"}, {b: "b"});
 *
 * Note:  Only provided as a convenience, so user gets auto completion based on destination type.
 *
 * @param dest - target object to mix into.
 * @param sources - objects to mix in
 */
function deepMixinT(dest) {
    if (dest === void 0) { dest = {}; }
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return deepMixin.apply(void 0, [dest].concat(sources));
}
/**
 * safeStingify - JSONsimilar to .stringify, except ignores circular references.
 * Usage:  safeStingify(object);
 *
 * @param obj - any object.
 */
function safeStringify(obj) {
    var cache = [];
    return JSON.stringify(obj, function (key, value) {
        if (typeof value === "object" && value !== null) {
            if (cache.indexOf(value) !== -1) {
                return;
            }
            cache.push(value);
        }
        return value;
    });
}
function isArray$1(arg) {
    if (Array.isArray !== undefined) {
        return Array.isArray(arg);
    }
    return Object.prototype.toString.call(arg) === "[object Array]";
}
function classID2Meta(classID) {
    var info = classID.split("_");
    var classInfo = info[1].split(".");
    return {
        module: "@hpcc-js/" + info[0],
        file: classInfo[0],
        class: classInfo[1] || classInfo[0]
    };
}

var ObserverHandle = /** @class */ (function () {
    function ObserverHandle(eventTarget, eventID, callback) {
        this.eventTarget = eventTarget;
        this.eventID = eventID;
        this.callback = callback;
    }
    ObserverHandle.prototype.release = function () {
        this.eventTarget.removeObserver(this.eventID, this.callback);
    };
    ObserverHandle.prototype.unwatch = function () {
        this.release();
    };
    return ObserverHandle;
}());
var Observable = /** @class */ (function () {
    function Observable() {
        var events = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            events[_i] = arguments[_i];
        }
        this._eventObservers = {};
    }
    Observable.prototype.addObserver = function (eventID, callback) {
        var eventObservers = this._eventObservers[eventID];
        if (!eventObservers) {
            eventObservers = [];
            this._eventObservers[eventID] = eventObservers;
        }
        eventObservers.push(callback);
        return new ObserverHandle(this, eventID, callback);
    };
    Observable.prototype.removeObserver = function (eventID, callback) {
        var eventObservers = this._eventObservers[eventID];
        if (eventObservers) {
            for (var i = eventObservers.length - 1; i >= 0; --i) {
                if (eventObservers[i] === callback) {
                    eventObservers.splice(i, 1);
                }
            }
        }
        return this;
    };
    Observable.prototype.dispatchEvent = function (eventID) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var eventObservers = this._eventObservers[eventID];
        if (eventObservers) {
            for (var _a = 0, eventObservers_1 = eventObservers; _a < eventObservers_1.length; _a++) {
                var observer = eventObservers_1[_a];
                observer.apply(void 0, args);
            }
        }
        return this;
    };
    Observable.prototype._hasObserver = function (eventID) {
        var eventObservers = this._eventObservers[eventID];
        for (var observer in eventObservers) {
            if (eventObservers[observer]) {
                return true;
            }
        }
        return false;
    };
    Observable.prototype.hasObserver = function (_eventID) {
        if (_eventID !== void 0) {
            return this._hasObserver(_eventID);
        }
        for (var eventID in this._eventObservers) {
            if (this._hasObserver(eventID)) {
                return true;
            }
        }
        return false;
    };
    return Observable;
}());

var requestAnimationFrame;
// let cancelAnimationFrame: CancelAnimationFrame;
(function () {
    if (root.requestAnimationFrame) {
        requestAnimationFrame = root.requestAnimationFrame;
        // cancelAnimationFrame = root.cancelAnimationFrame;
    }
    else {
        var lastTime_1 = 0;
        requestAnimationFrame = function (callback) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime_1));
            var id = setTimeout(function () { return callback(currTime + timeToCall); }, timeToCall);
            lastTime_1 = currTime + timeToCall;
            return id;
        };
        // cancelAnimationFrame = function (handle: number): void {
        //     clearTimeout(handle);
        // };
    }
})();
var Message = /** @class */ (function () {
    function Message() {
    }
    Object.defineProperty(Message.prototype, "canConflate", {
        get: function () { return false; },
        enumerable: true,
        configurable: true
    });
    Message.prototype.conflate = function (other) {
        return false;
    };
    Message.prototype.void = function () {
        return false;
    };
    return Message;
}());
var Dispatch = /** @class */ (function () {
    function Dispatch() {
        this._observerID = 0;
        this._observers = [];
        this._messageBuffer = [];
    }
    Dispatch.prototype.observers = function () {
        return this._observers;
    };
    Dispatch.prototype.messages = function () {
        var retVal = [];
        this._messageBuffer.forEach(function (msg) {
            if (!retVal.some(function (msg2) { return msg2.canConflate && msg2.conflate(msg); })) {
                retVal.push(msg);
            }
        });
        return retVal;
    };
    Dispatch.prototype.dispatchAll = function () {
        this.dispatch(this.messages());
        this.flush();
    };
    Dispatch.prototype.dispatch = function (messages) {
        if (messages.length === 0)
            return;
        this.observers().forEach(function (o) {
            var msgs = messages.filter(function (m) { return !m.void() && (o.type === undefined || m instanceof o.type); });
            if (msgs.length) {
                o.callback(msgs);
            }
        });
    };
    Dispatch.prototype.hasObserver = function () {
        return this._observers.length > 0;
    };
    Dispatch.prototype.flush = function () {
        this._messageBuffer = [];
    };
    Dispatch.prototype.send = function (msg) {
        this.dispatch([msg]);
    };
    Dispatch.prototype.post = function (msg) {
        var _this = this;
        this._messageBuffer.push(msg);
        requestAnimationFrame(function () { return _this.dispatchAll(); });
    };
    Dispatch.prototype.attach = function (callback, type) {
        var context = this;
        var id = ++this._observerID;
        this._observers.push({ id: id, type: type, callback: callback });
        return {
            release: function () {
                context._observers = context._observers.filter(function (o) { return o.id !== id; });
            },
            unwatch: function () {
                this.release();
            }
        };
    };
    return Dispatch;
}());

var XMLNode = /** @class */ (function () {
    function XMLNode(name) {
        this.name = "";
        this.$ = {};
        this._children = [];
        this.content = "";
        this.name = name;
    }
    XMLNode.prototype.appendAttribute = function (key, val) {
        this.$[key] = val;
    };
    XMLNode.prototype.appendContent = function (content) {
        this.content += content;
    };
    XMLNode.prototype.appendChild = function (child) {
        this._children.push(child);
    };
    XMLNode.prototype.children = function (tag) {
        if (tag === undefined) {
            return this._children;
        }
        return this._children.filter(function (xmlNode) {
            return xmlNode.name === tag;
        });
    };
    return XMLNode;
}());
var SAXStackParser = /** @class */ (function () {
    function SAXStackParser() {
        this.stack = new Stack();
    }
    SAXStackParser.prototype.walkDoc = function (node) {
        var xmlNode = this._startXMLNode(node);
        if (node.attributes) {
            for (var i = 0; i < node.attributes.length; ++i) {
                var attribute = node.attributes.item(i);
                this.attributes(attribute.nodeName, attribute.nodeValue);
            }
        }
        this.startXMLNode(xmlNode);
        if (node.childNodes) {
            for (var i = 0; i < node.childNodes.length; ++i) {
                var childNode = node.childNodes.item(i);
                if (childNode.nodeType === childNode.TEXT_NODE) {
                    this.characters(childNode.nodeValue);
                }
                else {
                    this.walkDoc(childNode);
                }
            }
        }
        this.endXMLNode(this.stack.pop());
    };
    SAXStackParser.prototype._startXMLNode = function (node) {
        var newNode = new XMLNode(node.nodeName);
        if (!this.stack.depth()) {
            this.root = newNode;
        }
        else {
            this.stack.top().appendChild(newNode);
        }
        return this.stack.push(newNode);
    };
    SAXStackParser.prototype.parse = function (xml) {
        var domParser = new DOMParser();
        var doc = domParser.parseFromString(xml, "application/xml");
        this.startDocument();
        this.walkDoc(doc);
        this.endDocument();
    };
    //  Callbacks  ---
    SAXStackParser.prototype.startDocument = function () {
    };
    SAXStackParser.prototype.endDocument = function () {
    };
    SAXStackParser.prototype.startXMLNode = function (node) {
    };
    SAXStackParser.prototype.endXMLNode = function (node) {
    };
    SAXStackParser.prototype.attributes = function (key, val) {
        this.stack.top().appendAttribute(key, val);
    };
    SAXStackParser.prototype.characters = function (text) {
        this.stack.top().appendContent(text);
    };
    return SAXStackParser;
}());
var XML2JSONParser = /** @class */ (function (_super) {
    __extends(XML2JSONParser, _super);
    function XML2JSONParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    XML2JSONParser.prototype.startXMLNode = function (node) {
        _super.prototype.startXMLNode.call(this, node);
        switch (node.name) {
            case "xs:element":
                break;
            case "xs:simpleType":
                break;
            default:
                break;
        }
    };
    XML2JSONParser.prototype.endXMLNode = function (node) {
        switch (node.name) {
            case "xs:element":
                break;
            case "xs:simpleType":
                break;
            default:
                break;
        }
        _super.prototype.endXMLNode.call(this, node);
    };
    return XML2JSONParser;
}(SAXStackParser));
function xml2json(xml) {
    var saxParser = new XML2JSONParser();
    saxParser.parse(xml);
    return saxParser.root;
}

var PropChangedMessage = /** @class */ (function (_super) {
    __extends(PropChangedMessage, _super);
    function PropChangedMessage(property, newValue, oldValue) {
        var _this = _super.call(this) || this;
        _this.property = property;
        _this.newValue = newValue;
        _this.oldValue = oldValue;
        return _this;
    }
    Object.defineProperty(PropChangedMessage.prototype, "canConflate", {
        get: function () { return true; },
        enumerable: true,
        configurable: true
    });
    PropChangedMessage.prototype.conflate = function (other) {
        if (this.property === other.property) {
            this.newValue = other.newValue;
            return true;
        }
        return false;
    };
    PropChangedMessage.prototype.void = function () {
        return this.newValue === this.oldValue;
    };
    return PropChangedMessage;
}(Message));
var StateObject = /** @class */ (function () {
    function StateObject() {
        this._espState = {};
        this._dispatch = new Dispatch();
        this._monitorTickCount = 0;
    }
    StateObject.prototype.clear = function (newVals) {
        this._espState = {};
        if (newVals !== void 0) {
            this.set(newVals);
        }
        this._monitorTickCount = 0;
    };
    StateObject.prototype.get = function (key, defValue) {
        if (key === void 0) {
            return this._espState;
        }
        return this.has(key) ? this._espState[key] : defValue;
    };
    StateObject.prototype.set = function (keyOrNewVals, newVal) {
        if (typeof keyOrNewVals === "string") {
            return this.setSingle(keyOrNewVals, newVal); //  TODO:  "as any" should not be needed (TS >= 3.1.x)
        }
        this.setAll(keyOrNewVals);
    };
    StateObject.prototype.setSingle = function (key, newVal) {
        var oldVal = this._espState[key];
        this._espState[key] = newVal;
        this._dispatch.post(new PropChangedMessage(key, newVal, oldVal));
    };
    StateObject.prototype.setAll = function (_) {
        for (var key in _) {
            if (_.hasOwnProperty(key)) {
                this.setSingle(key, _[key]);
            }
        }
    };
    StateObject.prototype.has = function (key) {
        return this._espState[key] !== void 0;
    };
    StateObject.prototype.addObserver = function (eventID, propIDOrCallback, callback) {
        if (this.isCallback(propIDOrCallback)) {
            if (eventID !== "changed")
                throw new Error("Invalid eventID:  " + eventID);
            return this._dispatch.attach(function (messages) {
                propIDOrCallback(messages.map(function (m) { return ({
                    id: m.property,
                    oldValue: m.oldValue,
                    newValue: m.newValue
                }); }));
            });
        }
        else {
            if (eventID !== "propChanged")
                throw new Error("Invalid eventID:  " + eventID);
            return this._dispatch.attach(function (messages) {
                var filteredMessages = messages.filter(function (m) { return m.property === propIDOrCallback; });
                if (filteredMessages.length) {
                    if (filteredMessages.length > 1) {
                        console.warn("Should only be 1 message?");
                    }
                    var event_1 = filteredMessages[filteredMessages.length - 1];
                    callback({
                        id: event_1.property,
                        oldValue: event_1.oldValue,
                        newValue: event_1.newValue
                    });
                }
            });
        }
    };
    StateObject.prototype.on = function (eventID, propIDOrCallback, callback) {
        this.addObserver(eventID, propIDOrCallback, callback);
        return this;
    };
    StateObject.prototype.isCallback = function (propIDOrCallback) {
        return (typeof propIDOrCallback === "function");
    };
    StateObject.prototype.hasEventListener = function () {
        return this._dispatch.hasObserver();
    };
    //  Monitoring  ---
    StateObject.prototype.refresh = function (full) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.resolve()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this];
                }
            });
        });
    };
    StateObject.prototype._monitor = function () {
        var _this = this;
        if (this._monitorHandle) {
            this._monitorTickCount = 0;
            return;
        }
        this._monitorHandle = setTimeout(function () {
            var refreshPromise = _this.hasEventListener() ? _this.refresh() : Promise.resolve();
            refreshPromise.then(function () {
                _this._monitor();
            });
            delete _this._monitorHandle;
        }, this._monitorTimeoutDuraction());
    };
    StateObject.prototype._monitorTimeoutDuraction = function () {
        ++this._monitorTickCount;
        if (this._monitorTickCount <= 1) { //  Once
            return 0;
        }
        return 30000;
    };
    StateObject.prototype.watch = function (callback, triggerChange) {
        var _this = this;
        if (triggerChange === void 0) { triggerChange = true; }
        if (typeof callback !== "function") {
            throw new Error("Invalid Callback");
        }
        if (triggerChange) {
            setTimeout(function () {
                var props = _this.get();
                var changes = [];
                for (var key in props) {
                    if (props.hasOwnProperty(props)) {
                        changes.push({ id: key, newValue: props[key], oldValue: undefined });
                    }
                }
                callback(changes);
            }, 0);
        }
        var retVal = this.addObserver("changed", callback);
        this._monitor();
        return retVal;
    };
    return StateObject;
}());

function trim(str, char) {
    if (typeof char !== "string")
        return str;
    if (char.length === 0)
        return str;
    while (str.indexOf(char) === 0) {
        str = str.substring(1);
    }
    while (endsWith(str, char)) {
        str = str.substring(0, str.length - 1);
    }
    return str;
}
function endsWith(origString, searchString, position) {
    var subjectString = origString.toString();
    if (typeof position !== "number" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
        position = subjectString.length;
    }
    position -= searchString.length;
    var lastIndex = subjectString.lastIndexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
}

function join() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var partialUrl = args.length && args[0].length && args[0].charAt(0) === "/";
    return (partialUrl ? "/" : "") + args.map(function (arg) {
        return trim(arg, "/");
    }).join("/");
}

export { AsyncCache, AsyncOrderedQueue, BUILD_VERSION, Cache, Dictionary, DictionaryNoCase, Dispatch, Edge, Graph, GraphItem, Level, Logging, Message, Observable, PKG_NAME, PKG_VERSION, SAXStackParser, ScopedLogging, Stack, StateObject, Subgraph, Vertex, XMLNode, classID2Meta, compare, debounce, deepEquals, deepMixin, deepMixinT, degreesToRadians, endsWith, espTime2Seconds, exists, find, hashSum, inner, isArray$1 as isArray, isBrowser, isNode, isTravis, join, logger, normalize, normalizeDegrees, normalizeRadians, promiseTimeout, radiansToDegrees, root, safeStringify, scopedLogger, trim, update, xml2json };
//# sourceMappingURL=index.es6.js.map
