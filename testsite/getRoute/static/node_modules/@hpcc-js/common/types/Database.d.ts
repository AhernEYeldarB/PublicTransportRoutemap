import { PropertyExt } from "./PropertyExt";
export interface INestedColumn {
    label: string;
    columns: Array<string | INestedColumn>;
}
export declare type FieldType = "string" | "number" | "boolean" | "date" | "time" | "hidden" | "nested";
export declare class Field extends PropertyExt {
    private _owner;
    idx: number;
    protected _children: Field[];
    constructor(id?: any);
    owner(): Grid;
    owner(_: Grid): this;
    valid(): boolean;
    checksum(): string;
    typeTransformer(_: any): any;
    maskTransformer(_: any): any;
    formatTransformer(_: any): any;
    parse(_: any): any;
    transform(_: any): any;
    clone(): Field;
    formatter(format: any): any;
    children(): Field[];
    children(_: Array<string | INestedColumn | Field>, asDefault?: boolean): this;
    label_default: {
        (): string;
        (x: string): Field;
    };
    label: {
        (): string;
        (x: string): Field;
    };
    mask: {
        (): string;
        (x: string): Field;
    };
    format: {
        (): string;
        (x: string): Field;
    };
}
export interface Field {
    type(): FieldType;
    type(_: FieldType): this;
}
export declare class Grid extends PropertyExt {
    _dataChecksum: boolean;
    _dataVersion: number;
    private _data;
    private _dataChecksums;
    constructor(dataChecksum?: any);
    clear(): this;
    resetColumns(): void;
    legacyColumns(_?: any, asDefault?: any): any | Grid;
    legacyData(_?: any, _clone?: any): any;
    schema(): void;
    field(idx: any): Field;
    fieldByLabel(_: any, ignoreCase?: any): Field;
    data(_?: any, clone?: any): any | Grid;
    parsedData(): any[];
    formattedData(): any[][];
    fieldsChecksum(): string;
    dataChecksum(): string;
    checksum(): string;
    private _dataCalcChecksum;
    row(row?: any, _?: any, asDefault?: any): any | Grid;
    rows(_?: any): any | Grid;
    column(col: any, _?: any): any | Grid;
    columnData(col: any, _: any): any | Grid;
    columns(_?: any): any | Grid;
    cell(row: any, col: any, _: any): any;
    grid(_?: any): any;
    hipieMappings(columns: any, missingDataString: any): any[];
    legacyView(): LegacyView;
    nestView(columnIndicies: any): RollupView;
    rollupView(columnIndicies: any, rollupFunc?: any): RollupView;
    aggregateView(columnIndicies: any, aggrType: any, aggrColumn: any, aggrDeltaColumn?: string): RollupView;
    private _nest;
    nest(columnIndicies: any): {
        key: string;
        values: any;
        value: undefined;
    }[];
    rollup(columnIndicies: any, rollup: any): {
        key: string;
        values: any;
        value: undefined;
    }[];
    length(): number;
    width(): number;
    pivot(): this;
    clone(deep: any): any;
    filter(filter: any): any;
    analyse(columns: any): any[];
    jsonObj(_?: any): any | Grid;
    json(_: string | object): this;
    json(): string;
    csv(_: any): this;
    csv(): string;
    tsv(_: any): this;
    tsv(): string;
}
export interface Grid {
    fields(): Field[];
    fields(_: Field[], clone?: boolean): this;
}
export declare class LegacyView {
    _grid: any;
    _parsedData: any;
    _parsedDataChecksum: any;
    _formattedData: any;
    _formattedDataChecksum: any;
    constructor(grid: any);
    checksum(): any;
    fields(): any;
    grid(): any;
    columns(_?: any): any;
    rawData(_?: any): any;
    formattedData(): any;
    parsedData(): any;
    protected _whichData(opts?: any): any;
    data(_: any): any;
}
export declare class RollupView extends LegacyView {
    _columnIndicies: any;
    _rollup: any;
    _nestChecksum: any;
    _nest: any;
    constructor(grid: any, columns: any, rollup?: any);
    nest(): any;
    entries(opts?: any): any;
    map(opts: any): any;
    d3Map(opts: any): any;
    _walkData(entries: any, prevRow?: any[]): any[];
    data(opts: any): any[];
}
//# sourceMappingURL=Database.d.ts.map