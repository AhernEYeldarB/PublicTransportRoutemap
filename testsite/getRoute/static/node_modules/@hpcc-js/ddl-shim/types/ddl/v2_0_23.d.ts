export declare type RowType = {
    [key: string]: any;
};
export declare type Number64 = string;
export declare type Range = [number | string, number | string];
export declare type Dataset = any[];
export declare type IFieldType = "boolean" | "number" | "number64" | "string" | "range" | "dataset" | "object";
export interface IFieldBoolean {
    type: "boolean";
    id: string;
    default?: boolean;
}
export interface IFieldNumber {
    type: "number";
    id: string;
    default?: number;
}
export interface IFieldNumber64 {
    type: "number64";
    id: string;
    default?: Number64;
}
export interface IFieldString {
    type: "string";
    id: string;
    default?: string;
}
export interface IFieldRange {
    type: "range";
    id: string;
    default?: Range;
}
export interface IFieldDataset {
    type: "dataset";
    id: string;
    default?: Dataset;
    children: IField[];
}
export interface IFieldObject {
    type: "object";
    id: string;
    default?: object;
    fields: {
        [key: string]: IField;
    };
}
export declare type IField = IFieldBoolean | IFieldNumber | IFieldNumber64 | IFieldString | IFieldRange | IFieldDataset | IFieldObject;
export declare type IServiceType = "wuresult" | "hipie" | "roxie";
export declare type IDatasourceType = IServiceType | "logicalfile" | "form" | "databomb";
export declare type DatasourceType = ILogicalFile | IForm | IDatabomb | IWUResult | IHipieService | IRoxieService;
export interface IDatasource {
    type: IDatasourceType;
    id: string;
    fields: IField[];
}
export interface IESPService extends IDatasource {
    url: string;
}
export interface IService {
    type: IServiceType;
    id: string;
    url: string;
}
export interface IOutput {
    fields: IField[];
}
export declare type OutputDict = {
    [key: string]: IOutput;
};
export interface IWUResult extends IService {
    type: "wuresult";
    wuid: string;
    outputs: OutputDict;
}
export interface ILogicalFile extends IESPService {
    type: "logicalfile";
    logicalFile: string;
}
export interface IRoxieService extends IService {
    type: "roxie";
    querySet: string;
    queryID: string;
    inputs: IField[];
    outputs: OutputDict;
}
export interface IHipieService extends IService {
    type: "hipie";
    querySet: string;
    queryID: string;
    inputs: IField[];
    outputs: OutputDict;
}
export interface IForm extends IDatasource {
    type: "form";
}
export declare type IDatabombFormat = "csv" | "tsv" | "json";
export interface IDatabomb extends IDatasource {
    type: "databomb";
    format: IDatabombFormat;
    payload?: string;
}
export interface IDatasourceBaseRef {
    id: string;
}
export interface IDatabombRef extends IDatasourceBaseRef {
}
export interface IWUResultRef extends IDatasourceBaseRef {
    output: string;
}
export interface IRequestField {
    source: string;
    remoteFieldID: string;
    localFieldID: string;
}
export interface IRoxieServiceRef extends IDatasourceBaseRef {
    request: IRequestField[];
    output: string;
}
export declare type IDatasourceRef = IDatabombRef | IWUResultRef | IRoxieServiceRef;
export declare function isDatabombRef(ref: IDatasourceRef): ref is IDatabombRef;
export declare function isWUResultRef(ref: IDatasourceRef): ref is IWUResultRef;
export declare function isRoxieServiceRef(ref: IDatasourceRef): ref is IRoxieServiceRef;
export declare type IActivityType = "filter" | "project" | "groupby" | "sort" | "limit" | "mappings";
export declare type ActivityType = IFilter | IProject | IGroupBy | ISort | ILimit | IMappings;
export interface IActivity {
    type: IActivityType;
}
export declare type IMappingConditionType = "==" | "!=" | ">" | ">=" | "<" | "<=" | "range" | "in";
export interface IMapping {
    remoteFieldID: string;
    localFieldID: string;
    condition: IMappingConditionType;
    nullable: boolean;
}
export interface IFilterCondition {
    viewID: string;
    mappings: IMapping[];
}
export interface IFilter extends IActivity {
    type: "filter";
    conditions: IFilterCondition[];
}
export declare function isFilterActivity(activity: IActivity): activity is IFilter;
export interface IEquals {
    fieldID: string;
    type: "=";
    sourceFieldID: string;
    transformations?: MultiTransformationType[];
}
export declare type ICalculatedType = "+" | "-" | "*" | "/";
export interface ICalculated {
    fieldID: string;
    type: ICalculatedType;
    sourceFieldID1: string;
    sourceFieldID2: string;
}
export interface IScale {
    fieldID: string;
    type: "scale";
    sourceFieldID: string;
    factor: number;
}
export interface ITemplate {
    fieldID: string;
    type: "template";
    template: string;
}
export interface IMapMapping {
    value: any;
    newValue: any;
}
export interface IMap {
    fieldID: string;
    type: "map";
    sourceFieldID: string;
    default: any;
    mappings: IMapMapping[];
}
export declare type MultiTransformationType = IEquals | ICalculated | IScale | ITemplate | IMap;
export interface IMulti {
    fieldID: string;
    type: "multi";
    transformations: MultiTransformationType[];
}
export declare type ProjectTransformationType = MultiTransformationType | IMulti;
export interface IProject extends IActivity {
    type: "project";
    transformations: ProjectTransformationType[];
}
export declare function isProjectActivity(activity: IActivity): activity is IProject;
export interface IMappings extends IActivity {
    type: "mappings";
    transformations: ProjectTransformationType[];
}
export declare function isMappingsActivity(activity: IActivity): activity is IMappings;
export declare type IAggregateType = "min" | "max" | "sum" | "mean" | "variance" | "deviation";
export interface IAggregate {
    fieldID: string;
    type: IAggregateType;
    inFieldID: string;
    baseCountFieldID?: string;
}
export interface ICount {
    fieldID: string;
    type: "count";
}
export declare type AggregateType = IAggregate | ICount;
export interface IGroupBy extends IActivity {
    type: "groupby";
    groupByIDs: string[];
    aggregates: AggregateType[];
}
export declare function isGroupByActivity(activity: IActivity): activity is IGroupBy;
export interface ISortCondition {
    fieldID: string;
    descending: boolean;
}
export interface ISort extends IActivity {
    type: "sort";
    conditions: ISortCondition[];
}
export declare function isSortActivity(activity: IActivity): activity is ISort;
export interface ILimit extends IActivity {
    type: "limit";
    limit: number;
}
export declare function isLimitActivity(activity: IActivity): activity is ILimit;
export interface IWidgetProperties {
    __class: string;
    [propID: string]: string | string[] | number | boolean | undefined | IWidgetProperties | IWidgetProperties[];
}
export interface IWidget {
    id: string;
    chartType: string;
    __class: string;
    properties: IWidgetProperties;
}
export declare type VisibilityType = "normal" | "flyout";
export declare const VisibilitySet: VisibilityType[];
export interface IVisualization extends IWidget {
    title: string;
    description?: string;
    visibility: VisibilityType;
    mappings: IMappings;
}
export interface IView {
    id: string;
    datasource: IDatasourceRef;
    activities: ActivityType[];
    visualization: IVisualization;
}
export interface IProperties {
    [propID: string]: any;
}
export interface Schema {
    version: "2.0.23";
    createdBy: {
        name: string;
        version: string;
    };
    datasources: DatasourceType[];
    dataviews: IView[];
    properties?: IProperties;
    hipieProperties?: IProperties;
    defs?: {
        fieldTypes: {
            number64: Number64;
            range: Range;
            dataset: Dataset;
            fieldType: IFieldType;
            fieldBoolean: IFieldBoolean;
            fieldNumber: IFieldNumber;
            fieldNumber64: IFieldNumber64;
            fieldString: IFieldString;
            fieldRange: IFieldRange;
            fieldDataset: IFieldDataset;
            fieldObject: IFieldObject;
            field: IField;
        };
        datasourceTypes: {
            datasource: IDatasource;
            logicalFile: ILogicalFile;
            form: IForm;
            databomb: IDatabomb;
            wuresult: IWUResult;
            hipieService: IHipieService;
            roxieService: IRoxieService;
        };
        datasourceRefTypes: {
            wuResultRef: IWUResultRef;
            roxieServiceRef: IRoxieServiceRef;
        };
        activityTypes: {
            filter: IFilter;
            project: IProject;
            groupby: IGroupBy;
            sort: ISort;
            limit: ILimit;
            mappings: IMappings;
        };
        aggregateTypes: {
            aggregate: IAggregate;
            count: ICount;
        };
        transformationTypes: {
            equals: IEquals;
            calculated: ICalculated;
            scale: IScale;
            template: ITemplate;
            map: IMap;
            multi: IMulti;
        };
    };
}
//# sourceMappingURL=v2_0_23.d.ts.map