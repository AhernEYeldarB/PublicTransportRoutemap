import { HTMLWidget, Utility, Palette, CanvasWidget, SVGWidget, Entity, Widget, Platform, PropertyExt } from '@hpcc-js/common';
import { VerticalList, HorizontalList, Grid } from '@hpcc-js/layout';

var PKG_NAME = "@hpcc-js/other";
var PKG_VERSION = "2.13.2";
var BUILD_VERSION = "2.10.1";

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, delay);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clockNow, interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

var Audio = /** @class */ (function (_super) {
    __extends(Audio, _super);
    function Audio() {
        var _this = _super.call(this) || this;
        _this._tag = "audio";
        _this._sections = {};
        return _this;
    }
    Audio.prototype.section = function (label, offset, beatLength, beatCount) {
        if (!arguments.length)
            return this._sections;
        if (arguments.length === 1)
            return this._sections[label];
        this._sections[label] = {
            label: label,
            offset: offset,
            beatLength: beatLength,
            beatCount: beatCount,
            endOffset: offset + beatCount * beatLength
        };
        return this;
    };
    Audio.prototype.getType = function (fileExt) {
        switch (fileExt) {
            case "mp3":
                return "audio/mpeg; codecs='mp3'";
            case "ogg":
                return "audio/ogg; codecs='vorbis'";
        }
        return "";
    };
    Audio.prototype.enter = function (domNode, element) {
        var context = this;
        element.on("play", function (d) { context.onPlay(d); });
    };
    Audio.prototype.update = function (domNode, element) {
        var source = element.selectAll("source").data(this.source(), function (d) { return d; });
        source.enter().append("source")
            .attr("src", function (d) { return d; });
    };
    Audio.prototype.createTimer = function (params, startTime, beat) {
        var context = this;
        timer(function () {
            context.onTick(params.label, beat, params);
            return true;
        }, beat * params.beatLength, startTime + params.offset);
    };
    Audio.prototype.onTick = function (label, beat, params) {
    };
    Audio.prototype.onPlay = function (d) {
        var startTime = Date.now();
        for (var key in this._sections) {
            var section = this._sections[key];
            for (var i = 0; i < section.beatCount; ++i) {
                this.createTimer(section, startTime, i);
            }
        }
    };
    Audio.prototype.play = function (d) {
        var context = this;
        this._element.on("canplaythrough", function (d2) {
            context.node().play();
        });
        this.node().load();
    };
    return Audio;
}(HTMLWidget));
Audio.prototype._class += " other_Audio";
Audio.prototype.publish("source", "", "string", "Audio Source");

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var autoComplete_1 = createCommonjsModule(function (module) {
/*
    JavaScript autoComplete v1.0.4
    Copyright (c) 2014 Simon Steinberger / Pixabay
    GitHub: https://github.com/Pixabay/JavaScript-autoComplete
    License: http://www.opensource.org/licenses/mit-license.php
*/

var autoComplete = (function(){
    // "use strict";
    function autoComplete(options){
        if (!document.querySelector) return;

        // helpers
        function hasClass(el, className){ return el.classList ? el.classList.contains(className) : new RegExp('\\b'+ className+'\\b').test(el.className); }

        function addEvent(el, type, handler){
            if (el.attachEvent) el.attachEvent('on'+type, handler); else el.addEventListener(type, handler);
        }
        function removeEvent(el, type, handler){
            // if (el.removeEventListener) not working in IE11
            if (el.detachEvent) el.detachEvent('on'+type, handler); else el.removeEventListener(type, handler);
        }
        function live(elClass, event, cb, context){
            addEvent(context || document, event, function(e){
                var found, el = e.target || e.srcElement;
                while (el && !(found = hasClass(el, elClass))) el = el.parentElement;
                if (found) cb.call(el, e);
            });
        }

        var o = {
            selector: 0,
            source: 0,
            minChars: 3,
            delay: 150,
            offsetLeft: 0,
            offsetTop: 1,
            cache: 1,
            menuClass: '',
            renderItem: function (item, search){
                // escape special characters
                search = search.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                var re = new RegExp("(" + search.split(' ').join('|') + ")", "gi");
                return '<div class="autocomplete-suggestion" data-val="' + item + '">' + item.replace(re, "<b>$1</b>") + '</div>';
            },
            onSelect: function(e, term, item){}
        };
        for (var k in options) { if (options.hasOwnProperty(k)) o[k] = options[k]; }

        // init
        var elems = typeof o.selector == 'object' ? [o.selector] : document.querySelectorAll(o.selector);
        for (var i=0; i<elems.length; i++) {
            var that = elems[i];

            // create suggestions container "sc"
            that.sc = document.createElement('div');
            that.sc.className = 'autocomplete-suggestions '+o.menuClass;

            that.autocompleteAttr = that.getAttribute('autocomplete');
            that.setAttribute('autocomplete', 'off');
            that.cache = {};
            that.last_val = '';

            that.updateSC = function(resize, next){
                var rect = that.getBoundingClientRect();
                that.sc.style.left = Math.round(rect.left + (window.pageXOffset || document.documentElement.scrollLeft) + o.offsetLeft) + 'px';
                that.sc.style.top = Math.round(rect.bottom + (window.pageYOffset || document.documentElement.scrollTop) + o.offsetTop) + 'px';
                that.sc.style.width = Math.round(rect.right - rect.left) + 'px'; // outerWidth
                if (!resize) {
                    that.sc.style.display = 'block';
                    that.sc.classList.remove('hide');
                    if (!that.sc.maxHeight) { that.sc.maxHeight = parseInt((window.getComputedStyle ? getComputedStyle(that.sc, null) : that.sc.currentStyle).maxHeight); }
                    if (!that.sc.suggestionHeight) that.sc.suggestionHeight = that.sc.querySelector('.autocomplete-suggestion').offsetHeight;
                    if (that.sc.suggestionHeight)
                        if (!next) that.sc.scrollTop = 0;
                        else {
                            var scrTop = that.sc.scrollTop, selTop = next.getBoundingClientRect().top - that.sc.getBoundingClientRect().top;
                            if (selTop + that.sc.suggestionHeight - that.sc.maxHeight > 0)
                                that.sc.scrollTop = selTop + that.sc.suggestionHeight + scrTop - that.sc.maxHeight;
                            else if (selTop < 0)
                                that.sc.scrollTop = selTop + scrTop;
                        }
                }
            };
            addEvent(window, 'resize', that.updateSC);
            document.body.appendChild(that.sc);

            live('autocomplete-suggestion', 'mouseleave', function(e){
                var sel = that.sc.querySelector('.autocomplete-suggestion.selected');
                if (sel) setTimeout(function(){ sel.className = sel.className.replace('selected', ''); }, 20);
            }, that.sc);

            live('autocomplete-suggestion', 'mouseover', function(e){
                var sel = that.sc.querySelector('.autocomplete-suggestion.selected');
                if (sel) sel.className = sel.className.replace('selected', '');
                this.className += ' selected';
            }, that.sc);

            live('autocomplete-suggestion', 'mousedown', function(e){
                if (hasClass(this, 'autocomplete-suggestion')) { // else outside click
                    var v = this.getAttribute('data-val');
                    that.value = v;
                    o.onSelect(e, v, this);
                    that.sc.style.display = 'none';
                    that.sc.classList.add("hide");

                }
            }, that.sc);

            that.blurHandler = function(){
                try { var over_sb = document.querySelector('.autocomplete-suggestions:hover'); } catch(e){ var over_sb = 0; }
                if (!over_sb) {
                    that.last_val = that.value;
                    that.sc.style.display = 'none';
                    that.sc.classList.add("hide");
                    setTimeout(function(){
                      that.sc.style.display = 'none';
                      that.sc.classList.add("hide");
                    }, 350); // hide suggestions on fast input
                } else if (that !== document.activeElement) setTimeout(function(){ that.focus(); }, 20);
            };
            addEvent(that, 'blur', that.blurHandler);

            var suggest = function(data, val){
                if (!val) {
                    var val = that.value;
                }
                that.cache[val] = data;
                if (data.length && val.length >= o.minChars) {
                    var s = '';
                    for (var i=0;i<data.length;i++) s += o.renderItem(data[i], val);
                    that.sc.innerHTML = s;
                    that.updateSC(0);
                }
                else
                    that.sc.style.display = 'none';
                    that.sc.classList.add("hide");
            };

            that.keydownHandler = function(e){
                var key = window.event ? e.keyCode : e.which;
                // down (40), up (38)
                if ((key == 40 || key == 38) && that.sc.innerHTML) {
                    var next, sel = that.sc.querySelector('.autocomplete-suggestion.selected');
                    if (!sel) {
                        next = (key == 40) ? that.sc.querySelector('.autocomplete-suggestion') : that.sc.childNodes[that.sc.childNodes.length - 1]; // first : last
                        next.className += ' selected';
                        that.value = next.getAttribute('data-val');
                    } else {
                        next = (key == 40) ? sel.nextSibling : sel.previousSibling;
                        if (next) {
                            sel.className = sel.className.replace('selected', '');
                            next.className += ' selected';
                            that.value = next.getAttribute('data-val');
                        }
                        else { sel.className = sel.className.replace('selected', ''); that.value = that.last_val; next = 0; }
                    }
                    that.updateSC(0, next);
                    return false;
                }
                // esc
                else if (key == 27) {
                  that.value = that.last_val;
                  that.sc.style.display = 'none';
                  that.sc.classList.add("hide");
                }
                // enter
                else if (key == 13 || key == 9) {
                    if (that.sc.style.display !== 'none') {
                        e.preventDefault();
                    }
                    var sel = that.sc.querySelector('.autocomplete-suggestion.selected');
                    if (sel && that.sc.style.display != 'none') {
                      o.onSelect(e, sel.getAttribute('data-val'), sel);
                      setTimeout(function(){
                        that.sc.style.display = 'none';
                        that.sc.classList.add("hide");
                    }, 20); }
                }
            };
            addEvent(that, 'keydown', that.keydownHandler);

            that.keyupHandler = function(e){
                var key = window.event ? e.keyCode : e.which;
                if (!key || (key < 35 || key > 40) && key != 13 && key != 27) {
                    var val = that.value;
                    if (val.length >= o.minChars) {
                        if (val != that.last_val) {
                            that.last_val = val;
                            clearTimeout(that.timer);
                            if (o.cache) {
                                if (val in that.cache) { suggest(that.cache[val]); return; }
                                // no requests if previous suggestions were empty
                                for (var i=1; i<val.length-o.minChars; i++) {
                                    var part = val.slice(0, val.length-i);
                                    if (part in that.cache && !that.cache[part].length) { suggest([]); return; }
                                }
                            }
                            that.timer = setTimeout(function(){ o.source(val, suggest); }, o.delay);
                        }
                    } else {
                        that.last_val = val;
                        that.sc.style.display = 'none';
                        that.sc.classList.add("hide");
                    }
                }
            };
            addEvent(that, 'keyup', that.keyupHandler);

            that.focusHandler = function(e){
                that.last_val = '\n';
                that.keyupHandler(e);
            };
            if (!o.minChars) addEvent(that, 'focus', that.focusHandler);
        }

        // public destroy method
        this.destroy = function(){
            for (var i=0; i<elems.length; i++) {
                var that = elems[i];
                removeEvent(window, 'resize', that.updateSC);
                removeEvent(that, 'blur', that.blurHandler);
                removeEvent(that, 'focus', that.focusHandler);
                removeEvent(that, 'keydown', that.keydownHandler);
                removeEvent(that, 'keyup', that.keyupHandler);
                if (that.autocompleteAttr)
                    that.setAttribute('autocomplete', that.autocompleteAttr);
                else
                    that.removeAttribute('autocomplete');
                document.body.removeChild(that.sc);
                that = null;
            }
        };
    }
    return autoComplete;
})();

(function(){
    if ( module.exports)
        module.exports = autoComplete;
    else
        window.autoComplete = autoComplete;
})();
});

var AutoComplete = /*#__PURE__*/Object.freeze({
    'default': autoComplete_1,
    __moduleExports: autoComplete_1
});

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".other_autoCompleteText label{display:inline-block;vertical-align:top}.other_autoCompleteText input{width:100%;max-width:600px;outline:0;border-radius:100}.autocomplete-suggestions{text-align:left;cursor:default;border:1px solid #ccc;border-top:0;background:#fff;box-shadow:-1px 1px 3px rgba(0,0,0,.1);position:absolute;display:none;z-index:9999;max-height:254px;overflow:hidden;overflow-y:auto;box-sizing:border-box}.autocomplete-suggestion{position:relative;padding:0 .6em;line-height:23px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:1.02em;color:#333}.autocomplete-suggestion b{font-weight:400;color:#1f8dd6}.autocomplete-suggestion.selected{background:#f0f0f0}";
styleInject(css);

var AutoCompleteText = /** @class */ (function (_super) {
    __extends(AutoCompleteText, _super);
    function AutoCompleteText() {
        var _this = _super.call(this) || this;
        _this._tag = "div";
        return _this;
    }
    AutoCompleteText.prototype.autoCompleteTextData = function () {
        if (this.data().length === 0)
            return [];
        var view = this._db.rollupView([this.textColumn(), this.valueColumn()]);
        return view.entries().map(function (row, idx) {
            return {
                idx: idx,
                text: row.key,
                value: row.values.length ? row.values[0].key : "",
                origRow: row.values.length && row.values[0].value.length ? row.values[0].value[0] : []
            };
        }, this);
    };
    AutoCompleteText.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        this._span = element.append("span");
        this._prompt = this._span.append("label")
            .attr("for", this.id() + "_input");
        this._input = this._span.append("input")
            .attr("id", this.id() + "_input")
            .attr("name", this.id() + "_input_name")
            .attr("type", "text")
            .attr("placeholder", this.placeholder());
    };
    AutoCompleteText.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        this._prompt.text(this.label());
        this._input.style("width", this.textboxWidth_exists() ? this.textboxWidth() + "px" : null);
        if (this._prevMinCharsText !== this.minCharsText()) {
            this._prevMinCharsText = this.minCharsText();
            if (this._autoComplete) {
                this._autoComplete.destroy();
            }
            var context_1 = this;
            this._autoComplete = new AutoComplete({
                selector: "#" + this.id() + "_input",
                minChars: this.minCharsText(),
                delay: 150,
                offsetLeft: 0,
                offsetTop: 1,
                source: function (term, suggest) {
                    var field = context_1._db.fieldByLabel(context_1.textColumn());
                    if (field) {
                        term = term.toLowerCase();
                        var suggestions = context_1.autoCompleteTextData().filter(function (row) {
                            return row.origRow[field.idx].toLowerCase().indexOf(term) >= 0;
                        }).map(function (row) {
                            return {
                                text: row.origRow[field.idx],
                                rowIdx: row.idx
                            };
                        });
                        suggest(suggestions);
                    }
                },
                renderItem: function (item, search) {
                    search = search.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                    var re = new RegExp("(" + search.split(" ").join("|") + ")", "gi");
                    return '<div class="autocomplete-suggestion" data-val="' + item.text + '" data-row-idx="' + item.rowIdx + '">' + item.text.replace(re, "<b>$1</b>") + "</div>";
                },
                onSelect: function (e, term, item) {
                    var rowIdx = +item.getAttribute("data-row-idx");
                    var row = context_1.autoCompleteTextData()[rowIdx];
                    context_1.click(context_1.rowToObj(row.origRow), context_1.valueColumn(), true);
                }
            });
        }
    };
    AutoCompleteText.prototype.exit = function (domNode, element) {
        if (this._autoComplete) {
            this._autoComplete.destroy();
        }
        this._span.remove();
        _super.prototype.exit.call(this, domNode, element);
    };
    AutoCompleteText.prototype.click = function (row, column, selected) {
        console.log("Click:  " + JSON.stringify(row) + ", " + column + ", " + selected);
    };
    return AutoCompleteText;
}(HTMLWidget));
AutoCompleteText.prototype._class += " other_AutoCompleteText";
AutoCompleteText.prototype.publish("label", "Label: ", "string", "Label for AutoCompleteText");
AutoCompleteText.prototype.publish("textboxWidth", null, "number", "width of textbox", null, { optional: true });
AutoCompleteText.prototype.publish("placeholder", "Search...", "string", "Placeholder for AutoCompleteText");
AutoCompleteText.prototype.publish("valueColumn", null, "set", "Select column for autocomplete", function () { return this.columns(); }, { optional: true });
AutoCompleteText.prototype.publish("textColumn", null, "set", "Select value(s)", function () { return this.columns(); }, { optional: true });
AutoCompleteText.prototype.publish("minCharsText", 1, "number", "Size of multiAutoCompleteText box");

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);

function d3Extent(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

function d3Range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  this.fill = match[1] || " ";
  this.align = match[2] || ">";
  this.sign = match[3] || "-";
  this.symbol = match[4] || "";
  this.zero = !!match[5];
  this.width = match[6] && +match[6];
  this.comma = !!match[7];
  this.precision = match[8] && +match[8].slice(1);
  this.trim = !!match[9];
  this.type = match[10] || "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity(x) {
  return x;
}

var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending$1;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending$1(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function d3Select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function d3SelectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {} // eslint-disable-line no-empty
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});
var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});
var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale$1(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day$1;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day$1 = week.getUTCDay();
          week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day$1 = week.getDay();
          week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
          week = day.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day.count(year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale$1;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  timeFormat = locale$1.format;
  timeParse = locale$1.parse;
  utcFormat = locale$1.utcFormat;
  utcParse = locale$1.utcParse;
  return locale$1;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : utcParse(isoSpecifier);

var css$1 = ".other_CalendarHeatMap{shape-rendering:crispEdges}.other_CalendarHeatMap .day{fill:#fff;stroke:#ccc}.other_CalendarHeatMap .day.selected{stroke:red}.other_CalendarHeatMap .day.over{stroke:orange}.other_CalendarHeatMap .day.selected.over{stroke:red}.other_CalendarHeatMap .month{fill:none;stroke:#000;stroke-width:2px}";
styleInject(css$1);

var CalendarHeatMap = /** @class */ (function (_super) {
    __extends(CalendarHeatMap, _super);
    function CalendarHeatMap() {
        var _this = _super.call(this) || this;
        Utility.SimpleSelectionMixin.call(_this);
        return _this;
    }
    CalendarHeatMap.prototype.calendarData = function () {
        if (this.fields().length === 0 || this.data().length === 0) {
            return [];
        }
        var dateParser = timeParse(this.datePattern());
        var valueFormatter = this.aggrDeltaColumn() ? format(".1%") : format("s");
        if (this._prevDateColumn !== this.dateColumn() ||
            this._prevAggrType !== this.aggrType() ||
            this._prevAggrColumn !== this.aggrColumn() ||
            this._prevAggrDeltaColumn !== this.aggrDeltaColumn()) {
            this._prevDateColumn = this.dateColumn();
            this._prevAggrType = this.aggrType();
            this._prevAggrColumn = this.aggrColumn();
            this._prevAggrDeltaColumn = this.aggrDeltaColumn();
            this._view = this._db.aggregateView([this.dateColumn()], this.aggrType(), this.aggrColumn(), this.aggrDeltaColumn());
        }
        return this._view.entries().map(function (row) {
            row.dateKey = dateParser(row.key);
            row.formattedValues = valueFormatter(row.value.aggregate);
            row.origRows = row.value;
            return row;
        });
    };
    CalendarHeatMap.prototype.calcDelta = function (row) {
        return (row.Close - row.Open) / row.Open;
    };
    CalendarHeatMap.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        d3Select(domNode.parentNode)
            .style("overflow-y", "scroll")
            .style("overflow-x", "hidden")
            .style("height", "100%")
            .style("width", "100%");
        this._selection.widgetElement(element);
    };
    CalendarHeatMap.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        this._palette = this._palette.switch(this.paletteID());
        var width = this.width();
        var cellSize = (width / 12) / 5;
        var height = cellSize * 8;
        var data = this.calendarData();
        var mappedData = map(data, function (d) { return d.dateKey; });
        var dateExtent = d3Extent(data, function (d) {
            return d.dateKey.getFullYear();
        });
        var context = this;
        var svg = element.selectAll("svg").data(d3Range(+dateExtent[0], +dateExtent[1] + 1));
        var svgUpdate = svg.enter().append("svg")
            .each(function (d) {
            var svgElement = d3Select(this);
            var g = svgElement.append("g");
            g.append("text")
                .style("text-anchor", "middle");
            g.append("g")
                .attr("class", "days");
            var _d3TimeMonths = months(new Date(d, 0, 1), new Date(d + 1, 0, 1));
            var _months = g.append("g").attr("class", "months");
            _d3TimeMonths.forEach(function (_m) {
                _months.append("path")
                    .attr("class", "month")
                    .attr("d", calcMonthPath(_m))
                    .style("stroke", context.monthStrokeColor())
                    .style("stroke-width", context.monthStrokeWidth());
            });
        })
            .merge(svg)
            .attr("width", width)
            .attr("height", height);
        svgUpdate.select("g")
            .attr("transform", "translate(" + ((width - cellSize * 53) / 2) + "," + (height - cellSize * 7 - 1) + ")");
        svgUpdate.select("text")
            .attr("transform", "translate(-6," + cellSize * 3.5 + ")rotate(-90)")
            .text(function (d) { return d; });
        svg.exit().remove();
        var dataExtent = d3Extent(data, function (d) {
            return d.value.aggregate;
        });
        if (this.aggrDeltaColumn()) {
            var max = Math.max(Math.abs(+dataExtent[0]), Math.abs(+dataExtent[1]));
            dataExtent = [-max, max];
        }
        var dayRect = svgUpdate.select(".days").selectAll(".day").data(function (d) { return days(new Date(d, 0, 1), new Date(d + 1, 0, 1)); });
        var dayRectUpdate = dayRect.enter().append("rect")
            .attr("class", "day")
            .call(this._selection.enter.bind(this._selection))
            .on("click", function (d) {
            var data2 = mappedData.get(d);
            if (data2 && data2.value && data2.value && data2.value.length) {
                context.click(context.rowToObj(data2.value[0]), context.dateColumn(), context._selection.selected(this));
            }
        })
            .on("dblclick", function (d) {
            var data2 = mappedData.get(d);
            if (data2 && data2.value && data2.value && data2.value.length) {
                context.dblclick(context.rowToObj(data2.value[0]), context.dateColumn(), context._selection.selected(this));
            }
        }).each(function (d) {
            var dayRectElement = d3Select(this);
            dayRectElement.append("title");
        })
            .merge(dayRect)
            .attr("x", function (d) { return sunday.count(year(d), d) * cellSize; })
            .attr("y", function (d) { return d.getDay() * cellSize; })
            .attr("width", cellSize)
            .attr("height", cellSize)
            .style("stroke", this.dayStrokeColor())
            .style("stroke-width", this.dayStrokeWidth())
            .style("fill", null);
        dayRectUpdate.select("title")
            .text(function (d) { return d; });
        dayRectUpdate.filter(function (d) { return mappedData.has(d); })
            .style("fill", function (d) {
            var row = mappedData.get(d);
            if (!row || !row.value || !row.value.aggregate) {
                return null;
            }
            return context._palette(row.value.aggregate, dataExtent[0], dataExtent[1]);
        })
            .select("title")
            .text(function (d) {
            var data2 = mappedData.get(d);
            return data2.key + ": " + data2.formattedValues;
        });
        dayRect.exit().remove();
        var monthPath = svg.select(".months").selectAll(".month").data(function (d) { return months(new Date(d, 0, 1), new Date(d + 1, 0, 1)); });
        monthPath.enter().append("path")
            .attr("class", "month")
            .merge(monthPath)
            .attr("d", calcMonthPath)
            .style("stroke", this.monthStrokeColor())
            .style("stroke-width", this.monthStrokeWidth());
        monthPath.exit().remove();
        function calcMonthPath(t0) {
            var t1 = new Date(t0.getFullYear(), t0.getMonth() + 1, 0);
            var d0 = t0.getDay();
            var w0 = sunday.count(year(t0), t0);
            var d1 = t1.getDay();
            var w1 = sunday.count(year(t1), t1);
            return "M" + (w0 + 1) * cellSize + "," + d0 * cellSize +
                "H" + w0 * cellSize + "V" + 7 * cellSize +
                "H" + w1 * cellSize + "V" + (d1 + 1) * cellSize +
                "H" + (w1 + 1) * cellSize + "V" + 0 +
                "H" + (w0 + 1) * cellSize + "Z";
        }
    };
    CalendarHeatMap.prototype.exit = function (domNode, element) {
        _super.prototype.exit.call(this, domNode, element);
    };
    //  Events  ---
    CalendarHeatMap.prototype.click = function (row, column, selected) {
        console.log("Click:  " + JSON.stringify(row) + ", " + column + ", " + selected);
    };
    CalendarHeatMap.prototype.dblclick = function (row, column, selected) {
        console.log("Double click:  " + JSON.stringify(row) + ", " + column + ", " + selected);
    };
    return CalendarHeatMap;
}(HTMLWidget));
CalendarHeatMap.prototype._class += " other_CalendarHeatMap";
CalendarHeatMap.prototype.mixin(Utility.SimpleSelectionMixin);
CalendarHeatMap.prototype._palette = Palette.rainbow("default");
CalendarHeatMap.prototype.publish("paletteID", "YlOrRd", "set", "Color palette for this widget", CalendarHeatMap.prototype._palette.switch(), { tags: ["Basic", "Shared"] });
CalendarHeatMap.prototype.publish("dayStrokeColor", "#ccc", "html-color", "Color of day border");
CalendarHeatMap.prototype.publish("monthStrokeColor", "#000", "html-color", "Color of month border");
CalendarHeatMap.prototype.publish("dayStrokeWidth", 1, "number", "Pixel width of day border");
CalendarHeatMap.prototype.publish("monthStrokeWidth", 2, "number", "Pixel width of month border");
CalendarHeatMap.prototype.publish("dateColumn", null, "set", "Date Column", function () { return this.columns(); }, { optional: true });
CalendarHeatMap.prototype.publish("datePattern", "%Y-%m-%d", "string", "Date Pattern");
CalendarHeatMap.prototype.publish("aggrType", null, "set", "Aggregation Type", [null, "mean", "median", "sum", "min", "max"], { optional: true });
CalendarHeatMap.prototype.publish("aggrColumn", null, "set", "Aggregation Field", function () { return this.columns(); }, { optional: true, disable: function (w) { return !w.aggrType(); } });
CalendarHeatMap.prototype.publish("aggrDeltaColumn", null, "set", "Aggregation Field", function () { return this.columns(); }, { optional: true, disable: function (w) { return !w.aggrType(); } });

var TIMEOUT_DEFAULT = 60;
function espValFix(val) {
    if (val === undefined || val === null) {
        return null;
    }
    if (!val.trim) {
        if (val.Row) {
            return espRowFix(val.Row);
        }
        return val;
    }
    var retVal = val.trim();
    if (retVal !== "" && !isNaN(retVal)) {
        if (retVal.length <= 1 || retVal[0] !== "0" || retVal[1] === ".") {
            return Number(retVal);
        }
    }
    return retVal;
}
function espRowFix(row) {
    for (var key in row) {
        row[key] = espValFix(row[key]);
    }
    return row;
}
var ESPUrl = /** @class */ (function () {
    function ESPUrl() {
        this._protocol = "http:";
        this._hostname = "localhost";
    }
    ESPUrl.prototype.url = function (_) {
        if (!arguments.length)
            return this._url;
        this._url = _;
        var parser = document.createElement("a");
        parser.href = this._url;
        parser.href = parser.href; // This fixes an IE9/IE10 DOM value issue
        var params = {};
        if (parser.search.length) {
            var tmp = parser.search;
            if (tmp[0] === "?") {
                tmp = tmp.substring(1);
            }
            tmp = tmp.split("&");
            tmp.map(function (item) {
                var tmpItem = item.split("=");
                params[decodeURIComponent(tmpItem[0])] = decodeURIComponent(tmpItem[1]);
            });
        }
        this._protocol = parser.protocol;
        this._hostname = parser.hostname;
        this._port = parser.port;
        this._pathname = parser.pathname;
        while (this._pathname.length && this._pathname[0] === "/") {
            this._pathname = this._pathname.substring(1);
        }
        this._search = parser.search;
        this._params = params;
        this._hash = parser.hash;
        this._host = parser.host;
        return this;
    };
    ESPUrl.prototype.protocol = function (_) {
        if (!arguments.length)
            return this._protocol;
        this._protocol = _;
        return this;
    };
    ESPUrl.prototype.hostname = function (_) {
        if (!arguments.length)
            return this._hostname;
        this._hostname = _;
        return this;
    };
    ESPUrl.prototype.port = function (_) {
        if (!arguments.length)
            return this._port;
        this._port = _;
        return this;
    };
    ESPUrl.prototype.search = function (_) {
        if (!arguments.length)
            return this._search;
        this._search = _;
        return this;
    };
    ESPUrl.prototype.pathname = function (_) {
        if (!arguments.length)
            return this._pathname;
        this._pathname = _;
        return this;
    };
    ESPUrl.prototype.hash = function (_) {
        if (!arguments.length)
            return this._hash;
        this._hash = _;
        return this;
    };
    ESPUrl.prototype.host = function (_) {
        if (!arguments.length)
            return this._host;
        this._host = _;
        return this;
    };
    ESPUrl.prototype.params = function (_) {
        if (!arguments.length)
            return this._params;
        this._params = _;
        return this;
    };
    ESPUrl.prototype.param = function (key) {
        return this._params[key];
    };
    ESPUrl.prototype.isWsWorkunits = function () {
        return this._pathname.toLowerCase().indexOf("wsworkunits") >= 0 || this._params["Wuid"];
    };
    ESPUrl.prototype.isWorkunitResult = function () {
        return this.isWsWorkunits() && (this._params["Sequence"] || this._params["ResultName"]);
    };
    ESPUrl.prototype.isWsEcl = function () {
        return this._pathname.toLowerCase().indexOf("wsecl") >= 0 || (this._params["QuerySetId"] && this._params["Id"]);
    };
    ESPUrl.prototype.isWsWorkunits_GetStats = function () {
        return this._pathname.toLowerCase().indexOf("wsworkunits/wugetstats") >= 0 && this._params["WUID"];
    };
    ESPUrl.prototype.getUrl = function (overrides) {
        overrides = overrides || {};
        return (overrides.protocol !== undefined ? overrides.protocol : this._protocol) + "//" +
            (overrides.hostname !== undefined ? overrides.hostname : this._hostname) + ":" +
            (overrides.port !== undefined ? overrides.port : this._port) + "/" +
            (overrides.pathname !== undefined ? overrides.pathname : this._pathname);
    };
    return ESPUrl;
}());
function ESPMappings(mappings) {
    this._mappings = mappings;
    this._reverseMappings = {};
    for (var resultName in this._mappings) {
        this._reverseMappings[resultName] = {};
        for (var key in this._mappings[resultName]) {
            this._reverseMappings[resultName][this._mappings[resultName][key]] = key;
        }
    }
}
ESPMappings.prototype.contains = function (resultName, origField) {
    return Utility.exists(resultName + "." + origField, this._mappings);
};
ESPMappings.prototype.mapResult = function (response, resultName) {
    var mapping = this._mappings[resultName];
    if (mapping) {
        response[resultName] = response[resultName].map(function (item) {
            var row = [];
            if (mapping.x && mapping.x instanceof Array) {
                //  LINE Mapping  ---
                row = [];
                for (var i = 0; i < mapping.x.length; ++i) {
                    row.push(item[mapping.y[i]]);
                }
            }
            else {
                //  Regular Mapping  ---
                for (var key in mapping) {
                    if (mapping[key] === "label") {
                        row[0] = item[key];
                    }
                    else if (mapping[key] === "weight") {
                        row[1] = item[key];
                    }
                }
            }
            return row;
        }, this);
    }
};
ESPMappings.prototype.mapResponse = function (response) {
    for (var key in response) {
        this.mapResult(response, key);
    }
};
var serialize = function (obj) {
    var str = [];
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            var val = obj[key];
            if (val !== undefined && val !== null) {
                str.push(encodeURIComponent(key) + "=" + encodeURIComponent(val));
            }
        }
    }
    return str.join("&");
};
var jsonp = function (url, request, timeout) {
    return new Promise(function (resolve, reject) {
        var respondedTimeout = timeout * 1000;
        var respondedTick = 5000;
        var callbackName = "jsonp_callback_" + Math.round(Math.random() * 999999);
        window[callbackName] = function (response) {
            respondedTimeout = 0;
            doCallback();
            resolve(response);
        };
        var script = document.createElement("script");
        script.src = url + (url.indexOf("?") >= 0 ? "&" : "?") + "jsonp=" + callbackName + "&" + serialize(request);
        document.body.appendChild(script);
        var progress = setInterval(function () {
            if (respondedTimeout <= 0) {
                clearInterval(progress);
            }
            else {
                respondedTimeout -= respondedTick;
                if (respondedTimeout <= 0) {
                    clearInterval(progress);
                    console.log("Request timeout:  " + script.src);
                    doCallback();
                    reject(Error("Request timeout:  " + script.src));
                }
                else {
                    console.log("Request pending (" + respondedTimeout / 1000 + " sec):  " + script.src);
                }
            }
        }, respondedTick);
        function doCallback() {
            delete window[callbackName];
            document.body.removeChild(script);
        }
    });
};
var Comms = /** @class */ (function (_super) {
    __extends(Comms, _super);
    function Comms() {
        var _this = _super.call(this) || this;
        _this._proxyMappings = {};
        _this._mappings = new ESPMappings({});
        _this._timeout = TIMEOUT_DEFAULT;
        _this._hipieResults = {};
        return _this;
    }
    Comms.prototype.hipieResults = function (_) {
        if (!arguments.length)
            return this._hipieResults;
        this._hipieResultsLength = 0;
        this._hipieResults = {};
        var context = this;
        _.forEach(function (item) {
            context._hipieResultsLength++;
            context._hipieResults[item.id] = item;
        });
        return this;
    };
    Comms.prototype.jsonp = function (url, request) {
        for (var key in this._proxyMappings) {
            var newUrlParts = url.split(key);
            var newUrl = newUrlParts[0];
            if (newUrlParts.length > 1) {
                var espUrl = new ESPUrl()
                    .url(url);
                url = newUrl + this._proxyMappings[key];
                request.IP = espUrl.hostname();
                request.PORT = espUrl.port();
                if (newUrlParts.length > 0) {
                    request.PATH = newUrlParts[1];
                }
                break;
            }
        }
        return jsonp(url, request, this.timeout());
    };
    Comms.prototype.ajax = function (method, url, request) {
        return new Promise(function (resolve, reject) {
            var uri = url;
            if (method === "GET" && request) {
                uri += "?" + serialize(request);
            }
            var xhr = new XMLHttpRequest();
            xhr.onload = function (e) {
                if (this.status >= 200 && this.status < 300) {
                    resolve(JSON.parse(this.response));
                }
                else {
                    reject(Error(this.statusText));
                }
            };
            xhr.onerror = function () {
                reject(Error(this.statusText));
            };
            xhr.open(method, uri);
            xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            if (method === "GET") {
                xhr.send();
            }
            else {
                xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                xhr.send(serialize(request));
            }
        });
    };
    Comms.prototype.get = function (url, request) {
        return this.ajax("GET", url, request);
    };
    Comms.prototype.post = function (url, request) {
        return this.ajax("POST", url, request);
    };
    Comms.prototype.mappings = function (_) {
        if (!arguments.length)
            return this._mappings;
        this._mappings = new ESPMappings(_);
        return this;
    };
    Comms.prototype.proxyMappings = function (_) {
        if (!arguments.length)
            return this._proxyMappings;
        this._proxyMappings = _;
        return this;
    };
    Comms.prototype.timeout = function (_) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = _ || TIMEOUT_DEFAULT;
        return this;
    };
    return Comms;
}(ESPUrl));
var Basic = /** @class */ (function (_super) {
    __extends(Basic, _super);
    function Basic() {
        return _super.call(this) || this;
    }
    Basic.prototype.cacheCalls = function (_) {
        if (!arguments.length)
            return this._cacheCalls;
        this._cacheCalls = _;
        return this;
    };
    Basic.prototype.call = function (request, callback) {
        var url = this._url + (this._url.indexOf("?") >= 0 ? "&" : "?") + serialize(request);
        if (this._cacheCalls) {
            var context_1 = this;
            return new Promise(function (resolve, reject) {
                var response = JSON.parse(localStorage.getItem("hpcc.viz." + url));
                if (!response) {
                    throw Error("not cached");
                }
                if (callback) {
                    console.log("Deprecated:  callback, use promise (Basic.prototype.call)");
                    callback(response);
                }
                resolve(response);
            }).catch(function (response) {
                return context_1.get(url).then(function (response2) {
                    localStorage.setItem("hpcc.viz." + url, JSON.stringify(response2));
                    if (callback) {
                        console.log("Deprecated:  callback, use promise (Basic.prototype.call)");
                        callback(response2);
                    }
                    return response2;
                });
            });
        }
        else {
            localStorage.removeItem("hpcc.viz." + url);
            return this.get(url).then(function (response) {
                if (callback) {
                    console.log("Deprecated:  callback, use promise (Basic.prototype.call)");
                    callback(response);
                }
                return response;
            });
        }
    };
    return Basic;
}(Comms));
function locateRoxieResponse(response) {
    // v5 and v6 compatible ---
    for (var key in response) {
        if (response[key].Row && response[key].Row instanceof Array) {
            return response;
        }
        var retVal = void 0;
        if (typeof (response[key]) !== "string") {
            retVal = locateRoxieResponse(response[key]);
        }
        if (retVal) {
            return retVal;
        }
    }
    return null;
}
function locateRoxieException(response) {
    for (var key in response) {
        if (response[key].Exception && response[key].Exception instanceof Array) {
            return response[key];
        }
        var retVal = locateRoxieException(response[key]);
        if (retVal) {
            return retVal;
        }
    }
    return null;
}
var WsECL = /** @class */ (function (_super) {
    __extends(WsECL, _super);
    function WsECL() {
        var _this = _super.call(this) || this;
        _this._port = "8002";
        _this._target = "";
        _this._query = "";
        return _this;
    }
    WsECL.prototype.url = function (_) {
        var retVal = _super.prototype.url.apply(this, arguments);
        if (arguments.length) {
            //  http://localhost:8010/esp/files/stub.htm?QuerySetId=roxie&Id=stock.3&Widget=QuerySetDetailsWidget
            this._port = this._port === "8010" ? "8002" : this._port; //  Need a better way  ---
            for (var key in this._params) {
                switch (key) {
                    case "QuerySetId":
                        this.target(this._params[key]);
                        break;
                    case "Id":
                        this.query(this._params[key]);
                        break;
                }
            }
            var pathParts = void 0;
            var queryParts = void 0;
            if (!this._target || !this._query) {
                // http://localhost:8002/WsEcl/forms/default/query/roxie/wecare
                pathParts = this._pathname.split("/query/");
                if (pathParts.length >= 2) {
                    queryParts = pathParts[1].split("/");
                    if (queryParts.length >= 2) {
                        this.target(queryParts[0]);
                        this.query(queryParts[1]);
                    }
                }
            }
        }
        return retVal;
    };
    WsECL.prototype.target = function (_) {
        if (!arguments.length)
            return this._target;
        this._target = _;
        return this;
    };
    WsECL.prototype.query = function (_) {
        if (!arguments.length)
            return this._query;
        this._query = _;
        return this;
    };
    WsECL.prototype.constructUrl = function () {
        return Comms.prototype.getUrl.call(this, {
            pathname: "WsEcl/submit/query/" + this._target + "/" + this._query + "/json"
        });
    };
    WsECL.prototype.call = function (target, request, callback) {
        target = target || {};
        target.target = target.target || this._target;
        target.query = target.query || this._query;
        var context = this;
        var url = this.getUrl({
            pathname: "WsEcl/submit/query/" + target.target + "/" + target.query + "/json"
        });
        return this.jsonp(url, request).then(function (response) {
            var _response = locateRoxieResponse(response);
            if (!_response) {
                _response = locateRoxieException(response);
            }
            response = _response;
            // Check for exceptions
            if (response.Exception) {
                throw Error(response.Exception.reduce(function (previousValue, exception, index, array) {
                    if (previousValue.length) {
                        previousValue += "\n";
                    }
                    return previousValue + exception.Source + " " + exception.Code + ":  " + exception.Message;
                }, ""));
            }
            // Remove "response.result.Row"
            for (var key in response) {
                if (response[key].Row) {
                    response[key] = response[key].Row.map(espRowFix);
                }
            }
            context._mappings.mapResponse(response);
            if (callback) {
                console.log("Deprecated:  callback, use promise (WsECL.prototype.call)");
                callback(response);
            }
            return response;
        });
    };
    WsECL.prototype.send = function (request, callback) {
        return this.call({ target: this._target, query: this._query }, request, callback);
    };
    return WsECL;
}(Comms));
var WsWorkunits = /** @class */ (function (_super) {
    __extends(WsWorkunits, _super);
    function WsWorkunits() {
        var _this = _super.call(this) || this;
        _this._wuid = "";
        _this._jobname = "";
        _this._sequence = null;
        _this._resultName = null;
        _this._fetchResultNamesPromise = null;
        _this._fetchResultPromise = {};
        _this._resultNameCache = {};
        _this._resultNameCacheCount = 0;
        _this._port = "8010";
        return _this;
    }
    WsWorkunits.prototype.url = function (_) {
        var retVal = Comms.prototype.url.apply(this, arguments);
        if (arguments.length) {
            //  http://localhost:8010/WsWorkunit/WuResult?Wuid=xxx&ResultName=yyy
            for (var key in this._params) {
                switch (key) {
                    case "Wuid":
                        this.wuid(this._params[key]);
                        break;
                    case "ResultName":
                        this.resultName(this._params[key]);
                        break;
                    case "Sequence":
                        this.sequence(this._params[key]);
                        break;
                }
            }
            if (!this._wuid) {
                //  http://localhost:8010/WsWorkunits/res/W20140922-213329/c:/temp/index.html
                var urlParts = this._url.split("/res/");
                if (urlParts.length >= 2) {
                    var urlParts2 = urlParts[1].split("/");
                    this.wuid(urlParts2[0]);
                }
            }
        }
        return retVal;
    };
    WsWorkunits.prototype.wuid = function (_) {
        if (!arguments.length)
            return this._wuid;
        this._wuid = _;
        return this;
    };
    WsWorkunits.prototype.jobname = function (_) {
        if (!arguments.length)
            return this._jobname;
        this._jobname = _;
        return this;
    };
    WsWorkunits.prototype.sequence = function (_) {
        if (!arguments.length)
            return this._sequence;
        this._sequence = _;
        return this;
    };
    WsWorkunits.prototype.resultName = function (_) {
        if (!arguments.length)
            return this._resultName;
        this._resultName = _;
        return this;
    };
    WsWorkunits.prototype.appendParam = function (label, value, params) {
        if (value) {
            if (params) {
                params += "&";
            }
            return params + label + "=" + value;
        }
        return params;
    };
    WsWorkunits.prototype.constructUrl = function () {
        var url = Comms.prototype.getUrl.call(this, {
            pathname: "WsWorkunits/res/" + this._wuid + "/"
        });
        var params = "";
        params = this.appendParam("ResultName", this._resultName, params);
        return url + (params ? "?" + params : "");
    };
    WsWorkunits.prototype._fetchResult = function (target, callback, skipMapping) {
        target = target || {};
        if (!this._fetchResultPromise[target.resultname]) {
            target._start = target._start || 0;
            target._count = target._count || -1;
            var url = this.getUrl({
                pathname: "WsWorkunits/WUResult.json"
            });
            var request = {
                Wuid: target.wuid,
                ResultName: target.resultname,
                SuppressXmlSchema: true,
                Start: target._start,
                Count: target._count
            };
            this._resultNameCache[target.resultname] = {};
            var context_2 = this;
            this._fetchResultPromise[target.resultname] = this.jsonp(url, request).then(function (response) {
                // Remove "xxxResponse.Result"
                for (var key in response) {
                    if (!response[key].Result) {
                        throw new Error("No result found.");
                    }
                    context_2._total = response[key].Total;
                    response = response[key].Result;
                    for (var responseKey in response) {
                        response = response[responseKey].Row.map(espRowFix);
                        break;
                    }
                    break;
                }
                context_2._resultNameCache[target.resultname] = response;
                if (!skipMapping) {
                    context_2._mappings.mapResult(context_2._resultNameCache, target.resultname);
                }
                if (callback) {
                    console.log("Deprecated:  callback, use promise (WsWorkunits.prototype._fetchResult)");
                    callback(context_2._resultNameCache[target.resultname]);
                }
                return context_2._resultNameCache[target.resultname];
            });
        }
        return this._fetchResultPromise[target.resultname];
    };
    WsWorkunits.prototype.fetchResult = function (target, callback, skipMapping) {
        if (target.wuid) {
            return this._fetchResult(target, callback, skipMapping);
        }
        else if (target.jobname) {
            var context_3 = this;
            return this.WUQuery(target, function (response) {
                target.wuid = response[0].Wuid;
                return context_3._fetchResult(target, callback, skipMapping);
            });
        }
    };
    WsWorkunits.prototype.WUQuery = function (_request, callback) {
        var url = this.getUrl({
            pathname: "WsWorkunits/WUQuery.json"
        });
        var request = {
            Jobname: _request.jobname,
            Count: 1
        };
        this._resultNameCache = {};
        this._resultNameCacheCount = 0;
        return this.jsonp(url, request).then(function (response) {
            if (!Utility.exists("WUQueryResponse.Workunits.ECLWorkunit", response)) {
                throw Error("No workunit found.");
            }
            response = response.WUQueryResponse.Workunits.ECLWorkunit;
            if (callback) {
                console.log("Deprecated:  callback, use promise (WsWorkunits.prototype.WUQuery)");
                callback(response);
            }
            return response;
        });
    };
    WsWorkunits.prototype.fetchResultNames = function (callback) {
        if (!this._fetchResultNamesPromise) {
            var url_1 = this.getUrl({
                pathname: "WsWorkunits/WUInfo.json"
            });
            var request_1 = {
                Wuid: this._wuid,
                TruncateEclTo64k: true,
                IncludeExceptions: false,
                IncludeGraphs: false,
                IncludeSourceFiles: false,
                IncludeResults: true,
                IncludeResultsViewNames: false,
                IncludeVariables: false,
                IncludeTimers: false,
                IncludeResourceURLs: false,
                IncludeDebugValues: false,
                IncludeApplicationValues: false,
                IncludeWorkflows: false,
                IncludeXmlSchemas: false,
                SuppressResultSchemas: true
            };
            this._resultNameCache = {};
            this._resultNameCacheCount = 0;
            var context_4 = this;
            this._fetchResultNamesPromise = this.jsonp(url_1, request_1).then(function (response) {
                if (Utility.exists("WUInfoResponse.Workunit.Archived", response) && response.WUInfoResponse.Workunit.Archived) {
                    console.log("WU is archived:  " + url_1 + " " + JSON.stringify(request_1));
                }
                if (Utility.exists("WUInfoResponse.Workunit.Results.ECLResult", response)) {
                    response.WUInfoResponse.Workunit.Results.ECLResult.map(function (item) {
                        context_4._resultNameCache[item.Name] = [];
                        ++context_4._resultNameCacheCount;
                    });
                }
                if (callback) {
                    console.log("Deprecated:  callback, use promise (WsWorkunits.prototype.fetchResultNames)");
                    callback(context_4._resultNameCache);
                }
                return context_4._resultNameCache;
            });
        }
        return this._fetchResultNamesPromise;
    };
    WsWorkunits.prototype.fetchResults = function (callback, skipMapping) {
        var context = this;
        return this.fetchResultNames().then(function (response) {
            var fetchArray = [];
            for (var key in context._resultNameCache) {
                fetchArray.push(context.fetchResult({ wuid: context._wuid, resultname: key }, null, skipMapping));
            }
            return Promise.all(fetchArray).then(function (responseArray) {
                if (callback) {
                    console.log("Deprecated:  callback, use promise (WsWorkunits.prototype.fetchResults)");
                    callback(context._resultNameCache);
                }
                return context._resultNameCache;
            });
        });
    };
    WsWorkunits.prototype.postFilter = function (request, response) {
        var retVal = {};
        for (var key in response) {
            retVal[key] = response[key].filter(function (row, idx) {
                for (var request_key in request) {
                    // tslint:disable-next-line:triple-equals
                    if (row[request_key] !== undefined && request[request_key] !== undefined && row[request_key] != request[request_key]) {
                        return false;
                    }
                }
                return true;
            });
        }
        this._mappings.mapResponse(retVal);
        return retVal;
    };
    WsWorkunits.prototype.send = function (request, callback) {
        var context = this;
        if (!this._resultNameCacheCount) {
            this.fetchResults(function (response) {
                callback(context.postFilter(request, response));
            }, true);
        }
        else {
            callback(context.postFilter(request, this._resultNameCache));
        }
    };
    return WsWorkunits;
}(Comms));
function WsWorkunits_GetStats() {
    Comms.call(this);
    this._port = "8010";
    this._wuid = null;
}
WsWorkunits_GetStats.prototype = Object.create(Comms.prototype);
WsWorkunits_GetStats.prototype.url = function (_) {
    var retVal = Comms.prototype.url.apply(this, arguments);
    if (arguments.length) {
        //  http://localhost:8010/WsWorkunits/WUGetStats?WUID="xxx"
        for (var key in this._params) {
            switch (key) {
                case "WUID":
                    this.wuid(this._params[key]);
                    break;
            }
        }
    }
    return retVal;
};
WsWorkunits_GetStats.prototype.wuid = function (_) {
    if (!arguments.length)
        return this._wuid;
    this._wuid = _;
    return this;
};
WsWorkunits_GetStats.prototype.constructUrl = function () {
    return Comms.prototype.getUrl.call(this, {
        pathname: "WsWorkunits/WUGetStats?WUID=" + this._wuid
    });
};
WsWorkunits_GetStats.prototype.send = function (request, callback) {
    var url = this.getUrl({
        pathname: "WsWorkunits/WUGetStats.json?WUID=" + this._wuid
    });
    return this.jsonp(url, request).then(function (response) {
        if (Utility.exists("WUGetStatsResponse.Statistics.WUStatisticItem", response)) {
            if (callback) {
                console.log("Deprecated:  callback, use promise (WsWorkunits_GetStats.prototype.send)");
                callback(response.WUGetStatsResponse.Statistics.WUStatisticItem);
            }
            return response.WUGetStatsResponse.Statistics.WUStatisticItem;
        }
        else {
            if (callback) {
                console.log("Deprecated:  callback, use promise (WsWorkunits_GetStats.prototype.send)");
                callback([]);
            }
            return [];
        }
    });
};
//  HIPIERoxie  ---
function HIPIERoxie() {
    Comms.call(this);
}
HIPIERoxie.prototype = Object.create(Comms.prototype);
HIPIERoxie.prototype.fetchResults = function (request, callback) {
    var url = this.getUrl({});
    this._resultNameCache = {};
    this._resultNameCacheCount = 0;
    var context = this;
    return this.jsonp(url, request).then(function (response) {
        var _response = locateRoxieResponse(response);
        if (!_response) {
            _response = locateRoxieException(response);
        }
        response = _response;
        // Check for exceptions
        if (response.Exception) {
            throw Error(response.Exception.reduce(function (previousValue, exception, index, array) {
                if (previousValue.length) {
                    previousValue += "\n";
                }
                return previousValue + exception.Source + " " + exception.Code + ":  " + exception.Message;
            }, ""));
        }
        // Remove "response.result.Row"
        for (var key in response) {
            if (response[key].Row) {
                context._resultNameCache[key] = response[key].Row.map(espRowFix);
                ++context._resultNameCacheCount;
            }
        }
        if (callback) {
            console.log("Deprecated:  callback, use promise (HIPIERoxie.prototype.fetchResults)");
            callback(context._resultNameCache);
        }
        return context._resultNameCache;
    });
};
HIPIERoxie.prototype.fetchResult = function (name, callback) {
    var context = this;
    return new Promise(function (resolve, reject) {
        if (callback) {
            console.log("Deprecated:  callback, use promise (HIPIERoxie.prototype.fetchResult)");
            callback(context._resultNameCache[name]);
        }
        resolve(context._resultNameCache[name]);
    });
};
HIPIERoxie.prototype.call = function (request, callback) {
    var context = this;
    return this.fetchResults(request, callback).then(function (response) {
        var retVal = {};
        for (var hipieKey in context._hipieResults) {
            var item = context._hipieResults[hipieKey];
            retVal[item.id] = response[item.from];
        }
        return retVal;
    });
};
//  HIPIEWorkunit  ---
function HIPIEWorkunit() {
    WsWorkunits.call(this);
}
HIPIEWorkunit.prototype = Object.create(WsWorkunits.prototype);
HIPIEWorkunit.prototype.fetchResults = function (callback) {
    var context = this;
    return WsWorkunits.prototype.fetchResultNames.call(this).then(function (response) {
        var fetchArray = [];
        for (var key in context._hipieResults) {
            var item = context._hipieResults[key];
            fetchArray.push(context.fetchResult(item.from));
        }
        return Promise.all(fetchArray).then(function (response2) {
            if (callback) {
                console.log("Deprecated:  callback, use promise (HIPIEWorkunit.prototype.fetchResults)");
                callback(context._resultNameCache);
            }
            return context._resultNameCache;
        });
    });
};
HIPIEWorkunit.prototype.fetchResult = function (name, callback) {
    return WsWorkunits.prototype.fetchResult.call(this, { wuid: this._wuid, resultname: name }).then(function (response) {
        if (callback) {
            console.log("Deprecated:  callback, use promise (HIPIEWorkunit.prototype.fetchResult)");
            callback(response);
        }
        return response;
    });
};
HIPIEWorkunit.prototype.call = function (request, callback) {
    var context = this;
    if (request.refresh || !this._resultNameCache || !this._resultNameCacheCount) {
        return this.fetchResults(callback).then(function (response) {
            return filterResults(request);
        });
    }
    else {
        return new Promise(function (resolve, reject) {
            resolve(filterResults(request));
        });
    }
    function filterResults(request2) {
        var changedFilter = {};
        for (var key in request2) {
            if (request2[key + "_changed"] !== undefined) {
                changedFilter[key] = {
                    value: request2[key]
                };
            }
        }
        var retVal = {};
        var _loop_1 = function (hipieKey) {
            var hipieResult = context._hipieResults[hipieKey];
            var outputFilter = {};
            for (var i = 0; i < hipieResult.filters.length; ++i) {
                var filter = hipieResult.filters[i];
                if (!filter.isRange()) {
                    outputFilter[filter.fieldid] = changedFilter[filter.fieldid] || { value: undefined };
                    outputFilter[filter.fieldid].filter = filter;
                }
            }
            retVal[hipieResult.id] = context._resultNameCache[hipieResult.from].filter(function (row) {
                for (var key2 in outputFilter) {
                    if (!outputFilter[key2].filter.matches(row, outputFilter[key2].value)) {
                        return false;
                    }
                }
                return true;
            });
        };
        for (var hipieKey in context._hipieResults) {
            _loop_1(hipieKey);
        }
        return retVal;
    }
};
//  HIPIEDatabomb  ---
function HIPIEDatabomb() {
    HIPIEWorkunit.call(this);
}
HIPIEDatabomb.prototype = Object.create(HIPIEWorkunit.prototype);
HIPIEDatabomb.prototype.databomb = function (_) {
    if (!arguments.length)
        return this._databomb;
    this._databomb = _;
    return this;
};
HIPIEDatabomb.prototype.databombOutput = function (from, id) {
    if (!arguments.length)
        return undefined;
    this._resultNameCacheCount++;
    if (this._databomb instanceof Array) {
        this._resultNameCache[from] = this._databomb.map(espRowFix);
    }
    else {
        this._resultNameCache[from] = this._databomb[from].map(espRowFix);
    }
    return this;
};
HIPIEDatabomb.prototype.fetchResults = function (callback) {
    var context = this;
    return new Promise(function (resolve, reject) {
        if (callback) {
            console.log("Deprecated:  callback, use promise (HIPIEDatabomb.prototype.fetchResults)");
            callback(context._resultNameCache);
        }
        resolve(context._resultNameCache);
    });
};
function createESPConnection(url) {
    url = url || document.URL;
    var testURL = new ESPUrl()
        .url(url);
    if (testURL.isWsWorkunits_GetStats()) {
        return new WsWorkunits_GetStats()
            .url(url);
    }
    if (testURL.isWsWorkunits()) {
        return new WsWorkunits()
            .url(url);
    }
    if (testURL.isWsEcl()) {
        return new WsECL()
            .url(url);
    }
    return null;
}
function hookJsonp(func) {
    jsonp = func;
}

var Comms$1 = /*#__PURE__*/Object.freeze({
    ESPUrl: ESPUrl,
    ESPMappings: ESPMappings,
    Comms: Comms,
    Basic: Basic,
    WsECL: WsECL,
    WsWorkunits: WsWorkunits,
    createESPConnection: createESPConnection,
    hookJsonp: hookJsonp,
    HIPIEWorkunit: HIPIEWorkunit,
    HIPIERoxie: HIPIERoxie,
    HIPIEDatabomb: HIPIEDatabomb
});

function nestedRowFix(row) {
    if (row.Row && row.Row instanceof Array) {
        return row.Row.map(nestedRowFix);
    }
    else if (row instanceof Object) {
        for (var key in row) {
            row[key] = nestedRowFix(row[key]);
        }
    }
    return row;
}
//  Basic Comms  ---
var enableBasicCommsCache = false;
var basicCommsCache = {};
function BasicComms() {
    Basic.call(this);
}
BasicComms.prototype = Object.create(Basic.prototype);
BasicComms.prototype.jsonp = function (url, request) {
    var requestStr = JSON.stringify(request);
    if (enableBasicCommsCache && basicCommsCache[url] && basicCommsCache[url][requestStr]) {
        return Promise.resolve(basicCommsCache[url][requestStr]);
    }
    return Basic.prototype.jsonp.apply(this, arguments).then(function (response) {
        if (enableBasicCommsCache) {
            if (!basicCommsCache[url]) {
                basicCommsCache[url] = {};
            }
            basicCommsCache[url][requestStr] = response;
        }
        return response;
    });
};
//  WsWorkunits  ---
function WsWorkunits$1(baseUrl) {
    BasicComms.call(this);
    this.url(baseUrl + "WsWorkunits/");
}
WsWorkunits$1.prototype = Object.create(BasicComms.prototype);
WsWorkunits$1.prototype.wuQuery = function (options) {
    var url = this.getUrl({
        pathname: "WsWorkunits/WUQuery.json"
    });
    var request = {
        Wuid: "",
        Type: "",
        Cluster: "",
        RoxieCluster: "",
        Owner: "",
        State: "",
        StartDate: "",
        EndDate: "",
        ECL: "",
        Jobname: "",
        LogicalFile: "",
        LogicalFileSearchType: "",
        /*
        ApplicationValues>
         ApplicationValue>
          Application: "",
          Name: "",
          Value: "",
         /ApplicationValue>
        /ApplicationValues>
        */
        After: "",
        Before: "",
        Count: "",
        PageSize: 100,
        PageStartFrom: 0,
        PageEndAt: "",
        LastNDays: "",
        Sortby: "",
        Descending: 0,
        CacheHint: ""
    };
    for (var key in options) {
        request[key] = options[key];
    }
    return this.jsonp(url, request).then(function (response) {
        if (response.WUQueryResponse && response.WUQueryResponse.Workunits) {
            return response.WUQueryResponse.Workunits.ECLWorkunit;
        }
        return [];
    });
};
//  Workunit  ---
function Workunit(baseUrl, wuid) {
    BasicComms.call(this);
    this.url(baseUrl + "WsWorkunits/");
    this._wuid = wuid;
}
Workunit.prototype = Object.create(BasicComms.prototype);
Workunit.prototype.wuInfo = function (options) {
    var url = this.getUrl({
        pathname: "WsWorkunits/WUInfo.json"
    });
    var request = {
        Wuid: this._wuid,
        TruncateEclTo64k: true,
        IncludeExceptions: false,
        IncludeGraphs: false,
        IncludeSourceFiles: false,
        IncludeResults: false,
        IncludeResultsViewNames: false,
        IncludeVariables: false,
        IncludeTimers: false,
        IncludeResourceURLs: false,
        IncludeDebugValues: false,
        IncludeApplicationValues: false,
        IncludeWorkflows: false,
        IncludeXmlSchemas: false,
        SuppressResultSchemas: true
    };
    for (var key in options) {
        request[key] = options[key];
    }
    return this.jsonp(url, request).then(function (response) {
        if (enableBasicCommsCache) {
            var retVal = { WUInfoResponse: { Workunit: {} } };
            for (var key in options) {
                var includeKey = key.substring(7);
                retVal.WUInfoResponse.Workunit[includeKey] = response.WUInfoResponse.Workunit[includeKey];
            }
            basicCommsCache[url][JSON.stringify(request)] = retVal;
        }
        return response;
    });
};
Workunit.prototype.wuUpdate = function (options) {
    var url = this.getUrl({
        pathname: "WsWorkunits/WUUpdate.json"
    });
    var request = {
        Wuid: this._wuid
    };
    for (var key in options) {
        request[key] = options[key];
    }
    return this.post(url, request);
};
Workunit.prototype.appData = function (appID, key, _) {
    if (arguments.length === 2) {
        return this.wuInfo({
            IncludeApplicationValues: true
        }).then(function (response) {
            var persistString;
            if (response.WUInfoResponse && response.WUInfoResponse.Workunit && response.WUInfoResponse.Workunit.ApplicationValues && response.WUInfoResponse.Workunit.ApplicationValues.ApplicationValue) {
                response.WUInfoResponse.Workunit.ApplicationValues.ApplicationValue.filter(function (row) {
                    return row.Application === appID && row.Name === key;
                }).forEach(function (row) {
                    persistString = row.Value;
                });
            }
            return persistString;
        });
    }
    else if (arguments.length === 3) {
        return this.wuUpdate({
            "ApplicationValues.ApplicationValue.0.Application": appID,
            "ApplicationValues.ApplicationValue.0.Name": key,
            "ApplicationValues.ApplicationValue.0.Value": _,
            "ApplicationValues.ApplicationValue.itemcount": 1
        });
    }
};
Workunit.prototype.results = function () {
    var context = this;
    return this.wuInfo({
        IncludeResults: true
    }).then(function (response) {
        var retVal = [];
        if (Utility.exists("WUInfoResponse.Workunit.Results.ECLResult", response)) {
            retVal = response.WUInfoResponse.Workunit.Results.ECLResult.map(function (result) {
                return new WUResult(context.getUrl({ pathname: "WsWorkunits/" }), context._wuid, result.Name);
            });
        }
        return retVal;
    });
};
Workunit.prototype.result = function (dataSource, resultName) {
    dataSource = dataSource || this._wuid;
    return createResult(dataSource, resultName);
};
//  Workunit Result  ---
function WUResult(baseUrl, wuid, name) {
    BasicComms.call(this);
    this.url(baseUrl + "WUResult.json");
    this._wuid = wuid;
    this._name = name;
    this._xmlSchema = null;
}
WUResult.prototype = Object.create(BasicComms.prototype);
WUResult.prototype.wuid = function (_) {
    if (!arguments.length)
        return this._wuid;
    this._wuid = _;
    return this;
};
WUResult.prototype.name = function (_) {
    if (!arguments.length)
        return this._name;
    this._name = _;
    return this;
};
WUResult.prototype.query = function (options, filter) {
    options = options || {};
    filter = filter || {};
    var request = {
        Wuid: this._wuid,
        ResultName: this._name,
        SuppressXmlSchema: true,
        Start: 0,
        Count: -1
    };
    for (var key in options) {
        request[key] = options[key];
    }
    var filterIdx = 0;
    for (var fKey in filter) {
        request["FilterBy.NamedValue." + filterIdx + ".Name"] = fKey;
        request["FilterBy.NamedValue." + filterIdx + ".Value"] = filter[fKey];
        ++filterIdx;
    }
    if (filterIdx) {
        request["FilterBy.NamedValue.itemcount"] = filterIdx;
    }
    var context = this;
    return this.jsonp(this.url(), request).then(function (response) {
        if (response.WUResultResponse &&
            response.WUResultResponse.Result &&
            response.WUResultResponse.Result[context._name]) {
            if (enableBasicCommsCache) {
                basicCommsCache[context.url()][JSON.stringify(request)] = {
                    WUResultResponse: {
                        Result: response.WUResultResponse.Result
                    }
                };
            }
            context._xmlSchema = response.WUResultResponse.Result.XmlSchema;
            return nestedRowFix(response.WUResultResponse.Result[context._name]);
        }
        return [];
    });
};
//  Logical File  ---
function LogicalFile(baseUrl, logicalName) {
    BasicComms.call(this);
    this.url(baseUrl + "WUResult.json");
    this._logicalName = logicalName;
    this._xmlSchema = null;
}
LogicalFile.prototype = Object.create(BasicComms.prototype);
LogicalFile.prototype.query = function (options, filter) {
    options = options || {};
    filter = filter || {};
    var request = {
        Cluster: "hthor",
        LogicalName: this._logicalName,
        SuppressXmlSchema: this._xmlSchema !== null,
        Start: 0,
        Count: -1
    };
    for (var key in options) {
        request[key] = options[key];
    }
    var filterIdx = 0;
    for (var fKey in filter) {
        request["FilterBy.NamedValue." + filterIdx + ".Name"] = fKey;
        request["FilterBy.NamedValue." + filterIdx + ".Value"] = filter[fKey];
        ++filterIdx;
    }
    if (filterIdx) {
        request["FilterBy.NamedValue.itemcount"] = filterIdx;
    }
    var context = this;
    return this.jsonp(this.url(), request).then(function (response) {
        if (response.WUResultResponse &&
            response.WUResultResponse.Result &&
            response.WUResultResponse.Result.Row) {
            context._xmlSchema = response.WUResultResponse.Result.XmlSchema;
            return nestedRowFix(response.WUResultResponse.Result.Row);
        }
        return [];
    });
};
//  Roxie Query  ---
function RoxieQuery(baseUrl, resultName) {
    BasicComms.call(this);
    var urlParts = baseUrl.split("/");
    var queryName = urlParts.pop();
    if (queryName.toLowerCase() === "json") {
        queryName = urlParts.pop();
    }
    this._queryName = queryName;
    this._resultName = resultName;
    this.url(urlParts.join("/") + "/" + queryName + "/json");
}
RoxieQuery.prototype = Object.create(BasicComms.prototype);
function trimRight(str) {
    if (str && str.replace) {
        return str.replace(/ +$/, "");
    }
    return str;
}
function postFilter(results, filter) {
    return results.filter(function (row) {
        for (var key in filter) {
            if (row[key] !== undefined && trimRight(filter[key]) !== trimRight(row[key])) {
                return false;
            }
        }
        return true;
    });
}
function locateRoxieResponse$1(response) {
    // v5 and v6 compatible ---
    for (var key in response) {
        if (response[key].Row && response[key].Row instanceof Array) {
            return response;
        }
        var retVal = locateRoxieResponse$1(response[key]);
        if (retVal) {
            return retVal;
        }
    }
    return null;
}
RoxieQuery.prototype.query = function (options, filter) {
    options = options || {};
    filter = filter || {};
    var request = {};
    for (var key in options) {
        request[key] = options[key];
    }
    for (var fKey in filter) {
        request[fKey] = filter[fKey];
    }
    var context = this;
    return this.jsonp(this.url(), request).then(function (response) {
        response = locateRoxieResponse$1(response);
        if (response) {
            if (context._resultName) {
                if (response && response[context._resultName] && response[context._resultName].Row) {
                    return nestedRowFix(postFilter(response[context._resultName].Row, filter));
                }
            }
            else {
                for (var key in response) {
                    if (response[key].Row) {
                        return nestedRowFix(postFilter(response[key].Row, filter));
                    }
                }
            }
        }
        return [];
    });
};
function createResult(_espUrl, dataSource, resultName) {
    var espUrl = new ESPUrl()
        .url(_espUrl);
    if (dataSource.indexOf("http") === 0) {
        return new RoxieQuery(dataSource, resultName);
    }
    else if (dataSource.indexOf("~") === 0 || dataSource.indexOf("::") >= 0) {
        return new LogicalFile(espUrl.getUrl({ pathname: "WsWorkunits/" }), dataSource);
    }
    else if (dataSource) {
        return new WUResult(espUrl.getUrl({ pathname: "WsWorkunits/" }), dataSource, resultName);
    }
    return null;
}
function enableCache(_) {
    if (!arguments.length)
        return enableBasicCommsCache;
    enableBasicCommsCache = _;
    if (!_) {
        basicCommsCache = {};
    }
}
function cache(_) {
    if (!arguments.length)
        return basicCommsCache;
    basicCommsCache = _;
}
function createConnection(url) {
    url = url || document.URL;
    var testURL = new ESPUrl()
        .url(url);
    if (testURL.isWsWorkunits()) {
        var espConnection = createESPConnection(url);
        if (espConnection instanceof WsWorkunits && espConnection.wuid()) {
            return new Workunit(espConnection.getUrl({ pathname: "" }), espConnection.wuid())
                .url(url);
        }
    }
    return null;
}
function flattenResult(result, mappings) {
    var retVal = {
        columns: [],
        data: []
    };
    if (result && result.length) {
        var colIdx_1 = {};
        if (mappings && mappings.length) {
            mappings.forEach(function (mapping) {
                colIdx_1[mapping.value.toLowerCase()] = retVal.columns.length;
                retVal.columns.push(mapping.key);
            });
        }
        else {
            for (var key in result[0]) {
                colIdx_1[key.toLowerCase()] = retVal.columns.length;
                retVal.columns.push(key);
            }
        }
        result.forEach(function (row, rowIdx) {
            var rowArr = [];
            for (var key in row) {
                if (colIdx_1[key.toLowerCase()] !== undefined) {
                    rowArr[colIdx_1[key.toLowerCase()]] = row[key];
                }
            }
            retVal.data.push(rowArr);
        });
    }
    return retVal;
}

var simpleheat_1 = createCommonjsModule(function (module) {

module.exports = simpleheat;

function simpleheat(canvas) {
    if (!(this instanceof simpleheat)) return new simpleheat(canvas);

    this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;

    this._ctx = canvas.getContext('2d');
    this._width = canvas.width;
    this._height = canvas.height;

    this._max = 1;
    this._data = [];
}

simpleheat.prototype = {

    defaultRadius: 25,

    defaultGradient: {
        0.4: 'blue',
        0.6: 'cyan',
        0.7: 'lime',
        0.8: 'yellow',
        1.0: 'red'
    },

    data: function (data) {
        this._data = data;
        return this;
    },

    max: function (max) {
        this._max = max;
        return this;
    },

    add: function (point) {
        this._data.push(point);
        return this;
    },

    clear: function () {
        this._data = [];
        return this;
    },

    radius: function (r, blur) {
        blur = blur === undefined ? 15 : blur;

        // create a grayscale blurred circle image that we'll use for drawing points
        var circle = this._circle = this._createCanvas(),
            ctx = circle.getContext('2d'),
            r2 = this._r = r + blur;

        circle.width = circle.height = r2 * 2;

        ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
        ctx.shadowBlur = blur;
        ctx.shadowColor = 'black';

        ctx.beginPath();
        ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();

        return this;
    },

    resize: function () {
        this._width = this._canvas.width;
        this._height = this._canvas.height;
    },

    gradient: function (grad) {
        // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one
        var canvas = this._createCanvas(),
            ctx = canvas.getContext('2d'),
            gradient = ctx.createLinearGradient(0, 0, 0, 256);

        canvas.width = 1;
        canvas.height = 256;

        for (var i in grad) {
            gradient.addColorStop(+i, grad[i]);
        }

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 1, 256);

        this._grad = ctx.getImageData(0, 0, 1, 256).data;

        return this;
    },

    draw: function (minOpacity) {
        if (!this._circle) this.radius(this.defaultRadius);
        if (!this._grad) this.gradient(this.defaultGradient);

        var ctx = this._ctx;

        ctx.clearRect(0, 0, this._width, this._height);

        // draw a grayscale heatmap by putting a blurred circle at each data point
        for (var i = 0, len = this._data.length, p; i < len; i++) {
            p = this._data[i];
            ctx.globalAlpha = Math.max(p[2] / this._max, minOpacity === undefined ? 0.05 : minOpacity);
            ctx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);
        }

        // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient
        var colored = ctx.getImageData(0, 0, this._width, this._height);
        this._colorize(colored.data, this._grad);
        ctx.putImageData(colored, 0, 0);

        return this;
    },

    _colorize: function (pixels, gradient) {
        for (var i = 0, len = pixels.length, j; i < len; i += 4) {
            j = pixels[i + 3] * 4; // get gradient color from opacity value

            if (j) {
                pixels[i] = gradient[j];
                pixels[i + 1] = gradient[j + 1];
                pixels[i + 2] = gradient[j + 2];
            }
        }
    },

    _createCanvas: function () {
        if (typeof document !== 'undefined') {
            return document.createElement('canvas');
        } else {
            // create a new canvas instance in node.js
            // the canvas class needs to have a default constructor without any parameter
            return new this._canvas.constructor();
        }
    }
};
});

var _simpleheat = /*#__PURE__*/Object.freeze({
    'default': simpleheat_1,
    __moduleExports: simpleheat_1
});

var simpleheat = window.simpleheat || (_simpleheat && simpleheat_1) || _simpleheat;
var HeatMap = /** @class */ (function (_super) {
    __extends(HeatMap, _super);
    function HeatMap() {
        return _super.call(this) || this;
    }
    HeatMap.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        // canvas size needs to be set before render
        this.resize(this._size);
        this._heat = simpleheat(domNode);
    };
    HeatMap.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        this._palette = this._palette.switch(this.paletteID());
        if (this.useClonedPalette()) {
            this._palette = this._palette.cloneNotExists(this.paletteID() + "_" + this.id());
        }
        if (this.topLeftX_exists() && this.topLeftY_exists() && this.bottomRightX_exists() && this.bottomRightY_exists()) {
            this._heat.data(this.skewedData());
        }
        else {
            this._heat.data(this.data());
        }
        if (this.radius()) {
            this._heat.radius(this.radius(), this.blur());
        }
        if (this.usePalette()) {
            var grad = {};
            for (var idx = 1; idx <= this.colorCount(); idx++) {
                var value = idx / this.colorCount();
                grad[value] = this._palette(idx, 1, this.colorCount());
            }
            this._heat.defaultGradient = grad;
            this._heat.gradient(grad);
        }
        else if (this.gradient()) {
            this._heat.defaultGradient = this.gradient();
            this._heat.gradient(this.gradient());
        }
        this._heat.draw();
    };
    HeatMap.prototype.exit = function (domNode, element) {
        delete this._heat;
        _super.prototype.exit.call(this, domNode, element);
    };
    HeatMap.prototype.resize = function (size) {
        var retVal = CanvasWidget.prototype.resize.apply(this, arguments);
        if (this._heat !== undefined) {
            this._heat.resize();
        }
        return retVal;
    };
    HeatMap.prototype.skewedData = function () {
        var context = this;
        var retArr = [];
        var arr = this.data();
        var box = this.size();
        var coordsWidth = this.bottomRightX() - this.topLeftX();
        var coordsHeight = this.bottomRightY() - this.topLeftY();
        var pixelValueX = coordsWidth / box.width;
        var pixelValueY = coordsHeight / box.height;
        arr.forEach(function (n) {
            var left = Math.abs(n[0] - context.topLeftX());
            var top = Math.abs(n[1] - context.topLeftY());
            var newX = left / pixelValueX;
            var newY = top / pixelValueY;
            retArr.push([newX, newY, n[2]]);
        });
        return retArr;
    };
    return HeatMap;
}(CanvasWidget));
HeatMap.prototype._class += " other_HeatMap";
HeatMap.prototype._palette = Palette.rainbow("default");
HeatMap.prototype.publish("radius", 15, "number", "Set point radius", null, { tags: ["Basic"] });
HeatMap.prototype.publish("blur", 15, "number", "Set point blur", null, { tags: ["Basic"] });
HeatMap.prototype.publish("max", 1, "number", "Set max data value", null, { tags: ["Basic"] });
HeatMap.prototype.publish("gradient", { 0.4: "blue", 0.6: "cyan", 0.7: "lime", 0.8: "yellow", 1.0: "red" }, "object", "Set gradient colors", null, { tags: ["Basic"] });
HeatMap.prototype.publish("usePalette", false, "boolean", "If true, uses paletteID and colorCount to determine gradient", null, { tags: ["Basic"] });
HeatMap.prototype.publish("colorCount", 10, "number", "Top left x-value", null, { tags: ["Basic"] });
HeatMap.prototype.publish("paletteID", "default", "set", "Color palette for this widget", HeatMap.prototype._palette.switch(), { tags: ["Basic"] });
HeatMap.prototype.publish("useClonedPalette", false, "boolean", "Enable or disable using a cloned palette", null, { tags: ["Intermediate", "Shared"] });
HeatMap.prototype.publish("topLeftX", null, "number", "Top left x-value", null, { tags: ["Basic"], optional: true });
HeatMap.prototype.publish("topLeftY", null, "number", "Top left y-value", null, { tags: ["Basic"], optional: true });
HeatMap.prototype.publish("bottomRightX", null, "number", "Bottom right x-value", null, { tags: ["Basic"], optional: true });
HeatMap.prototype.publish("bottomRightY", null, "number", "Bottom right y-value", null, { tags: ["Basic"], optional: true });

var HPCCBadge = /** @class */ (function (_super) {
    __extends(HPCCBadge, _super);
    function HPCCBadge() {
        return _super.call(this) || this;
    }
    HPCCBadge.prototype.testData = function (domNode, element) {
        return this;
    };
    HPCCBadge.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        this.root = element.append("g");
        this.logo = this.root.append("g");
        this.logo_accent = this.root.append("g");
        this.line = this.logo_accent.append("path")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .attr("fill", "#179BD7")
            .attr("d", "m 189.38849,364.55373 c 191.6,3.8 0,0 191.6,3.8 l 0.1,-4.2 c -191.7,0.4 0,0 -191.7,0.4 z");
        this.circle_accent = this.logo_accent.append("path")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .attr("fill", "#6E6E73")
            .attr("d", "M421.3,354.2c6.9,6.9,3.1,18.7-8.6,26.1c-11.8,7.4-26.3,6.9-32.1-0.6c-5.5-7.2-1.1-18.2,9.6-25C401,348,414.7,347.6,421.3,354.2z");
        this.logo_circles = this.logo.append("g");
        this.circle_1 = this.logo_circles.append("path")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .attr("fill", "#179BD7")
            .attr("d", "m 258.9815,363.84947 c 1.3,-3 1.5,-5.9 0.4,-8.1 -2.6,-5.4 -11.8,-5.1 -20.6,0.4 -3.5,2.2 -6.5,4.9 -8.7,7.8 -0.11933,0.35821 -0.39477,0.60735 -0.6,0.9 -2.9,4.1 -4.2,8.3 -3,11.6 2.1,6 11.4,6.3 20.9,0.4 5,-3.2 8.9,-7.3 11,-11.4 -0.59813,0.54778 0.47385,-1.28911 0.6,-1.6 z");
        this.circle_2 = this.logo_circles.append("path")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .attr("fill", "#179BD7")
            .attr("d", "M291.3,349.3c9.5-5.9,14.1-15,10.5-20c-3.5-4.8-13.3-4.2-22.1,1.3c-8.8,5.5-13.7,14.1-10.9,19.3C271.7,355.4,281.9,355.2,291.3,349.3z");
        this.circle_3 = this.logo_circles.append("path")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .attr("fill", "#179BD7")
            .attr("d", "M335.3,321.7c9.5-5.9,13.3-14.5,8.9-19c-4.3-4.3-14.8-3.2-23.6,2.3c-8.8,5.5-13.1,13.7-9.4,18.4C315,328.3,325.9,327.7,335.3,321.7z");
        this.circle_4 = this.logo_circles.append("path")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .attr("fill", "#179BD7")
            .attr("d", "M273.2,384c-3.2-6.5-13.5-6.7-23.2-0.7c-9.7,6-15.6,16.4-13.2,23.4c2.5,7.3,13.1,8.2,23.6,1.7 C270.8,401.9,276.5,390.8,273.2,384z");
        this.circle_5 = this.logo_circles.append("path")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .attr("fill", "#179BD7")
            .attr("d", "m 320.84499,363.83119 c 1,-3.4 0.8,-6.6 -1,-9.1 -4.2,-5.9 -15.3,-5.6 -25,0.5 -3.89999,2.4 -7.09999,5.5 -9.19999,8.7 -1.18854,2.2092 -0.0404,-0.09 -1.2,2.2 -2.2,4.1 -2.7,8.3 -0.9,11.5 3.6,6.7 15.09999,7 25.59999,0.5 5,-3.2 8.7,-7.2 10.7,-11.3 0.95557,-2.97582 0.0423,0.0306 1,-3 z");
        this.circle_6 = this.logo_circles.append("path")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .attr("fill", "#179BD7")
            .attr("d", "M330.4,348.2c4.6,6,17,5.8,27.5-0.8c10.5-6.6,14.3-16.5,8.9-22c-5.2-5.3-17.1-4.4-26.8,1.6C330.3,333.1,325.9,342.4,330.4,348.2z");
        this.circle_7 = this.logo_circles.append("path")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .attr("fill", "#179BD7")
            .attr("d", "M264.1,417.4c-10.8,6.7-17.2,19-14.2,27.8c3.2,9.2,15.4,11.1,27.2,3.7c11.8-7.4,17.8-20.6,13.6-29.2C286.6,411.6,274.8,410.7,264.1,417.4z");
        this.circle_8 = this.logo_circles.append("path")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .attr("fill", "#179BD7")
            .attr("d", "M314.2,386.1c-10.8,6.7-16.2,18.4-11.9,26.4c4.5,8.4,17.8,9.5,29.6,2.2c11.8-7.4,16.6-19.9,11.1-27.7C337.7,379.6,324.9,379.3,314.2,386.1z");
        //  Text  ---
        this.text = this.root.append("g");
        this.text_hpccsystems = this.text.append("path")
            .attr("fill", "#6E6E73")
            .attr("d", "M224.2,476.3c0.1-1.3,0.1-2.7,0.2-4.1c-0.3,0-0.5,0.1-0.8,0.1c-0.3,0-0.5,0-0.8,0c-0.3,0-0.5,0-0.8,0c-0.3,0-0.5-0.1-0.8-0.1c0.1,1.4,0.1,2.8,0.2,4.1c0.1,1.3,0.1,2.7,0.1,4.1v1.1c-1.1,0-2.3,0-3.3,0.1c-1.1,0-2.2,0-3.3,0c-1.1,0-2.3,0-3.3,0c-1.1,0-2.2,0-3.3-0.1v-1.1c0-1.4,0-2.8,0.1-4.1c0.1-1.3,0.1-2.7,0.2-4.1c-0.3,0-0.5,0.1-0.8,0.1c-0.3,0-0.5,0-0.8,0c-0.3,0-0.5,0-0.8,0c-0.3,0-0.5-0.1-0.8-0.1c0.1,1.4,0.1,2.8,0.2,4.1c0.1,1.3,0.1,2.7,0.1,4.1v5.5c0,1.4,0,2.8-0.1,4.1c-0.1,1.4-0.1,2.7-0.2,4c0.5,0,1-0.1,1.6-0.1c0.6,0,1.1,0,1.6,0.1c-0.1-1.3-0.1-2.7-0.2-4c-0.1-1.4-0.1-2.7-0.1-4.1v-2.9c1.1,0,2.3,0,3.3,0c1.1,0,2.2,0,3.3,0c1.1,0,2.3,0,3.3,0c1.1,0,2.2,0,3.3,0v2.9c0,1.4,0,2.8-0.1,4.1c-0.1,1.4-0.1,2.7-0.2,4c0.5,0,1-0.1,1.6-0.1c0.6,0,1.1,0,1.6,0.1c-0.1-1.3-0.1-2.7-0.2-4c-0.1-1.4-0.1-2.7-0.1-4.1v-5.5C224.1,479,224.1,477.7,224.2,476.3z M242.7,473.8c-0.4-0.4-0.9-0.7-1.4-0.9c-0.5-0.2-1-0.4-1.5-0.5c-0.5-0.1-1-0.2-1.5-0.2c-0.5,0-0.9,0-1.2,0c-0.2,0-0.5,0-0.9,0c-0.3,0-0.7,0-1.1,0c-0.4,0-0.7,0-1.1,0c-0.4,0-0.7,0-0.9,0c-0.5,0-1,0-1.5,0c-0.5,0-1-0.1-1.5-0.1c0.1,1.4,0.1,2.8,0.2,4.1c0.1,1.3,0.1,2.7,0.1,4.1v5.5c0,1.4,0,2.8-0.1,4.1c-0.1,1.4-0.1,2.7-0.2,4c0.5,0,1-0.1,1.6-0.1c0.6,0,1.1,0,1.6,0.1c-0.1-1.3-0.1-2.7-0.2-4c-0.1-1.4-0.1-2.7-0.1-4.1v-1.8c0.4,0,0.8,0.1,1.2,0.1c0.4,0,0.8,0,1.3,0c0.8,0,1.6-0.1,2.6-0.3c1-0.2,1.9-0.5,2.8-1c0.9-0.5,1.6-1.2,2.2-2c0.6-0.9,0.9-2,0.9-3.4c0-0.9-0.1-1.6-0.4-2.2C243.5,474.7,243.1,474.2,242.7,473.8z M240.6,480.4c-0.4,0.7-0.9,1.2-1.4,1.6c-0.6,0.4-1.2,0.7-1.9,0.8c-0.7,0.1-1.4,0.2-2,0.2c-0.8,0-1.5-0.1-2.3-0.3v-9.5h2.9c0.8,0,1.6,0.1,2.2,0.2c0.7,0.1,1.2,0.3,1.7,0.7c0.5,0.3,0.8,0.8,1.1,1.3c0.3,0.6,0.4,1.3,0.4,2.2C241.2,478.8,241,479.7,240.6,480.4z M251.9,475.4c0.8-0.8,1.7-1.5,2.8-1.9c1.1-0.4,2.2-0.6,3.5-0.6c0.8,0,1.5,0.1,2.1,0.3c0.6,0.2,1.2,0.5,1.7,0.7c0.5,0.3,1,0.6,1.3,0.9c0.4,0.3,0.7,0.6,0.9,0.9l0.2-0.1c0.1-0.3,0.1-0.8,0.3-1.3c0.1-0.5,0.2-0.9,0.4-1.2c-0.9-0.4-1.9-0.7-3.1-1c-1.2-0.3-2.4-0.4-3.8-0.4c-1.8,0-3.4,0.3-4.8,0.8c-1.5,0.5-2.7,1.3-3.8,2.2c-1.1,1-1.9,2.2-2.5,3.6c-0.6,1.4-0.9,3-0.9,4.8c0,1.8,0.3,3.4,0.9,4.8c0.6,1.4,1.4,2.6,2.4,3.6c1,1,2.3,1.7,3.7,2.2c1.4,0.5,3,0.7,4.7,0.7c0.8,0,1.5-0.1,2.3-0.2c0.7-0.1,1.4-0.3,2-0.4c0.6-0.2,1.1-0.3,1.5-0.5c0.4-0.2,0.7-0.4,0.9-0.6l0.3-1.9l-0.1-0.1c-0.3,0.2-0.7,0.5-1.1,0.8c-0.4,0.3-0.9,0.6-1.5,0.9c-0.5,0.3-1.1,0.5-1.8,0.7c-0.6,0.2-1.4,0.3-2.1,0.3c-1.3,0-2.4-0.2-3.5-0.6c-1.1-0.4-2-1-2.8-1.9c-0.8-0.8-1.4-1.9-1.9-3.2c-0.4-1.3-0.7-2.8-0.7-4.6c0-1.8,0.2-3.3,0.7-4.6 C250.5,477.3,251.1,476.3,251.9,475.4z M273.2,475.4c0.8-0.8,1.7-1.5,2.8-1.9c1.1-0.4,2.2-0.6,3.5-0.6c0.8,0,1.5,0.1,2.1,0.3c0.6,0.2,1.2,0.5,1.7,0.7c0.5,0.3,1,0.6,1.3,0.9c0.4,0.3,0.7,0.6,0.9,0.9l0.2-0.1c0.1-0.3,0.1-0.8,0.3-1.3c0.1-0.5,0.2-0.9,0.4-1.2c-0.9-0.4-1.9-0.7-3.1-1c-1.2-0.3-2.4-0.4-3.8-0.4c-1.8,0-3.4,0.3-4.8,0.8c-1.5,0.5-2.7,1.3-3.8,2.2c-1.1,1-1.9,2.2-2.5,3.6c-0.6,1.4-0.9,3-0.9,4.8c0,1.8,0.3,3.4,0.9,4.8c0.6,1.4,1.4,2.6,2.4,3.6c1,1,2.3,1.7,3.7,2.2c1.4,0.5,3,0.7,4.7,0.7c0.8,0,1.5-0.1,2.3-0.2c0.7-0.1,1.4-0.3,2-0.4c0.6-0.2,1.1-0.3,1.5-0.5c0.4-0.2,0.7-0.4,0.9-0.6l0.3-1.9l-0.1-0.1c-0.3,0.2-0.7,0.5-1.1,0.8c-0.4,0.3-0.9,0.6-1.5,0.9c-0.5,0.3-1.1,0.5-1.8,0.7c-0.6,0.2-1.4,0.3-2.1,0.3c-1.3,0-2.4-0.2-3.5-0.6c-1.1-0.4-2-1-2.8-1.9c-0.8-0.8-1.4-1.9-1.9-3.2c-0.4-1.3-0.7-2.8-0.7-4.6c0-1.8,0.2-3.3,0.7-4.6 C271.8,477.3,272.4,476.3,273.2,475.4z M308.2,482.9c-0.7-0.4-1.5-0.8-2.4-1.1c-0.9-0.3-1.7-0.7-2.4-1.1c-0.7-0.4-1.4-0.9-1.9-1.5c-0.5-0.6-0.7-1.4-0.7-2.4c0-0.6,0.1-1.1,0.3-1.6c0.2-0.5,0.5-0.9,0.9-1.3c0.4-0.4,0.8-0.6,1.3-0.8c0.5-0.2,1-0.3,1.6-0.3c0.6,0,1.1,0.1,1.5,0.3c0.4,0.2,0.8,0.5,1.1,0.7c0.3,0.3,0.6,0.6,0.7,1c0.2,0.4,0.3,0.7,0.4,1h0.4c0.1-0.6,0.3-1.1,0.4-1.5c0.1-0.4,0.3-0.8,0.5-1.1c-0.6-0.5-1.3-0.9-2.1-1.1c-0.7-0.2-1.6-0.4-2.6-0.4c-1.1,0-2,0.1-2.9,0.4c-0.9,0.3-1.6,0.7-2.2,1.2c-0.6,0.5-1.1,1.2-1.4,1.9c-0.3,0.7-0.5,1.5-0.5,2.4c0,1.3,0.2,2.3,0.7,3c0.5,0.7,1.1,1.4,1.9,1.8c0.7,0.5,1.5,0.9,2.4,1.2c0.9,0.3,1.7,0.7,2.4,1.1c0.7,0.4,1.4,0.9,1.9,1.4c0.5,0.6,0.7,1.3,0.7,2.3c0,0.6-0.1,1.2-0.3,1.8c-0.2,0.6-0.5,1.1-0.9,1.5c-0.4,0.4-0.9,0.7-1.4,1c-0.6,0.2-1.2,0.4-1.9,0.4c-0.7,0-1.3-0.1-1.8-0.3c-0.6-0.2-1-0.5-1.5-0.8c-0.4-0.3-0.8-0.7-1.1-1.1c-0.3-0.4-0.5-0.8-0.7-1.2h-0.4c-0.1,0.6-0.1,1.1-0.2,1.5c-0.1,0.4-0.2,0.8-0.4,1.3c0.6,0.4,1.2,0.8,2.1,1.2c0.8,0.4,1.9,0.5,3.2,0.5c1.2,0,2.3-0.2,3.3-0.5c1-0.4,1.8-0.8,2.5-1.5c0.7-0.6,1.2-1.4,1.5-2.3c0.4-0.9,0.5-1.8,0.5-2.8c0-1.2-0.2-2.1-0.7-2.8C309.6,483.9,309,483.3,308.2,482.9z M328.6,472.2c-0.4,0.9-0.9,1.9-1.4,2.8c-0.5,1-1,1.9-1.5,2.9c-0.5,1-1.1,1.9-1.6,2.8c-0.5,0.9-1,1.8-1.5,2.5c-1.1-1.9-2.2-3.8-3.1-5.6c-1-1.8-2-3.6-2.9-5.5c-0.3,0-0.6,0.1-0.9,0.1c-0.3,0-0.6,0-0.9,0c-0.3,0-0.6,0-0.9,0c-0.3,0-0.6-0.1-0.9-0.1c0.2,0.3,0.5,0.8,0.9,1.5c0.4,0.7,0.9,1.4,1.4,2.3c0.5,0.8,1,1.7,1.6,2.6c0.6,0.9,1.1,1.8,1.6,2.6c0.5,0.8,1,1.6,1.4,2.3c0.4,0.7,0.7,1.2,0.9,1.6c0,1.7,0,3.4,0,4.9c0,1.6-0.1,2.9-0.2,4c0.5,0,1-0.1,1.6-0.1c0.6,0,1.1,0,1.6,0.1c0-0.4-0.1-1-0.1-1.8c0-0.7-0.1-1.5-0.1-2.4c0-0.9,0-1.7,0-2.6c0-0.9,0-1.7,0-2.5c0.3-0.7,0.7-1.4,1.2-2.2c0.5-0.8,1-1.7,1.6-2.8c0.6-1,1.3-2.2,2.1-3.4c0.8-1.3,1.7-2.7,2.7-4.2c-0.5,0.1-0.9,0.2-1.2,0.2C329.5,472.3,329.1,472.3,328.6,472.2z M343.6,482.9c-0.7-0.4-1.5-0.8-2.4-1.1c-0.9-0.3-1.7-0.7-2.4-1.1c-0.7-0.4-1.4-0.9-1.9-1.5c-0.5-0.6-0.7-1.4-0.7-2.4c0-0.6,0.1-1.1,0.3-1.6c0.2-0.5,0.5-0.9,0.9-1.3c0.4-0.4,0.8-0.6,1.3-0.8c0.5-0.2,1-0.3,1.6-0.3c0.6,0,1.1,0.1,1.5,0.3c0.4,0.2,0.8,0.5,1.1,0.7c0.3,0.3,0.6,0.6,0.7,1c0.2,0.4,0.3,0.7,0.4,1h0.4c0.1-0.6,0.3-1.1,0.4-1.5c0.1-0.4,0.3-0.8,0.5-1.1c-0.6-0.5-1.3-0.9-2.1-1.1c-0.7-0.2-1.6-0.4-2.6-0.4c-1.1,0-2,0.1-2.9,0.4c-0.9,0.3-1.6,0.7-2.2,1.2c-0.6,0.5-1.1,1.2-1.4,1.9c-0.3,0.7-0.5,1.5-0.5,2.4c0,1.3,0.2,2.3,0.7,3c0.5,0.7,1.1,1.4,1.9,1.8c0.7,0.5,1.5,0.9,2.4,1.2c0.9,0.3,1.7,0.7,2.4,1.1c0.7,0.4,1.4,0.9,1.9,1.4c0.5,0.6,0.7,1.3,0.7,2.3c0,0.6-0.1,1.2-0.3,1.8c-0.2,0.6-0.5,1.1-0.9,1.5c-0.4,0.4-0.9,0.7-1.4,1c-0.6,0.2-1.2,0.4-1.9,0.4c-0.7,0-1.3-0.1-1.8-0.3c-0.6-0.2-1-0.5-1.5-0.8c-0.4-0.3-0.8-0.7-1.1-1.1c-0.3-0.4-0.5-0.8-0.7-1.2h-0.4c-0.1,0.6-0.1,1.1-0.2,1.5c-0.1,0.4-0.2,0.8-0.4,1.3c0.6,0.4,1.2,0.8,2.1,1.2c0.8,0.4,1.9,0.5,3.2,0.5c1.2,0,2.3-0.2,3.3-0.5c1-0.4,1.8-0.8,2.5-1.5c0.7-0.6,1.2-1.4,1.5-2.3c0.4-0.9,0.5-1.8,0.5-2.8c0-1.2-0.2-2.1-0.7-2.8C345,483.9,344.4,483.3,343.6,482.9z M360.7,472.3c-1.3,0-2.7,0-4.1,0c-1.4,0-2.8,0-4.1,0c-1.3,0-2.7-0.1-4.1-0.1c0.1,0.4,0.2,0.8,0.2,1c0,0.3-0.1,0.6-0.2,1c0.4-0.1,1-0.1,1.5-0.2c0.6,0,1.1-0.1,1.8-0.1c0.6,0,1.2-0.1,1.8-0.1c0.6,0,1.2,0,1.7,0c0.1,2.2,0.1,4.4,0.1,6.6v5.5c0,1.4,0,2.8-0.1,4.1c-0.1,1.4-0.1,2.7-0.2,4c0.5,0,1-0.1,1.6-0.1c0.6,0,1.1,0,1.6,0.1c-0.1-1.3-0.1-2.7-0.2-4c-0.1-1.4-0.1-2.7-0.1-4.1v-5.5c0-2.2,0-4.4,0.1-6.6c0.6,0,1.1,0,1.7,0c0.6,0,1.2,0,1.8,0.1c0.6,0,1.2,0.1,1.8,0.1c0.6,0,1.1,0.1,1.5,0.2c-0.1-0.4-0.2-0.7-0.2-1c0-0.3,0.1-0.6,0.2-1C363.4,472.2,362,472.3,360.7,472.3z M379.8,492.3c-0.5,0.1-1.1,0.2-1.8,0.2c-0.7,0.1-1.4,0.1-2.2,0.1c-0.8,0-1.6,0-2.4,0h-2.2c0-0.4,0-1,0-1.8c0-0.8,0-1.8,0-3v-3.2c0-0.3,0-0.6,0-0.8c0-0.2,0-0.4,0-0.6c0.4,0,0.9,0,1.5,0c0.6,0,1.3,0,2.1,0c0.7,0,1.5,0,2.2,0.1c0.7,0,1.4,0.1,1.9,0.2c-0.1-0.3-0.1-0.6-0.1-1c0-0.3,0-0.7,0.1-1c-0.5,0-1,0.1-1.5,0.1c-0.5,0-1.1,0.1-1.7,0.1c-0.6,0-1.3,0.1-2,0.1c-0.7,0-1.6,0-2.5,0c0-0.4,0-1,0-1.8c0-0.8,0-1.6,0-2.4c0-0.8,0-1.5,0-2.1c0-0.6,0.1-1.3,0.1-1.9c1,0,1.9,0,2.7,0c0.7,0,1.4,0.1,2.1,0.1c0.6,0,1.2,0.1,1.8,0.1c0.6,0,1.2,0.1,1.9,0.1c-0.1-0.3-0.1-0.6-0.1-1c0-0.3,0-0.6,0.1-1c-1,0-1.9,0.1-2.8,0.1c-0.9,0-1.9,0-2.8,0c-1,0-1.9,0-2.9,0c-0.9,0-1.9-0.1-2.9-0.1c0.1,1.4,0.1,2.7,0.2,4.1c0.1,1.4,0.1,2.7,0.1,4.1v5.5c0,1.4,0,2.8-0.1,4.1c-0.1,1.4-0.1,2.7-0.2,4.1c1,0,1.9-0.1,2.9-0.1h5.8c0.9,0,1.9,0,2.9,0.1c-0.1-0.2-0.1-0.5-0.1-0.8c0-0.1,0-0.3,0-0.5C379.7,492.6,379.8,492.4,379.8,492.3z M406.8,483.3c-0.2-1.8-0.4-3.7-0.6-5.6c-0.2-1.9-0.4-3.9-0.7-5.9h-0.4c-0.5,1-1.1,2-1.7,3.2c-0.6,1.1-1.2,2.3-1.9,3.4c-0.6,1.2-1.2,2.3-1.8,3.5c-0.6,1.1-1.2,2.2-1.7,3.2c-0.5,1-1,1.8-1.4,2.6c-0.4,0.8-0.7,1.3-0.9,1.7c-1.6-3-3.2-5.9-4.7-8.8c-1.5-2.8-3-5.8-4.4-8.8H386c-0.2,1.7-0.4,3.5-0.6,5.4c-0.2,1.9-0.5,3.8-0.8,5.7c-0.3,1.9-0.6,3.9-0.9,5.8c-0.3,1.9-0.6,3.7-0.9,5.5c0.3,0,0.7-0.1,1.1-0.1c0.4,0,0.8,0,1.1,0.1c0-0.9,0.1-1.9,0.2-3.3c0.1-1.3,0.2-2.7,0.4-4.2c0.1-1.5,0.3-3,0.5-4.6c0.2-1.5,0.3-3,0.5-4.3h0.1c1.4,2.8,2.8,5.6,4.2,8.2c1.4,2.7,2.7,5.4,4,8h0.3c1.3-2.9,2.6-5.7,4-8.3c1.4-2.6,2.9-5.3,4.3-8h0.1c0.3,2.8,0.6,5.5,0.9,8.1c0.2,2.7,0.5,5.4,0.7,8.2c0.3,0,0.5-0.1,0.7-0.1h1.5c0.2,0,0.5,0,0.7,0.1c-0.3-1.8-0.5-3.5-0.7-5.3 C407.2,486.9,407,485.1,406.8,483.3z M423.4,484.6c-0.5-0.7-1.1-1.3-1.9-1.7c-0.7-0.4-1.5-0.8-2.4-1.1c-0.9-0.3-1.7-0.7-2.4-1.1c-0.7-0.4-1.4-0.9-1.9-1.5c-0.5-0.6-0.7-1.4-0.7-2.4c0-0.6,0.1-1.1,0.3-1.6c0.2-0.5,0.5-0.9,0.9-1.3c0.4-0.4,0.8-0.6,1.3-0.8c0.5-0.2,1-0.3,1.6-0.3c0.6,0,1.1,0.1,1.5,0.3c0.4,0.2,0.8,0.5,1.1,0.7c0.3,0.3,0.6,0.6,0.7,1c0.2,0.4,0.3,0.7,0.4,1h0.4c0.1-0.6,0.3-1.1,0.4-1.5c0.1-0.4,0.3-0.8,0.5-1.1c-0.6-0.5-1.3-0.9-2.1-1.1c-0.7-0.2-1.6-0.4-2.6-0.4c-1.1,0-2,0.1-2.9,0.4c-0.9,0.3-1.6,0.7-2.2,1.2c-0.6,0.5-1.1,1.2-1.4,1.9c-0.3,0.7-0.5,1.5-0.5,2.4c0,1.3,0.2,2.3,0.7,3c0.5,0.7,1.1,1.4,1.9,1.8c0.7,0.5,1.5,0.9,2.4,1.2c0.9,0.3,1.7,0.7,2.4,1.1c0.7,0.4,1.4,0.9,1.9,1.4c0.5,0.6,0.7,1.3,0.7,2.3c0,0.6-0.1,1.2-0.3,1.8c-0.2,0.6-0.5,1.1-0.9,1.5c-0.4,0.4-0.9,0.7-1.4,1c-0.6,0.2-1.2,0.4-1.9,0.4c-0.7,0-1.3-0.1-1.8-0.3c-0.6-0.2-1-0.5-1.5-0.8c-0.4-0.3-0.8-0.7-1.1-1.1c-0.3-0.4-0.5-0.8-0.7-1.2h-0.4c-0.1,0.6-0.1,1.1-0.2,1.5c-0.1,0.4-0.2,0.8-0.4,1.3c0.6,0.4,1.2,0.8,2.1,1.2c0.8,0.4,1.9,0.5,3.2,0.5c1.2,0,2.3-0.2,3.3-0.5c1-0.4,1.8-0.8,2.5-1.5c0.7-0.6,1.2-1.4,1.5-2.3c0.4-0.9,0.5-1.8,0.5-2.8 C424.2,486.3,423.9,485.3,423.4,484.6z");
        this.text_r = this.text.append("path")
            .attr("fill", "#6E6E73")
            .attr("d", "M433.1,472.1c2.2,0,3.9,1.8,3.9,3.9c0,2.2-1.8,3.9-3.9,3.9c-2.2,0-3.9-1.8-3.9-3.9 C429.2,473.8,430.9,472.1,433.1,472.1z M433.1,479.5c1.9,0,3.5-1.6,3.5-3.5s-1.5-3.5-3.5-3.5s-3.5,1.6-3.5,3.5 S431.2,479.5,433.1,479.5z M431.7,475c0-0.5,0-1.1-0.1-1.5c0.3,0,0.6,0.1,0.9,0.1c0.3,0,0.6-0.1,0.9-0.1c0.8,0,1.4,0.4,1.4,1.1c0,0.9-1,1.3-1.5,1.4c0.6,0.7,1.5,2,1.9,2.4v0.1c-0.1,0-0.3-0.1-0.4-0.1c-0.1,0-0.3,0-0.4,0.1c-0.5-0.8-1.1-1.6-1.8-2.4h-0.4v0.8c0,0.5,0,1.1,0.1,1.6c-0.1,0-0.2-0.1-0.4-0.1c-0.1,0-0.2,0-0.4,0.1c0-0.5,0.1-1,0.1-1.5V475z M432.2,475.7c0.1,0,0.3,0,0.5,0c0.7,0,1.4-0.3,1.4-1.1c0-0.6-0.4-0.9-1-0.9c-0.3,0-0.5,0-0.8,0.1c0,0.3-0.1,0.7-0.1,1V475.7z");
        this.text_tm = this.text.append("path")
            .attr("fill", "#6E6E73")
            .attr("d", "M376.1,322.1c0-0.6,0-1.2,0-1.9c-0.6,0-1.4,0-1.9,0.1c0-0.1,0-0.2,0-0.3c0-0.1,0-0.2,0-0.3c0.8,0,1.5,0,2.3,0s1.5,0,2.3,0c0,0.1,0,0.2,0,0.3c0,0.1,0,0.2,0,0.3c-0.5-0.1-1.3-0.1-1.9-0.1c0,0.6,0,1.2,0,1.9v1.5c0,0.8,0,1.6,0.1,2.3c-0.2,0-0.3,0-0.4,0c-0.1,0-0.3,0-0.4,0c0-0.8,0.1-1.6,0.1-2.3V322.1zM380.5,319.7c0.8,1.7,1.7,3.3,2.6,5c0.4-0.7,1.8-3.3,2.7-5h0.1c0.3,2.3,0.5,4.3,0.7,6.3c-0.1,0-0.3,0-0.4,0c-0.1,0-0.3,0-0.4,0c-0.1-1.6-0.3-3.1-0.4-4.6h0c-0.8,1.5-1.6,3-2.4,4.6h-0.1c-0.7-1.5-1.5-3-2.3-4.6h0c-0.2,1.5-0.4,3.6-0.4,4.6c-0.1,0-0.2,0-0.3,0c-0.1,0-0.2,0-0.3,0c0.3-2,0.7-4.4,0.9-6.3H380.5z");
        var bbox = this.root.node().getBBox();
        var centerX = bbox.x + bbox.width / 2;
        var centerY = bbox.y + bbox.height / 2;
        var scale = Math.min(this.width(), this.height()) / Math.max(bbox.width, bbox.height);
        this.root
            .attr("transform", "translate(" + (-centerX * scale) + "," + (-centerY * scale) + ")scale(" + scale + ")");
    };
    HPCCBadge.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        switch (this.animation()) {
            case "none":
                break;
            case "accentInOut":
                this.logo.attr("opacity", 0);
                this.logo_accent.attr("transform", "translate(-400, 0)");
                this.text.attr("opacity", 0);
                this.logo.transition().duration(1000)
                    .attr("opacity", 1);
                this.logo_accent.transition().delay(500).duration(1500)
                    .attr("transform", "translate(0, 0)");
                this.text.transition().delay(100).duration(1000)
                    .attr("opacity", 1);
                this.logo_accent.transition().ease("back").delay(7000).duration(1500)
                    .attr("transform", "translate(400, 0)");
                this.text.transition().delay(8400).duration(1000)
                    .attr("opacity", 0);
                this.logo_accent.transition().delay(8500).duration(1000)
                    .attr("opacity", 0);
                this.logo.transition().delay(8500).duration(1000)
                    .attr("opacity", 0);
                break;
            case "accentIn":
                this.logo.attr("opacity", 0);
                this.logo_accent.attr("transform", "translate(-400, 0)");
                this.text.attr("opacity", 0);
                this.logo.transition().duration(1000)
                    .attr("opacity", 1);
                this.logo_accent.transition().delay(500).duration(1500)
                    .attr("transform", "translate(0, 0)");
                this.text.transition().delay(100).duration(1000)
                    .attr("opacity", 1);
                break;
            case "fade_in":
                this.logo.attr("opacity", 0);
                // this.logo_accent.attr("transform", "translate(-400, 0)");
                this.logo_accent.attr("opacity", 0);
                this.text.attr("opacity", 0);
                this.logo.transition().duration(1000)
                    .attr("opacity", 1);
                /*
                this.logo_accent.transition().delay(500).duration(1500)
                    .attr("transform", "translate(0, 0)")
                ;
                */
                this.logo_accent.transition().duration(1000)
                    .attr("opacity", 1);
                this.text.transition().delay(100).duration(1000)
                    .attr("opacity", 1);
                /*
                this.logo_accent.transition().ease("back").delay(7000).duration(1500)
                    .attr("transform", "translate(400, 0)")
                ;
                */
                /*
                this.text.transition().delay(8400).duration(1000)
                    .attr("opacity", 0)
                ;
                this.logo_accent.transition().delay(8500).duration(1000)
                    .attr("opacity", 0)
                ;
                this.logo.transition().delay(8500).duration(1000)
                    .attr("opacity", 0)
                ;
                */
                break;
            default:
                break;
        }
    };
    return HPCCBadge;
}(SVGWidget));
HPCCBadge.prototype._class += " other_HPCCBadge";
HPCCBadge.prototype.publish("animation", "none", "set", "Animation Style", ["none", "accentInOut", "accentIn", "fade_in"]);

var css$2 = ".other_Html{height:100%;width:100%;overflow-x:auto;overflow-y:scroll}";
styleInject(css$2);

var Html = /** @class */ (function (_super) {
    __extends(Html, _super);
    function Html() {
        var _this = _super.call(this) || this;
        _this._tag = "div";
        return _this;
    }
    Html.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
    };
    Html.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        element
            .style("overflow-x", this.overflowX_exists() ? this.overflowX() : "")
            .style("overflow-y", this.overflowY_exists() ? this.overflowY() : "");
        var html = element.selectAll(".htmlWrapper").data(this.data().length > 0 ? this.data() : [this.html()]);
        html.enter().append("div")
            .attr("class", "htmlWrapper")
            .merge(html)
            .html(function (d) { return d; });
        html.exit().remove();
    };
    return Html;
}(HTMLWidget));
Html.prototype._class += " other_Html";
Html.prototype.publish("html", "", "string", "Html to render", null, { tags: ["Basic"] });
Html.prototype.publish("overflowX", null, "set", "CSS overflow-x", ["", "visible", "hidden", "scroll", "auto", "initial", "inherit"], { tags: ["Basic"], optional: true });
Html.prototype.publish("overflowY", null, "set", "CSS overflow-y", ["", "visible", "hidden", "scroll", "auto", "initial", "inherit"], { tags: ["Basic"], optional: true });

var css$3 = ".other_IconList .other_Html{overflow-x:hidden;overflow-y:hidden}";
styleInject(css$3);

var IconList = /** @class */ (function (_super) {
    __extends(IconList, _super);
    function IconList() {
        var _this = _super.call(this) || this;
        _this._entity_list = [];
        _this._content_list = [];
        _this._list = new HorizontalList()
            .orientation_default("horizontal")
            .flexWrap_default("nowrap");
        return _this;
    }
    IconList.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        element
            .style("height", "100%")
            .style("width", "100%");
        d3Select(domNode.parentElement)
            .style("height", "100%")
            .style("width", "100%");
        this._list.target(domNode);
    };
    IconList.prototype.update = function (domNode, element) {
        var _this = this;
        _super.prototype.update.call(this, domNode, element);
        var listWidgets = this._list.widgets();
        this.data().forEach(function (row, idx) {
            if (!listWidgets[idx]) {
                listWidgets[idx] = _this.updateListProperties(new VerticalList(), idx)
                    .widgets([
                    _this.updateEntityProperties(new Entity(), idx),
                    new Html().html(_this.data()[idx][_this.htmlColumnIndex_exists() ? _this.htmlColumnIndex() : 1])
                ]);
            }
            else {
                listWidgets[idx] = _this.updateListProperties(listWidgets[idx], idx);
                _this.updateEntityProperties(listWidgets[idx].widgets()[0], idx);
                listWidgets[idx]
                    .widgets()[1]
                    .html(_this.data()[idx][_this.htmlColumnIndex_exists() ? _this.htmlColumnIndex() : 1]);
            }
        });
        this._list.widgets(listWidgets.slice(0, this.data().length));
        this._list.resize().render();
    };
    IconList.prototype.updateListProperties = function (list, idx) {
        return list
            .disableScroll(true)
            .widgetsFlexBasis([this.iconSize() + "px", "calc(100% - " + this.iconSize() + "px)"]);
    };
    IconList.prototype.updateEntityProperties = function (entity, idx) {
        return entity
            .icon(this.iconColumnIndex_exists() ? this.data()[idx][this.iconColumnIndex()] : "?")
            .iconColor(this.iconColorColumnIndex_exists() ? this.data()[idx][this.iconColorColumnIndex()] : "#000")
            .iconDiameter(this.iconSize())
            .iconPaddingPercent(0);
    };
    return IconList;
}(HTMLWidget));
IconList.prototype._class += " other_IconList";
IconList.prototype.publish("iconSize", 72, "number", "Size of icon (pixels)");
IconList.prototype.publish("iconColumnIndex", 0, "number", "Index of column containing icon character");
IconList.prototype.publish("iconColorColumnIndex", 1, "number", "Index of column containing icon color");
IconList.prototype.publish("htmlColumnIndex", 2, "number", "Index of column containing html string");

var css$4 = ".other_Paginator{display:block;position:absolute;white-space:nowrap}.other_Paginator .pagination{display:inline-block;white-space:nowrap;margin:0;padding:0}.other_Paginator .pagination>li{display:inline}.other_Paginator input[type=number].currentPageNumber{border:1px solid #ddd;outline:0 none;position:relative;width:37px;text-align:center}.other_Paginator div.side{padding-top:5px;padding-left:8px;vertical-align:top}.other_Paginator span.side{position:relative;color:#337ab7}.other_Paginator .pagination>div,.other_Paginator .pagination>li>a,.other_Paginator .pagination>li>span{position:relative;float:left;padding:6px 12px;margin-left:-1px;line-height:1.42857143;color:#337ab7;text-decoration:none;background-color:#fff;border:1px solid #ddd}.other_Paginator .pagination>li:first-child>a,.other_Paginator .pagination>li:first-child>span{margin-left:0;border-top-left-radius:4px;border-bottom-left-radius:4px}.other_Paginator .pagination>li:last-child>a,.other_Paginator .pagination>li:last-child>span{border-top-right-radius:4px;border-bottom-right-radius:4px}.other_Paginator .pagination>li>a:focus,.other_Paginator .pagination>li>a:hover,.other_Paginator .pagination>li>span:focus,.other_Paginator .pagination>li>span:hover{color:#23527c;background-color:#eee;border-color:#ddd}.other_Paginator .pagination>.active>a,.other_Paginator .pagination>.active>a:focus,.other_Paginator .pagination>.active>a:hover,.other_Paginator .pagination>.active>span,.other_Paginator .pagination>.active>span:focus,.other_Paginator .pagination>.active>span:hover{z-index:2;color:#fff;cursor:default;background-color:#337ab7;border-color:#337ab7}.other_Paginator .pagination>.disabled>a,.other_Paginator .pagination>.disabled>a:focus,.other_Paginator .pagination>.disabled>a:hover,.other_Paginator .pagination>.disabled>span,.other_Paginator .pagination>.disabled>span:focus,.other_Paginator .pagination>.disabled>span:hover{color:#777;cursor:not-allowed;background-color:#fff;border-color:#ddd}.other_Paginator .pagination-lg>li>a,.other_Paginator .pagination-lg>li>span{padding:10px 16px;font-size:18px}.other_Paginator .pagination-lg>li:first-child>a,.other_Paginator .pagination-lg>li:first-child>span{border-top-left-radius:6px;border-bottom-left-radius:6px}.other_Paginator .pagination-lg>li:last-child>a,.other_Paginator .pagination-lg>li:last-child>span{border-top-right-radius:6px;border-bottom-right-radius:6px}.other_Paginator .pagination-sm>li>a,.other_Paginator .pagination-sm>li>span{padding:5px 10px;font-size:12px}.other_Paginator .pagination-sm>li:first-child>a,.other_Paginator .pagination-sm>li:first-child>span{border-top-left-radius:3px;border-bottom-left-radius:3px}.other_Paginator .pagination-sm>li:last-child>a,.other_Paginator .pagination-sm>li:last-child>span{border-top-right-radius:3px;border-bottom-right-radius:3px}";
styleInject(css$4);

var Paginator = /** @class */ (function (_super) {
    __extends(Paginator, _super);
    function Paginator() {
        var _this = _super.call(this) || this;
        _this._tag = "div";
        _this._tNumPages = 1; // np
        _this._numList = []; // pn
        return _this;
    }
    Paginator.prototype.postUpdate = function (domNode, element) { };
    Paginator.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        var context = this;
        this.paginator = element.append("ul").attr("class", "paginator pagination pagination-sm");
        this.side = element.append("div").attr("class", "paginator pagination side");
        this.side.append("span")
            .classed("side", true)
            .text("Page ");
        this.side.append("input")
            .attr("type", "number")
            .attr("class", "currentPageNumber")
            .property("value", 1)
            .attr("min", 1)
            .on("change", function () {
            context.pageNumber(this.value);
            context._onSelect(this.value);
        });
        this.side.append("span")
            .classed("side total", true)
            .text(" of 1");
    };
    Paginator.prototype.update = function (domNode, element) {
        var context = this;
        element
            .style("bottom", this.bottom() + "px")
            .style("right", this.right() + "px");
        this._tNumPages = Math.ceil(this.numItems() / this.itemsPerPage()) || 1;
        if (this.pageNumber() > this._tNumPages) {
            this.pageNumber(1);
        }
        this._numList = [];
        if (this.numItems()) {
            this._numList.push("first");
            for (var x = -this.adjacentPages(); x <= this.adjacentPages(); x++) {
                if (this.pageNumber() + x > 0 && this.pageNumber() + x <= this._tNumPages) {
                    this._numList.push(this.pageNumber() + x);
                }
            }
            this._numList.push("last");
        }
        this.side.select(".total").text(" of " + this._tNumPages);
        this.side.select(".currentPageNumber").property("value", this.pageNumber());
        this.side.select(".currentPageNumber").attr("max", this._tNumPages);
        var page = this.paginator.selectAll("li").data(this._numList, function (d) { return d; });
        page
            .enter()
            .append(function (d) {
            var li = document.createElement("li");
            if (d !== context.pageNumber()) {
                var a = document.createElement("a");
                var linkText = document.createTextNode(d);
                a.appendChild(linkText);
                a.href = "#";
                li.appendChild(a);
                return li;
            }
            else {
                var span = document.createElement("span");
                span.innerHTML = d;
                li.appendChild(span);
                return li;
            }
        })
            .on("click", function (d, i) {
            event.preventDefault();
            context.side.select(".currentPageNumber").property("value", context.pageNumber());
            switch (d) {
                case "first":
                    if (context.pageNumber() !== 1) {
                        context.pageNumber(1);
                        context._onSelect(1, "previous");
                    }
                    break;
                case "last":
                    if (context.pageNumber() !== context._tNumPages) {
                        context.pageNumber(context._tNumPages);
                        context._onSelect(context._tNumPages, "previous");
                    }
                    break;
                default:
                    context.pageNumber(d);
                    context._onSelect(d);
            }
        });
        page.classed("active", function (e, j) { return e === context.pageNumber(); })
            .select("a")
            .text(function (d) { return d; });
        page.exit().remove();
        page.order();
        if (this.numItems() === 0) {
            d3Select(domNode).remove();
        }
    };
    Paginator.prototype.exit = function (domNode, element) {
        _super.prototype.exit.call(this, domNode, element);
    };
    return Paginator;
}(HTMLWidget));
Paginator.prototype._class += " other_Paginator";
Paginator.prototype.publish("itemsPerPage", 2, "number", "Pagination items per page", null, { tags: ["Private"] });
Paginator.prototype.publish("numItems", 10, "number", "Pagination total number of items", null, { tags: ["Private"] });
Paginator.prototype.publish("pageNumber", 1, "number", "Pagination set or get the page number", null, { tags: ["Private"] });
Paginator.prototype.publish("adjacentPages", 2, "number", "Number of page indexes either side of current one", null, { tags: ["Private"] });
Paginator.prototype.publish("bottom", 20, "number", "Pagination bottom offset", null, { tags: ["Private"] });
Paginator.prototype.publish("right", 20, "number", "Pagination right offset", null, { tags: ["Private"] });

var css$5 = ".other_Table{color:#333;border-width:1px;border-color:#999}.other_Table table{border-collapse:collapse;border-spacing:0}.other_Table .tableDiv{position:absolute}.labels-wrapper th,.other_Table th{padding:5px 10px;border:1px solid #a9c6c9;color:#fff;white-space:nowrap;cursor:pointer;box-sizing:border-box}.cols-wrapper tr,.other_Table thead>tr{background-color:#1f77b4}.labels-wrapper .thIcon,.other_Table .thIcon{font-family:FontAwesome;padding-left:8px}.other_Table .tableDiv tbody>tr:nth-child(odd){background-color:#f3faff;color:#000}.other_Table .tableDiv tbody>tr:nth-child(2n){background-color:#fff;color:#000}.other_Table .tableDiv tbody>tr.selected{background-color:#f48a00;color:#fff}.other_Table .rows-wrapper table>tbody>tr{background-color:#bce1fb;color:#000}.other_Table .rows-wrapper .labels-wrapper{width:100%}.other_Table table tbody>tr.selected{background-color:#f48a00;color:#fff}.other_Table .tableDiv tbody>tr.hover,.other_Table .tableDiv tbody>tr:hover,.rows-wrapper table tbody tr.hover{background-color:#bfd7e7;color:#fff}.other_Table .rows-wrapper tbody tr.hover.selected,.other_Table .tableDiv tbody>tr.selected.hover,.other_Table .tableDiv tbody>tr.selected:hover,.other_Table tr.selected.hover,.other_Table tr.selected:hover{background-color:#5ea8db;color:#fff}.other_Table td,.rows-wrapper td{padding:2px 5px;border:1px solid #a9c6c9;white-space:nowrap;box-sizing:border-box;vertical-align:middle}.other_Table tfoot td,.rows-wrapper tfoot td{background-color:#addff3;font-weight:700}";
styleInject(css$5);

function replacer(key, value) {
    if (value instanceof Widget) {
        return "Widget with class: " + value.classID();
    }
    return value;
}
var Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table() {
        var _this = _super.call(this) || this;
        _this._tag = "div";
        _this.columns([]);
        _this._paginator = new Paginator();
        _this._selectionBag = new Utility.Selection(_this);
        _this._selectionPrevClick = null;
        _this._paginatorTableSpacing = 4;
        return _this;
    }
    Table.prototype.size = function (_) {
        var retVal = _super.prototype.size.apply(this, arguments);
        if (arguments.length) {
            if (this.tableDiv) {
                var topMargin = this.showHeader() && this.fixedHeader() ? this.thead.property("offsetHeight") : 0;
                this.tableDiv
                    .style("width", this._size.width + "px")
                    .style("height", this._size.height - topMargin + "px");
                this._element
                    .style("width", this._size.width + "px")
                    .style("height", this._size.height + "px");
            }
        }
        return retVal;
    };
    Table.prototype.isHidden = function (colIdx) {
        if (this.pivot())
            return false;
        if (this.hiddenColumns().indexOf(colIdx) !== -1)
            return true;
        var fields = this.fields();
        if (fields && fields[colIdx] && (fields[colIdx].type() === "hidden" || this._empty_col_idx_arr.indexOf(colIdx) !== -1)) {
            return true;
        }
        return false;
    };
    Table.prototype.tableColumns = function (_) {
        var retVal = this.columns.apply(this, arguments);
        if (!arguments.length && this.pivot()) {
            return this._db.column(0);
        }
        return retVal;
    };
    Table.prototype.tableData = function (_) {
        var retVal = this.data.apply(this, arguments);
        if (!arguments.length && this.pivot()) {
            return this._db.columns().filter(function (col, idx) { return idx > 0; });
        }
        return retVal;
    };
    Table.prototype.field = function (rowIdx, colIdx) {
        var noTransform = { transform: function (d) { return d; } };
        if (this.pivot()) {
            if (colIdx === 0)
                return noTransform;
            return this.fields()[rowIdx + 1];
        }
        if (rowIdx === -1)
            return noTransform;
        return this.fields()[colIdx];
    };
    Table.prototype.calcFieldsIndex = function (colIdx) {
        var i = -1;
        var offset = 0;
        var colLen = this.columns().length;
        var visibleCount = 0;
        while (i < colLen && visibleCount <= colIdx) {
            i++;
            if (this.isHidden(i)) {
                offset++;
            }
            else {
                visibleCount++;
            }
        }
        return colIdx + offset;
    };
    Table.prototype.getEmptyColumnIdxArr = function (columns, data) {
        var ret_arr = [];
        if (this.hideEmptyColumns()) {
            for (var col_idx = 0; col_idx < columns.length; col_idx++) {
                var column_is_empty = true;
                for (var row_idx = 0; row_idx < data.length; row_idx++) {
                    if (["", null, undefined].indexOf(data[row_idx][col_idx]) === -1) {
                        column_is_empty = false;
                        break;
                    }
                }
                if (column_is_empty) {
                    ret_arr.push(col_idx);
                }
            }
        }
        return ret_arr;
    };
    Table.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        this._placeholderElement.style("overflow", "hidden");
        this.tableDiv = element.append("div").attr("class", "tableDiv");
        this.table = this.tableDiv.append("table");
        this.fixedHead = element.append("div").classed("header-wrapper", true);
        this.fixedHeadTable = this.fixedHead.append("table");
        this.fixedThead = this.fixedHeadTable.append("thead").append("tr");
        this.unfixedThead = this.table.append("thead").append("tr");
        this.tbody = this.table.append("tbody");
        this.tfoot = this.table.append("tfoot").append("tr");
        this.fixedCol = element.append("div").classed("rows-wrapper", true);
        this.fixedColTable = this.fixedCol.append("table");
        this.fixedColHead = this.fixedColTable.append("thead");
        this.fixedColHeadRow = this.fixedColHead.append("tr");
        this.fixedColBody = this.fixedColTable.append("tbody");
        this.fixedColFoot = this.fixedColTable.append("tfoot");
        this.fixedColFootRow = this.fixedColFoot.append("tr");
        this.tableDiv
            .style("overflow", "auto");
    };
    Table.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        var context = this;
        var columns = context.tableColumns();
        var data = context.tableData();
        var scrollLeft = this.tableDiv.node().scrollLeft;
        this._empty_col_idx_arr = this.getEmptyColumnIdxArr(columns, data);
        this.element().selectAll("table,tbody,th,td").style("width", null);
        if (this.sortByFieldIndex_exists() && (this._prevSortByFieldIndex !== this.sortByFieldIndex() || this._prevDescending !== this.descending())) {
            Utility.multiSort(data, [{ idx: this.sortByFieldIndex(), reverse: this.descending() }]);
            this._prevSortByFieldIndex = this.sortByFieldIndex();
            this._prevDescending = this.descending();
        }
        this._hasChildWidgets = false;
        if (this.fixedHeader()) {
            this.thead = this.fixedThead;
        }
        else {
            this.thead = this.unfixedThead;
        }
        this.fixedHead.style("display", this.fixedHeader() ? "table-row" : "none");
        this.unfixedThead.style("display", this.fixedHeader() ? "none" : "table-row");
        var thSel = this.thead.selectAll("th").data(this.showHeader() ? columns.filter(function (col, idx) {
            return !context.isHidden(idx) && context._empty_col_idx_arr.indexOf(idx) === -1;
        }) : []);
        var thUpdate = thSel.enter().append("th")
            .each(function (d) {
            var element2 = d3Select(this);
            element2
                .append("span")
                .attr("class", "thText");
            element2
                .append("span")
                .attr("class", "thIcon");
        })
            .on("click", function (column, idx) {
            context.headerClick(column, idx);
        })
            .merge(thSel)
            .style("background-color", this.theadRowBackgroundColor())
            .style("border-color", this.theadCellBorderColor())
            .style("color", this.theadFontColor())
            .style("font-size", this.theadFontSize());
        thUpdate.select(".thText")
            .style("font-family", this.theadFontFamily())
            .text(function (column, idx) {
            var fieldsIdx = context.calcFieldsIndex(idx);
            return context.field(-1, fieldsIdx).transform(column);
        });
        thUpdate.select(".thIcon")
            .text(function (column, idx) {
            if (context.descending()) {
                return context.sortByFieldIndex() === idx ? "\uf078" : "";
            }
            else {
                return context.sortByFieldIndex() === idx ? "\uf077" : "";
            }
        });
        thSel.exit()
            .remove();
        thUpdate.order();
        if (this.paginationLimit()) {
            this.pagination(data.length >= parseInt(this.paginationLimit()) ? true : false);
        }
        if (this.pagination()) {
            if (this._paginator.target() === null) {
                this._paginator.target(element.node());
            }
            var ipp = this._calcRowsPerPage(thUpdate);
            this.itemsPerPage(ipp);
            this._paginator.numItems(data.length);
            this._tNumPages = Math.ceil(this._paginator.numItems() / this.itemsPerPage()) || 1;
            if (this.pageNumber() > this._tNumPages || this.pageNumber() <= 0) {
                this.pageNumber(1);
            } // resets if current pagenum selected out of range
            this._paginator._onSelect = function (p, d) {
                context.pageNumber(p);
                context.render();
                return;
            };
        }
        else {
            this._paginator.numItems(0); // remove widget
        }
        // pageNumber starts at index 1
        var startIndex = this.pageNumber() - 1;
        var itemsOnPage = this.itemsPerPage();
        var start = startIndex * itemsOnPage;
        var end = startIndex * parseInt(itemsOnPage) + parseInt(itemsOnPage);
        var tData = null;
        if (this.topN()) {
            tData = data.slice(0, this.topN());
        }
        else if (this.pagination()) {
            tData = data.slice(start, end);
        }
        else {
            tData = data;
        }
        var totalRow = [this.totalledLabel() ? this.totalledLabel() : null];
        if (this.totalledColumns().length !== 0) {
            for (var i = 0; i < this.totalledColumns().length; i++)
                this.totalledColumns()[i] = +this.totalledColumns()[i];
            for (var j = 1; j < columns.length; j++) {
                var sum = 0;
                if (this.totalledColumns().indexOf(j) !== -1) {
                    for (var k = 0; k < tData.length; k++) {
                        sum = sum + tData[k][j];
                    }
                    totalRow.push(sum);
                }
                else {
                    totalRow.push("");
                }
            }
            var tfSel = this.tfoot.selectAll("td").data(totalRow);
            tfSel.enter()
                .append("td")
                .merge(tfSel)
                .style("background-color", this.tfootRowBackgroundColor())
                .style("border-color", this.tfootCellBorderColor())
                .style("color", this.tfootFontColor())
                .style("font-size", this.tfootFontSize())[this.renderHtmlDataCells() ? "html" : "text"](function (d, idx) {
                return context.fields()[idx].transform(d);
            });
            tfSel.exit()
                .remove();
        }
        var rowsSel = this.tbody.selectAll("tr.tr_" + this.id()).data(tData.map(function (d, idx) {
            //  TODO - Move fix closer to data source?
            for (var i = 0; i < d.length; ++i) {
                if (d[i] === undefined) {
                    d[i] = null;
                }
            }
            return {
                rowIdx: idx,
                row: d
            };
        }));
        var rowsUpdate = rowsSel.enter().append("tr")
            .attr("class", "tr_" + this.id())
            .on("click.selectionBag", function (_d) {
            if (_d.row) {
                var d = _d.row;
                var i = _d.rowIdx;
                context.selectionBagClick(d, i);
                context.applyRowStyles(context.getBodyRow(i));
                context.applyFirstColRowStyles(context.getFixedRow(i));
            }
        }, true) //  capture=true:  event is caught on the way down the DOM before the cell click.
            .on("mouseover", function (_d) {
            if (_d.row) {
                var i = _d.rowIdx;
                var fixedLeftRows = context.getFixedRow(i);
                if (!fixedLeftRows.empty()) {
                    fixedLeftRows.classed("hover", true);
                }
                var tbodyRows = context.getBodyRow(i);
                tbodyRows.classed("hover", true);
                context.applyStyleToRows(tbodyRows);
                context.applyFirstColRowStyles(fixedLeftRows);
            }
        })
            .on("mouseout", function (_d) {
            if (_d.row) {
                var i = _d.rowIdx;
                var fixedLeftRows = context.getFixedRow(i);
                fixedLeftRows.classed("hover", false);
                var tbodyRows = context.getBodyRow(i);
                tbodyRows.classed("hover", false);
                context.applyStyleToRows(tbodyRows);
                context.applyFirstColRowStyles(fixedLeftRows);
            }
        })
            .merge(rowsSel)
            .classed("selected", function (_d) {
            var d = _d.row;
            return context._selectionBag.isSelected(context._createSelectionObject(d));
        })
            .classed("trId" + this._id, true);
        rowsSel.exit()
            .remove();
        this.applyStyleToRows(rowsUpdate);
        var cellsSel = rowsUpdate.selectAll(".td_" + this.id()).data(function (_d, _trIdx) {
            return _d.row.filter(function (cell, idx) {
                return idx < columns.length && !context.isHidden(idx) && context._empty_col_idx_arr.indexOf(idx) === -1;
            }).map(function (cell, idx) {
                return {
                    rowInfo: _d,
                    colIdx: idx,
                    cell: cell
                };
            });
        });
        cellsSel.enter()
            .append("td")
            .attr("class", "td_" + this.id())
            .on("click", function (tdContents) {
            if (tdContents.rowInfo) {
                context.click(context.rowToObj(tdContents.rowInfo.row), context.columns()[tdContents.colIdx], context._selectionBag.isSelected(context._createSelectionObject(tdContents.rowInfo.row)));
            }
        })
            .on("dblclick", function (tdContents, idx) {
            if (tdContents.rowInfo) {
                context.dblclick(context.rowToObj(tdContents.rowInfo.row), context.columns()[tdContents.colIdx], context._selectionBag.isSelected(context._createSelectionObject(tdContents.rowInfo.row)));
            }
        })
            .each(function (tdContents, tdIdx) {
            var alignment = context.getColumnAlignment(tdContents.rowInfo.rowIdx, tdContents.colIdx, tdContents.cell);
            var el = d3Select(this);
            el
                .style("height", null)
                .style("text-align", alignment)
                .style("vertical-align", context.verticalAlign())
                .classed("tr-" + tdContents.rowInfo.rowIdx + "-td-" + tdIdx, true);
        })
            .merge(cellsSel)
            .each(function (tdContents) {
            var el = d3Select(this);
            if (tdContents.cell instanceof Widget) {
                el[context.renderHtmlDataCells() ? "html" : "text"](null);
                var widgetDiv = el.selectAll(".div_" + context.id()).data([tdContents.cell], function (d) { return d.id(); });
                widgetDiv.exit()
                    .each(function (d) {
                    d.target(null);
                })
                    .remove();
                widgetDiv.enter().append("div")
                    .attr("class", "div_" + context.id())
                    .style("width", context.minWidgetWidth() + "px")
                    .style("height", context.minWidgetHeight() + "px")
                    .each(function (d) {
                    var widgetDiv2 = d3Select(this);
                    d._parentWidget = context;
                    if (d._class.indexOf("childWidget") < 0) {
                        d._class = "childWidget " + d._class;
                    }
                    d
                        .target(null)
                        .target(widgetDiv2.node());
                })
                    .merge(widgetDiv)
                    .each(function (d) {
                    d
                        .resize()
                        .lazyRender();
                    context._hasChildWidgets = true;
                });
            }
            else {
                el.selectAll(".div_" + context.id()).remove();
                var fieldsIdx = context.calcFieldsIndex(tdContents.colIdx);
                el[context.renderHtmlDataCells() ? "html" : "text"](context.field(tdContents.rowInfo.rowIdx, fieldsIdx).transform(tdContents.cell));
            }
        });
        cellsSel.exit()
            .remove();
        var tableMarginHeight = parseInt(this.thead.node().offsetHeight);
        if (this.pagination() && this._hasChildWidgets) {
            this.tableDiv.style("overflow-y", "auto");
            this.table.style("margin-bottom", "50px");
            console.log("Warning: displaying another widget in the table may cause problems with pagination");
        }
        else {
            this.tableDiv.style("overflow-y", null);
            this.table.style("margin-bottom", null);
        }
        this.size(this._size);
        var fixedColWidth = 0;
        var fixedColThSel = this.fixedColHeadRow.selectAll("th").data(this.fixedColumn() && this.showHeader() ? [columns[0]] : []);
        var fixedColThUpdate = fixedColThSel.enter().append("th")
            .each(function (d) {
            var element2 = d3Select(this);
            element2
                .append("span")
                .attr("class", "thText");
            element2
                .append("span")
                .attr("class", "thIcon");
        })
            .on("click", function (column, idx) {
            context.headerClick(column, idx);
        })
            .merge(fixedColThSel)
            .style("background-color", this.theadRowBackgroundColor())
            .style("border-color", this.theadCellBorderColor())
            .style("color", this.theadFontColor())
            .style("font-size", this.theadFontSize());
        fixedColThUpdate.select(".thText")
            .style("font-family", this.theadFontFamily())
            .text(function (column) {
            return column;
        });
        fixedColThUpdate.select(".thIcon")
            .text(function (column, idx) {
            if (context.descending()) {
                return context.sortByFieldIndex() === idx ? "\uf078" : "";
            }
            else {
                return context.sortByFieldIndex() === idx ? "\uf077" : "";
            }
        });
        fixedColThSel.exit()
            .remove();
        var fixedColTrSel = this.fixedColBody.selectAll("tr").data(this.fixedColumn() ? tData : []);
        var fixedColTrUpdate = fixedColTrSel.enter().append("tr")
            .attr("class", function () {
            return "trId" + context._id;
        })
            .merge(fixedColTrSel)
            .on("click", function (d, i) {
            d3Select(rowsUpdate[0][i]).on("click.selectionBag")(rowsUpdate.data()[i], i);
        })
            .on("mouseover", function (d, i) {
            d3Select(rowsUpdate[0][i]).on("mouseover")(rowsUpdate.data()[i], i);
        })
            .on("mouseout", function (d, i) {
            d3Select(rowsUpdate[0][i]).on("mouseout")(rowsUpdate.data()[i], i);
        })
            .classed("selected", function (d) {
            return context._selectionBag.isSelected(context._createSelectionObject(d));
        });
        fixedColTrSel.exit()
            .remove();
        var fixedColTdSel = fixedColTrUpdate.selectAll("td").data(function (d, i) {
            return [d[0]];
        });
        var fixedColTdUpdate = fixedColTdSel.enter().append("td")
            .merge(fixedColTdSel)[this.renderHtmlDataCells() ? "html" : "text"](function (d) {
            if (typeof (d) === "string") {
                return d.trim();
            }
            else if (typeof (d) === "number") {
                return d;
            }
            return "";
        });
        fixedColTdSel.exit()
            .remove();
        var fixedColFootTdSel = this.fixedColFootRow.selectAll("td").data(this.fixedColumn() && this.totalledLabel() ? [this.totalledLabel()] : []);
        var fixedColFootTdUpdate = fixedColFootTdSel.enter().append("td")
            .merge(fixedColFootTdSel)[this.renderHtmlDataCells() ? "html" : "text"](function (d) {
            if (typeof (d) === "string") {
                return d.trim();
            }
            else if (typeof (d) === "number") {
                return d;
            }
            return "";
        });
        fixedColFootTdSel.exit()
            .remove();
        if (this.fixedColumn() && !this.fixedSize() && fixedColFootTdUpdate.length) {
            if (this.showHeader()) {
                fixedColWidth = fixedColFootTdUpdate.property("offsetWidth") > fixedColFootTdUpdate.property("offsetWidth") ? fixedColFootTdUpdate.property("offsetWidth") : fixedColFootTdUpdate.property("offsetWidth");
            }
            else {
                fixedColWidth = fixedColFootTdUpdate.property("offsetWidth");
            }
            this.fixedCol
                .style("position", "absolute")
                .style("margin-top", -this.tableDiv.property("scrollTop") + tableMarginHeight + "px");
            fixedColTdUpdate
                .style("width", fixedColWidth + "px");
            this.fixedColHead
                .style("position", "absolute")
                .style("margin-top", (this.fixedHeader() ? this.tableDiv.property("scrollTop") : 0) - tableMarginHeight + "px");
            fixedColThUpdate
                .style("width", fixedColWidth + "px");
            rowsUpdate.each(function (d, i) {
                var height = d3Select(this).select("td").property("offsetHeight");
                d3Select(fixedColTdUpdate[i][0]).style("height", height + "px");
            });
        }
        this.table
            .style("margin-left", -fixedColWidth + "px");
        this.tableDiv
            .style("margin-left", fixedColWidth + "px")
            .style("width", this.width() - fixedColWidth + "px");
        if (!rowsUpdate.empty())
            this.setColumnWidths(rowsUpdate);
        var box;
        var newTableHeight;
        var maxWidth;
        if (this.fixedSize()) {
            var node = d3Select(".tableDiv > table").node();
            if (node) {
                box = node.getBoundingClientRect();
                var newTableHeight_1;
                var finalWidth_1;
                if (box.width !== 0 && box.height !== 0) {
                    calcWidth();
                    calcHeight();
                }
                else {
                    if (box.height - tableMarginHeight <= context.tableDiv.property("offsetHeight")) {
                        calcHeight();
                    }
                    else {
                        if (context.fixedHeader()) {
                            newTableHeight_1 = context.tableDiv.property("offsetHeight"); //  is tableDiv correct?
                            newTableHeight_1 = newTableHeight_1 + "px";
                        }
                        else {
                            newTableHeight_1 = "100%";
                        }
                    }
                    if (box.width - fixedColWidth < context.tableDiv.property("offsetWidth")) {
                        calcWidth();
                    }
                    else {
                        if (context.fixedColumn()) {
                            finalWidth_1 = context.tableDiv.property("offsetWidth") - fixedColWidth; //  is tableDiv correct?
                            finalWidth_1 = finalWidth_1 + "px";
                        }
                        else {
                            finalWidth_1 = "100%";
                        }
                    }
                }
                if (element.classed("childWidget")) {
                    context._placeholderElement
                        .style("width", finalWidth_1 + "px")
                        .style("height", newTableHeight_1 + "px");
                    context.tableDiv
                        .style("overflow", "hidden");
                }
                context.size({ width: finalWidth_1, height: newTableHeight_1 });
            }
        }
        this.setOnScrollEvents(this.tableDiv.node(), tableMarginHeight);
        function calcWidth() {
            var newTableWidth = box.width;
            maxWidth = context.tbody.property("offsetWidth") + 1;
        }
        function calcHeight() {
            newTableHeight = context.tbody.property("offsetHeight") + tableMarginHeight;
            newTableHeight = newTableHeight;
        }
        this._paginator.render();
        setTimeout(function () {
            context._paginator
                .right((context.hasVScroll(element) ? Platform.getScrollbarWidth() : 0) + context._paginatorTableSpacing)
                .bottom((context.hasHScroll(element) ? Platform.getScrollbarWidth() : 0) + context._paginatorTableSpacing)
                .render(function () {
                context.tableDiv.node().scrollLeft = scrollLeft;
            });
        }, 0);
    };
    Table.prototype.exit = function (domNode, element) {
        this._paginator.target(null);
        _super.prototype.exit.call(this, domNode, element);
    };
    Table.prototype.setColumnWidths = function (rows) {
        var context = this;
        var firstRow = rows.filter(function (d, i) { return i === 0; });
        var tds = d3Select(null);
        firstRow.each(function (d) {
            tds = d3SelectAll(this.childNodes);
        });
        var tableMarginHeight = this.fixedHeader() ? this.thead.property("offsetHeight") : 0;
        var totalWidth = 1;
        var tdWidths = {};
        tds.each(function (d, i) {
            tdWidths[i] = this.offsetWidth;
        });
        var th = this.thead.selectAll("th");
        th.each(function (d, i) {
            var thwidth = this.offsetWidth;
            var tdwidth = tds.empty() ? 0 : tdWidths[i];
            var usewidth = thwidth >= tdwidth ? thwidth : tdwidth;
            this.style.width = usewidth + "px";
            tds
                .filter(function (_d, idx) { return idx === 0; })
                .each(function () {
                d3Select(this).style("width", usewidth + "px");
            });
            totalWidth += usewidth;
        });
        this.thead
            .style("position", this.fixedHeader() ? "absolute" : "relative")
            .style("width", totalWidth + "px")
            .style("margin-top", "0px");
        this.table
            .style("width", totalWidth + "px");
        this.tableDiv
            .style("margin-top", (context.fixedHeader() ? tableMarginHeight : 0) + "px");
        this.tbody
            .style("width", totalWidth + "px");
    };
    Table.prototype.getBodyRow = function (i) {
        return this.table.selectAll("tbody tr.trId" + this._id)
            .filter(function (d, idx) {
            return idx === i;
        });
    };
    Table.prototype.getFixedRow = function (i) {
        return this._element.selectAll(".rows-wrapper tbody tr")
            .filter(function (d, idx) {
            return idx === i;
        });
    };
    Table.prototype.setOnScrollEvents = function (scrollNode, margHeight) {
        var context = this;
        scrollNode.onscroll = function (e) {
            var topDelta = e.target.scrollTop;
            var leftDelta = e.target.scrollLeft;
            if (context.fixedHeader()) {
                context.thead
                    .style("margin-left", -leftDelta + "px");
            }
            if (context.fixedColumn()) {
                context.fixedCol
                    .style("margin-top", -topDelta + margHeight + "px");
                if (context.fixedHeader()) {
                    context.fixedColHead
                        .style("margin-top", topDelta - margHeight + "px");
                }
            }
        };
    };
    Table.prototype._generateTempRow = function () {
        var trow = this.tbody.append("tr");
        trow.append("td").text("QQQ");
        return trow;
    };
    Table.prototype._createSelectionObject = function (d) {
        var context = this;
        return {
            _id: d,
            element: function () { return context.tbody ? context.tbody.selectAll("tr").filter(function (d2) { return d2 === d; }) : d3Select(null); }
        };
    };
    Table.prototype._calcRowsPerPage = function (th) {
        if (this._paginator.numItems() === 0) { // only run on first render
            this._paginator.numItems(1);
            this.itemsPerPage(1);
        }
        this._paginator.render();
        var thHeight = this.thead.selectAll("th").node() ? this.thead.selectAll("th").node().clientHeight : 0;
        var tfootHeight = this.tfoot.selectAll("td").node() ? this.tfoot.selectAll("td").node().clientHeight : 0;
        var tmpRow = this._generateTempRow();
        var tcellHeight = tmpRow.node().clientHeight;
        tmpRow.remove();
        var paginatorHeight = this.calcHeight(this._paginator.element());
        var ipp = Math.floor((this.height() - thHeight - tfootHeight - paginatorHeight - (this.table.style("width") >= this.table.style("width") ? Platform.getScrollbarWidth() : 0) - this._paginatorTableSpacing * 2) / tcellHeight) || 1;
        if (this.totalledColumns().length !== 0) {
            ipp -= 1;
        }
        return ipp;
    };
    Table.prototype.sort = function (idx) {
        if (this.sortByFieldIndex() !== idx) {
            this.descending(false);
        }
        else {
            this.descending(!this.descending());
        }
        this.sortByFieldIndex(idx);
        return this;
    };
    Table.prototype.selection = function (_) {
        if (!arguments.length)
            return this._selectionBag.get().map(function (d) { return d._id; });
        this._selectionBag.set(_.map(function (row) {
            return this._createSelectionObject(row);
        }, this));
        return this;
    };
    Table.prototype.selectionBagClick = function (d, i) {
        if (this.multiSelect() && event.shiftKey && this._selectionPrevClick) {
            var inRange_1 = false;
            var rows_1 = [];
            var selection = this.tableData().filter(function (row, i2) {
                var lastInRangeRow = false;
                if (row === d || row === this._selectionPrevClick) {
                    if (inRange_1) {
                        lastInRangeRow = true;
                    }
                    inRange_1 = !inRange_1;
                    rows_1.push(i2);
                }
                return inRange_1 || lastInRangeRow;
            }, this);
            this.selection(selection);
        }
        else if (this.multiSelect()) {
            this._selectionBag.click(this._createSelectionObject(d), event);
            this._selectionPrevClick = d;
        }
        else {
            var selObj = this._createSelectionObject(d);
            this._selectionBag.click(selObj, { ctrlKey: this._selectionBag.isSelected(selObj) });
            this._selectionPrevClick = d;
        }
        this.render();
    };
    Table.prototype.applyHoverRowStyles = function (row) {
        var context = this;
        row
            .style("color", context.tbodyHoverRowFontColor())
            .style("background-color", context.tbodyHoverRowBackgroundColor());
    };
    Table.prototype.applySelectedRowStyles = function (row) {
        var context = this;
        row
            .style("color", context.tbodySelectedRowFontColor())
            .style("background-color", context.tbodySelectedRowBackgroundColor());
    };
    Table.prototype.applyRowStyles = function (row, isFirstCol) {
        if (isFirstCol === void 0) { isFirstCol = false; }
        var dataRow = row.datum().row;
        row
            .style("color", isFirstCol ? this.tbodyFirstColFontColor() : this.tbodyFontColor())
            .style("background-color", isFirstCol ? this.tbodyFirstColBackgroundColor() : this.tableZebraColor_exists() && this.tableData().indexOf(dataRow) % 2 ? this.tbodyRowBackgroundColor() : this.tableZebraColor());
    };
    Table.prototype.applyFirstColRowStyles = function (rows) {
        this.applyStyleToRows(rows, true);
    };
    Table.prototype.applyStyleToRows = function (rows, isFirstCol) {
        if (isFirstCol === void 0) { isFirstCol = false; }
        isFirstCol = typeof isFirstCol !== "undefined" ? isFirstCol : false;
        var context = this;
        rows.each(function () {
            var tr = d3Select(this);
            if (tr.classed("hover")) {
                context.applyHoverRowStyles(tr);
            }
            else if (tr.classed("selected")) {
                context.applySelectedRowStyles(tr);
            }
            else {
                context.applyRowStyles(tr, isFirstCol);
            }
        });
    };
    Table.prototype.getColumnAlignment = function (rowIdx, colIdx, cell) {
        var fieldsIdx = this.calcFieldsIndex(colIdx);
        var field = this.field(rowIdx, fieldsIdx);
        switch (field.__prop_type) {
            case "string":
                return this.stringAlign();
            case "number":
                return this.numberAlign();
            case "":
            case undefined:
                switch (typeof cell) {
                    case "string":
                        return this.stringAlign();
                    case "number":
                        return this.numberAlign();
                }
        }
        return null;
    };
    Table.prototype.serializeState = function () {
        return {
            selection: this._selectionBag.get().map(function (d) {
                return d._id;
            }),
            data: this.data()
        };
    };
    Table.prototype.deserializeState = function (state) {
        if (state) {
            if (state.selection) {
                var context_1 = this;
                this._selectionBag.set(state.selection.map(function (d) {
                    return context_1._createSelectionObject(d);
                }));
            }
            if (state.data) {
                this.data(state.data);
            }
        }
        return this;
    };
    Table.prototype.click = function (row, column, selected) {
        console.log("click:  " + JSON.stringify(row, replacer) + ", " + column + "," + selected);
    };
    Table.prototype.dblclick = function (row, column, selected) {
        console.log("dblclick:  " + JSON.stringify(row, replacer) + ", " + column + "," + selected);
    };
    Table.prototype.headerClick = function (column, idx) {
        this
            .sort(idx)
            .render();
    };
    return Table;
}(HTMLWidget));
Table.prototype._class += " other_Table";
Table.prototype.publish("renderHtmlDataCells", false, "boolean", "enable or disable HTML within cells", null, { tags: ["Private"] });
Table.prototype.publish("pagination", true, "boolean", "Enable or disable pagination", null, { tags: ["Private"] });
Table.prototype.publish("paginationLimit", null, "number", "Maximum number of rows allowed before pagination defaults to on", null, { tags: ["Private"] });
Table.prototype.publishProxy("itemsPerPage", "_paginator");
Table.prototype.publishProxy("pageNumber", "_paginator", "pageNumber", 1);
Table.prototype.publishProxy("adjacentPages", "_paginator");
Table.prototype.publish("topN", null, "number", "Total number or rows of data to be displayed in the table", null, { tags: ["Private"] });
Table.prototype.publish("pivot", false, "boolean", "Pivot Table");
Table.prototype.publish("showHeader", true, "boolean", "Show or hide the table header", null, { tags: ["Private"] });
Table.prototype.publish("fixedHeader", true, "boolean", "Enable or disable fixed table header", null, { tags: ["Private"] });
Table.prototype.publish("fixedColumn", false, "boolean", "Enable or disable fixed first column", null, { tags: ["Private"] });
Table.prototype.publish("multiSelect", false, "boolean", "Multiple Selection", null, { tags: ["Basic"] });
Table.prototype.publish("fixedSize", false, "boolean", "Fix Size to Min Width/Height");
Table.prototype.publish("hideEmptyColumns", false, "boolean", "Hide columns with all empty cells");
Table.prototype.publish("theadFontSize", null, "string", "Table head font size", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodyFontSize", null, "string", "Table body font size", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tfootFontSize", null, "string", "Table body font size", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("theadFontColor", null, "html-color", "Table head font color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodyFontColor", null, "html-color", "Table body font color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tfootFontColor", null, "html-color", "Table body font color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("theadFontFamily", null, "string", "Table head font family", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodyFontFamily", null, "string", "Table body font family", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tfootFontFamily", null, "string", "Table body font family", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("theadCellBorderColor", null, "html-color", "Table head cell border color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tfootCellBorderColor", null, "html-color", "Table head cell border color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("theadRowBackgroundColor", null, "html-color", "Table head row color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tfootRowBackgroundColor", null, "html-color", "Table head row color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodyCellBorderColor", null, "html-color", "Table body cell border color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodyRowBackgroundColor", null, "html-color", "Table body row color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodyFirstColFontColor", null, "html-color", "Table body first column font color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodyFirstColBackgroundColor", null, "html-color", "Table body first column background color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodyHoverRowFontColor", null, "html-color", "Table body hover row font color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodyHoverRowBackgroundColor", null, "html-color", "Table body hover row background color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodySelectedRowFontColor", null, "html-color", "Table body selected row color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tbodySelectedRowBackgroundColor", null, "html-color", "Table body selected row color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("tableZebraColor", null, "html-color", "Table zebra row color", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("totalledColumns", [], "array", "Array of indices of the columns to be totalled", null, { tags: ["Basic"], optional: true, disable: function (w) { return w.pivot(); } });
Table.prototype.publish("totalledLabel", null, "string", "Adds a label to the first column of the 'Totalled' row", null, { tags: ["Basic"], optional: true, disable: function (w) { return w.pivot(); } });
Table.prototype.publish("hiddenColumns", [], "array", "Array of indices of the columns to be hidden", null, { tags: ["Basic"], optional: true, disable: function (w) { return w.pivot(); } });
Table.prototype.publish("stringAlign", "left", "set", "Cell alignment for strings", ["left", "right", "center"], { tags: ["Basic"], optional: true });
Table.prototype.publish("numberAlign", "right", "set", "Cell alignment for numbers", ["left", "right", "center"], { tags: ["Basic"], optional: true });
Table.prototype.publish("verticalAlign", null, "set", "Cell vertical alignment", [null, "middle", "top", "bottom"], { tags: ["Basic"], optional: true });
Table.prototype.publish("minWidgetWidth", 320, "number", "Minimum width of a child widget", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("minWidgetHeight", 240, "number", "Minimum height of a child widget", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("sortByFieldIndex", null, "number", "Index for the field/column to sort the data", null, { tags: ["Basic"], optional: true });
Table.prototype.publish("descending", false, "boolean", "Direction for sorting the data: ascending (true) or descending (false)", null, { tags: ["Basic"], optional: true });

var css$6 = ".other_Legend .colorBlock{width:10px;height:10px}.other_Legend>table,.other_Legend>table td,.other_Legend>table th{border-collapse:collapse;border-spacing:0}.other_Table.other_Legend table{border-spacing:0}.labels-wrapper th,.other_Table.other_Legend th{padding:2px 5px;background-color:transparent;border:1px solid transparent;color:#333;white-space:nowrap;cursor:default;font-weight:400;text-align:left}.other_Table.other_Legend tr{background-color:transparent;color:#333}.other_Table.other_Legend .tableDiv tbody>tr:nth-child(odd){background-color:unset;color:#000}.other_Table.other_Legend .tableDiv tbody>tr.hover,.other_Table.other_Legend .tableDiv tbody>tr:hover,.rows-wrapper table tbody tr.hover{background-color:#bfd7e7;color:#fff}.other_Table.other_Legend thead>tr:hover{background-color:transparent}.other_Table.other_Legend tbody>tr.hover,.other_Table.other_Legend tbody>tr:hover,.rows-wrapper tbody tr.hover{background-color:#eee}.other_Table.other_Legend td,.rows-wrapper td{border-width:0;padding:2px 5px;white-space:nowrap;box-sizing:border-box}.other_Legend>.tableDiv>table>tbody>tr:hover{cursor:pointer;color:#000;background-color:#ddd}.other_Legend.horiz-legend .tableDiv{width:100%!important;text-align:left}.other_Legend.horiz-legend .tableDiv>table{display:inline-block;width:100%!important;top:0!important;left:0!important}.other_Legend.horiz-legend tbody,.other_Legend.horiz-legend thead,.other_Legend.horiz-legend tr{display:inline-block}.other_Legend.horiz-legend td,.other_Legend.horiz-legend td>div{display:inline-block;white-space:nowrap}.other_Legend.horiz-legend tr{white-space:nowrap}.other_Legend.horiz-legend tbody{display:inline-block;width:100%!important;text-align:center}";
styleInject(css$6);

function _htmlColorBlock(hexColor) {
    return "<div class=\"colorBlock\" style=\"background-color:" + hexColor + ";\"></div>";
}
var Legend = /** @class */ (function (_super) {
    __extends(Legend, _super);
    function Legend() {
        var _this = _super.call(this) || this;
        _this.showHeader(false);
        _this.pagination(false);
        return _this;
    }
    Legend.prototype.isRainbow = function () {
        var widget = this.getWidget();
        return widget && widget._palette && widget._palette.type() === "rainbow";
    };
    Legend.prototype.targetWidget = function (_) {
        if (!arguments.length)
            return this._targetWidget;
        this._targetWidget = _;
        if (this._targetWidgetMonitor) {
            this._targetWidgetMonitor.remove();
            delete this._targetWidgetMonitor;
        }
        var context = this;
        this._targetWidgetMonitor = this._targetWidget.monitor(function (key, newProp, oldProp, source) {
            switch (key) {
                case "chart":
                case "columns":
                case "data":
                case "paletteID":
                    context.lazyRender();
                    break;
            }
        });
        return this;
    };
    Legend.prototype.getWidget = function () {
        if (this._targetWidget) {
            switch (this._targetWidget.classID()) {
                case "chart_MultiChart":
                    return this._targetWidget.chart();
            }
        }
        return this._targetWidget;
    };
    Legend.prototype.getPalette = function () {
        var widget = this.getWidget();
        if (widget && widget._palette) {
            switch (widget._palette.type()) {
                case "ordinal":
                    return Palette.ordinal(widget._palette.id());
                case "rainbow":
                    return Palette.rainbow(widget._palette.id());
            }
        }
        return Palette.ordinal("default");
    };
    Legend.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        d3Select(domNode.parentNode).style("overflow-y", "auto");
        this.renderHtmlDataCells(true);
        this.fixedHeader(false);
        this.fixedSize(true);
        element.classed("other_Legend", true);
    };
    Legend.prototype.update = function (domNode, element) {
        var colArr = ["Key", "Label"];
        var dataArr = [];
        if (this._targetWidget) {
            var palette_1 = this.getPalette();
            switch (palette_1.type()) {
                case "ordinal":
                    switch (this.dataFamily()) {
                        case "2D":
                            dataArr = this._targetWidget.data().map(function (n) {
                                return [_htmlColorBlock(palette_1(n[0])), n[0]];
                            }, this);
                            break;
                        case "ND":
                            var widgetColumns = this._targetWidget.columns();
                            dataArr = widgetColumns.filter(function (n, i) { return i > 0; }).map(function (n) {
                                return [_htmlColorBlock(palette_1(n)), n];
                            }, this);
                            break;
                    }
                    break;
                case "rainbow":
                    var format$1 = format(this.rainbowFormat());
                    var widget = this.getWidget();
                    var steps = this.rainbowBins();
                    var weightMin = widget._dataMinWeight;
                    var weightMax = widget._dataMaxWeight;
                    var stepWeightDiff = (weightMax - weightMin) / (steps - 1);
                    dataArr.push([_htmlColorBlock(palette_1(weightMin, weightMin, weightMax)), format$1(weightMin)]);
                    for (var x = 1; x < steps - 1; ++x) {
                        var mid = stepWeightDiff * x;
                        dataArr.push([_htmlColorBlock(palette_1(mid, weightMin, weightMax)), format$1(Math.floor(mid))]);
                    }
                    dataArr.push([_htmlColorBlock(palette_1(weightMax, weightMin, weightMax)), format$1(weightMax)]);
                    break;
            }
        }
        this.columns(colArr);
        this.data(dataArr);
        _super.prototype.update.call(this, domNode, element);
        element.classed("horiz-legend", this.orientation() === "horizontal");
        var table = element.select(".tableDiv > table");
        var tableRect = table.node().getBoundingClientRect();
        var elementRect = this._placeholderElement.node().getBoundingClientRect();
        element.select(".tableDiv").style("overflow", "visible");
        var top = elementRect.height / 2 - tableRect.height / 2;
        var left = elementRect.width / 2 - tableRect.width / 2;
        table
            .style("position", "absolute")
            .style("top", top + "px")
            .style("left", left + "px");
        var startIndex = this.pageNumber() - 1;
        var itemsOnPage = this.itemsPerPage();
        var start = startIndex * itemsOnPage;
        var end = startIndex * parseInt(itemsOnPage) + parseInt(itemsOnPage);
        var tData = null;
        if (this.pagination()) {
            tData = this.data().slice(start, end);
        }
        else {
            tData = this.data();
        }
        var rows = this.tbody.selectAll("tr").data(tData);
        var context = this;
        rows
            .on("click", function (d, i) {
            context.onClick(d, i);
        })
            .on("dblclick", function (d, i) {
            context.onDblClick(d, i);
        })
            .on("mouseover", function (d, i) {
            context.onMouseOver(d, i);
        });
    };
    Legend.prototype.exit = function (domNode, element) {
        if (this._targetWidgetMonitor) {
            this._targetWidgetMonitor.remove();
            delete this._targetWidgetMonitor;
        }
        _super.prototype.exit.call(this, domNode, element);
    };
    Legend.prototype.onClick = function (rowData, rowIdx) {
        console.log("Legend onClick method");
        console.log("rowData: " + rowData);
        console.log("rowIdx: " + rowIdx);
    };
    Legend.prototype.onDblClick = function (rowData, rowIdx) {
        console.log("Legend onDblClick method");
        console.log("rowData: " + rowData);
        console.log("rowIdx: " + rowIdx);
    };
    Legend.prototype.onMouseOver = function (rowData, rowIdx) {
        console.log("Legend onMouseOver method");
        console.log("rowData: " + rowData);
        console.log("rowIdx: " + rowIdx);
    };
    return Legend;
}(Table));
Legend.prototype._class += " other_Legend";
Legend.prototype.publish("dataFamily", "ND", "set", "Type of data", ["1D", "2D", "ND", "map", "any", "other"], { tags: ["Private"] });
Legend.prototype.publish("orientation", "vertical", "set", "Orientation of Legend rows", ["vertical", "horizontal"], { tags: ["Private"] });
Legend.prototype.publish("rainbowFormat", ",", "string", "Rainbow number formatting", null, { tags: ["Private"], optional: true, disable: function (w) { return !w.isRainbow(); } });
Legend.prototype.publish("rainbowBins", 8, "number", "Number of rainbow bins", null, { tags: ["Private"], disable: function (w) { return !w.isRainbow(); } });
var origGetBBox = Table.prototype.getBBox;
Legend.prototype.getBBox = function (refresh, round) {
    var retVal = origGetBBox.apply(this, arguments);
    var table = this.element().select(".tableDiv > table");
    if (!table.empty()) {
        var tableRect = table.node().getBoundingClientRect();
        var width = tableRect.width + 8 + (this.hasVScroll(this._placeholderElement) ? Platform.getScrollbarWidth() : 0);
        var height = tableRect.height + 8 + (this.hasHScroll(this._placeholderElement) ? Platform.getScrollbarWidth() : 0);
        return {
            x: retVal.x,
            y: retVal.y,
            width: (round ? Math.round(width) : width) * this._scale,
            height: (round ? Math.round(height) : height) * this._scale
        };
    }
    return retVal;
};

var css$7 = ".other_MorphText .enter{fill:green}.other_MorphText .update{fill:#333}.other_MorphText .exit{fill:brown}";
styleInject(css$7);

var MorphText = /** @class */ (function (_super) {
    __extends(MorphText, _super);
    function MorphText() {
        return _super.call(this) || this;
    }
    MorphText.prototype.enter = function (domNode, element) {
        if (!this.fontSize()) {
            var style = window.getComputedStyle(domNode, null);
            this.fontSize(parseInt(style.fontSize));
        }
        this._fontWidth = this.fontSize() * 32 / 48;
        this._textElement = element.append("g");
    };
    MorphText.prototype.dateTime = function () {
        var d = new Date();
        var seconds = d.getSeconds().toString().length === 1 ? "0" + d.getSeconds() : d.getSeconds();
        var minutes = d.getMinutes().toString().length === 1 ? "0" + d.getMinutes() : d.getMinutes();
        var hours = d.getHours().toString().length === 1 ? "0" + d.getHours() : d.getHours();
        var ampm = d.getHours() >= 12 ? "pm" : "am";
        var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        return days[d.getDay()] + " " + months[d.getMonth()] + " " + d.getDate() + " " + d.getFullYear() + " " + hours + ":" + minutes + ":" + seconds + ampm;
    };
    MorphText.prototype.update = function (domNode, element) {
        var context = this;
        var text = this._textElement.selectAll("text")
            .data(this.data(), function (d) { return d.id; });
        text
            .attr("class", "update");
        this.transition.apply(text)
            .attr("x", function (d, i) { return (-context.data().length / 2 + i) * context._fontWidth + context._fontWidth / 2; });
        var newText = text.enter().append("text")
            .attr("class", "enter")
            .attr("font-size", this.fontSize())
            .attr("dy", ".35em")
            .attr("y", (this.reverse() ? +1 : -1) * this._fontWidth * 2)
            .attr("x", function (d, i) { return (-context.data().length / 2 + i) * context._fontWidth + context._fontWidth / 2; })
            .style("fill-opacity", 1e-6)
            .style("text-anchor", this.anchor())
            .text(function (d) { return d.text; });
        this.transition.apply(newText)
            .attr("y", 0)
            .style("fill-opacity", 1);
        text.exit()
            .attr("class", "exit");
        this.transition.apply(text.exit())
            .attr("y", (this.reverse() ? -1 : +1) * this._fontWidth * 2)
            .style("fill-opacity", 1e-6)
            .remove();
    };
    return MorphText;
}(SVGWidget));
MorphText.prototype._class += " other_MorphText";
MorphText.prototype.publish("anchor", "middle", "set", "Sets anchor point", ["middle"], { tags: ["Basic"] });
MorphText.prototype.publish("fontSize", 14, "number", "Sets fontsize", null, { tags: ["Basic"] });
MorphText.prototype.publish("reverse", false, "boolean", "Reverse Animation", null, { tags: ["Basic"] });
MorphText.prototype.publish("text", "", "string", "Sets text/data of widget", null, { tags: ["Basic"] });
var _origText = MorphText.prototype.text;
MorphText.prototype.text = function (_) {
    var retVal = _origText.apply(this, arguments);
    if (arguments.length) {
        var usedChars_1 = {};
        var chars = _.split("");
        this.data(chars.map(function (d) {
            var id = "_" + d;
            if (usedChars_1[id] === undefined) {
                usedChars_1[id] = 0;
            }
            usedChars_1[id]++;
            return { text: d, id: d.charCodeAt(0) + (1024 * usedChars_1[id]) };
        }));
    }
    return retVal;
};

var NestedTable = /** @class */ (function (_super) {
    __extends(NestedTable, _super);
    function NestedTable() {
        var _this = _super.call(this) || this;
        _this.minWidgetHeight(240);
        _this.minWidgetWidth(360);
        return _this;
    }
    return NestedTable;
}(Table));
NestedTable.prototype._class += " other_NestedTable";
var origColumns = NestedTable.prototype.columns;
NestedTable.prototype.columns = function (_) {
    if (arguments.length) {
        this._columns = _;
        return origColumns.call(this, _.map(function (col) {
            if (typeof col === "object") {
                return col.label;
            }
            return col;
        }));
    }
    return origColumns.apply(this, arguments);
};
var origData = NestedTable.prototype.data;
NestedTable.prototype.data = function (_) {
    if (arguments.length) {
        var context_1 = this;
        return origData.call(this, _.map(function (row) {
            return row.map(function (cell, idx) {
                if (cell instanceof Array) {
                    var columns = [];
                    if (typeof context_1._columns[idx] === "object" && context_1._columns[idx].columns) {
                        columns = context_1._columns[idx].columns;
                    }
                    else {
                        for (var i = 0; i < cell.length; ++i) {
                            columns.push(context_1._columns[idx] + "." + i);
                        }
                    }
                    return new Table()
                        .columns(columns)
                        .data(cell);
                }
                return cell;
            });
        }));
    }
    return origData.apply(this, arguments);
};

var css$8 = ".graph_Opportunity{transform:translate(20px,20px)scale(1)!important}.graph_Opportunity .group{stroke-width:1;stroke:#555;fill:#fefefe}.graph_Opportunity .group_headings{font-family:Helvetica,Arial,sans-serif;font-size:14px;font-weight:700;line-height:20px}.graph_Opportunity .node_prev_rect{fill:#fff;stroke-width:2;stroke:#000;stroke-dasharray:3,3;opacity:.6}.graph_Opportunity .node_rev_change{fill:#fff}.graph_Opportunity .node_rev_change_text{font-size:18px;font-family:Arial;color:#000;font-weight:700}.graph_Opportunity .node_date_change{fill:#fff}.graph_Opportunity .node_date_change_text{font-size:18px;font-family:Arial;color:#000;font-weight:700}.graph_Opportunity .node_prev_text{font-size:9px;font-family:Arial;opacity:.6}.graph_Opportunity .node_cur_rect{stroke-width:2;stroke:#000}.graph_Opportunity .node_cur_text{font-size:9px;font-family:Arial;text-decoration:underline}.graph_Opportunity .arrowhead{refX:6}.graph_Opportunity-tooltip.tooltip{position:absolute;text-align:left;width:350px;height:135px;padding:15px 10px 10px;font:14px arial;background:#bdbdbd;border:0;border-radius:8px;pointer-events:none;z-index:1}";
styleInject(css$8);

var Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    function Column() {
        return _super.call(this) || this;
    }
    Column.prototype.owner = function (_) {
        if (!arguments.length)
            return this._owner;
        this._owner = _;
        return this;
    };
    Column.prototype.valid = function () {
        return !!this.headerLabel();
    };
    return Column;
}(PropertyExt));
Column.prototype._class += " other_Opportunity.Column";
Column.prototype.publish("headerLabel", null, "string", "Header value of a table", function () { return this._owner ? this._owner.columns() : []; }, { tags: ["Basic"], optional: true });
var MouseHoverColumn = /** @class */ (function (_super) {
    __extends(MouseHoverColumn, _super);
    function MouseHoverColumn() {
        return _super.call(this) || this;
    }
    MouseHoverColumn.prototype.owner = function (_) {
        if (!arguments.length)
            return this._owner;
        this._owner = _;
        return this;
    };
    MouseHoverColumn.prototype.valid = function () {
        return !!this.hoverValue() && !!this.hoverList();
    };
    return MouseHoverColumn;
}(PropertyExt));
MouseHoverColumn.prototype._class += " other_Opportunity.MouseHoverColumn";
MouseHoverColumn.prototype.publish("hoverValue", null, "string", "Hover value of a table", function () { return this._owner ? this._owner.columns() : []; }, { tags: ["Basic"], optional: true });
MouseHoverColumn.prototype.publish("hoverList", null, "set", "Hover value of a table", function () { return this._owner ? this._owner.getIds() : []; }, { tags: ["Basic"], optional: true });
var ColumnDropdown = /** @class */ (function (_super) {
    __extends(ColumnDropdown, _super);
    function ColumnDropdown() {
        return _super.call(this) || this;
    }
    ColumnDropdown.prototype.owner = function (_) {
        if (!arguments.length)
            return this._owner;
        this._owner = _;
        return this;
    };
    ColumnDropdown.prototype.valid = function () {
        return !!this.columnIndex() && !!this.ColumnDropdownList();
    };
    return ColumnDropdown;
}(PropertyExt));
ColumnDropdown.prototype._class += " other_Opportunity.ColumnDropdown";
ColumnDropdown.prototype.publish("columnIndex", null, "number", "Column index for display context data based on column dropdown list selction", {}, { tags: ["Basic", "Shared"] });
ColumnDropdown.prototype.publish("ColumnDropdownList", null, "set", "column value of a table", function () { return this._owner ? this._owner.getIds() : []; }, { tags: ["Basic"], optional: true });
var Opportunity = /** @class */ (function (_super) {
    __extends(Opportunity, _super);
    function Opportunity() {
        var _this = _super.call(this) || this;
        _this._drawStartPos = "origin";
        _this.groupCount = 7;
        return _this;
    }
    Opportunity.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        var paddingTop = 30;
        var nodeRectHeight = 14;
        var verticalPadding = 10;
        var h = (this.data().length + 1) * (nodeRectHeight + verticalPadding + 1) + paddingTop;
        this.svg = element.append("g")
            .attr("width", ((this.groupCount * 100) + 1))
            .attr("height", h);
        this.svg.append("defs").append("marker")
            .classed("arrowhead", true)
            .attr("id", "end-arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 6)
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .append("svg:path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "rgb(100,100,100)");
        this.tooltipdiv = d3Select("body").append("div")
            .attr("class", "other_Opportunity-tooltip tooltip")
            .style("opacity", 0);
    };
    Opportunity.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        var context = this;
        var data = this.data();
        var dropDownOption = this.opportunityId();
        data.sort(function (a, b) {
            if (a.cur_group > b.cur_group)
                return 1;
            else if (a.cur_group < b.cur_group)
                return -1;
            else
                return 0;
        });
        var groups = [];
        for (var i = 1; i <= context.groupCount; i++) {
            groups.push(i);
        }
        var paddingTop = 30;
        var nodeRectHeight = 14;
        var verticalPadding = 10;
        var h = (data.length + 1) * (nodeRectHeight + verticalPadding + 1) + paddingTop;
        var w = this.width();
        var nodeRectWidthPadding = 30;
        var nodeRectWidth = ((w / context.groupCount) - nodeRectWidthPadding);
        //  Groups  ---
        var group = this.svg.selectAll(".group").data(groups);
        group.enter().append("rect")
            .attr("class", "group");
        group
            .attr("x", function (d, i) {
            return (i * w / context.groupCount) + 1;
        })
            .attr("y", paddingTop)
            .attr("width", w / this.groupCount)
            .attr("height", h - paddingTop);
        group.exit().remove();
        //  Group Headings  ---
        var groupHeadings = this.svg.selectAll(".group_headings").data(groups);
        groupHeadings.enter().append("text")
            .attr("class", "group_headings")
            .attr("y", 20);
        groupHeadings
            .attr("x", function (d, i) {
            return (i * w / context.groupCount) + ((w / context.groupCount) / context.groupCount);
        })
            .text(function (d, i) {
            if (context.headerLabels().length > 0) {
                if (context.headerLabels()[i] && (context.headerLabels()[i]).headerLabel()) {
                    return (context.headerLabels()[i]).headerLabel();
                }
            }
            return "";
        });
        groupHeadings.exit().remove();
        if (this.previousGroup() === "prev_group" && this.currentGroup() === "cur_group") {
            //  Node Date Change  ---
            var node_date_change = this.svg.selectAll(".node_date_change").data(data);
            node_date_change.enter().append("g")
                .attr("class", "node_date_change update")
                .on("mouseover", function (d) {
                context.tooltipdiv.transition()
                    .duration(200)
                    .style("opacity", 0.9);
                var htmlInput = "<span style='font-weight:bolder'>" + "Close Date Change " + "</span>" + "<br/>";
                var mouseHoverMapping = context.mouseHover();
                mouseHoverMapping.forEach(function (obj, index) {
                    if (obj.hoverValue() !== undefined) {
                        htmlInput = htmlInput + "<span style='font-weight:bold'>" + obj.hoverValue() + ":  " + "</span>" + d[obj.hoverList()] + "<br/>";
                    }
                });
                var prevDate = d.prevdate + "";
                prevDate = prevDate.replace(/(\d\d\d\d)(\d\d)(\d\d)/g, "$3-$2-$1");
                var fromDate = d.curdate + "";
                fromDate = fromDate.replace(/(\d\d\d\d)(\d\d)(\d\d)/g, "$3-$2-$1");
                htmlInput = htmlInput + "<span style='font-weight:bold'>" + "From: " + "</span>" + prevDate + "<br/>" + "<span style='font-weight:bold'>" + "To: " + "</span>" + fromDate + "<br/>";
                context.tooltipdiv.html(htmlInput)
                    .style("left", (event.pageX) + "px")
                    .style("top", (event.pageY - 50) + "px");
            })
                .on("mouseout", function (d) {
                context.tooltipdiv.transition()
                    .duration(500)
                    .style("opacity", 0);
            })
                .each(function (d) {
                var element2 = d3Select(this);
                element2.append("rect")
                    .attr("class", "node_date_change_rect")
                    .attr("width", 5)
                    .attr("height", nodeRectHeight)
                    .attr("rx", 6)
                    .attr("ry", 6);
            });
            node_date_change
                .attr("transform", function (d, i) {
                return "translate(" + ((9 * w / context.groupCount) + (nodeRectWidthPadding) - 80) + "," + ((i + (i * (nodeRectHeight + verticalPadding))) + 12 + paddingTop) + ")";
            });
            node_date_change.exit().remove();
            //  Node Prev Group  ---
            var node_prev_group = this.svg.selectAll(".node_prev_group").data(data);
            node_prev_group.enter().append("g")
                .attr("class", "node_prev_group")
                .on("mouseover", function (d, i) {
                context.tooltipdiv.transition()
                    .duration(200)
                    .style("opacity", 0.9);
                var tooltipHtml = "";
                var mouseHoverMapping = context.mouseHover();
                mouseHoverMapping.forEach(function (obj, index) {
                    if (obj.hoverValue() !== undefined) {
                        tooltipHtml = tooltipHtml + "<span style='font-weight:bold'>" + obj.hoverValue() + ":  " + "</span>" + d[obj.hoverList()] + "<br/>";
                    }
                });
                context.tooltipdiv.html(tooltipHtml)
                    .style("left", (event.pageX) + "px")
                    .style("top", (event.pageY - 100) + "px");
            })
                .on("mouseout", function (d) {
                context.tooltipdiv.transition()
                    .duration(500)
                    .style("opacity", 0);
            })
                .each(function (d) {
                var element2 = d3Select(this);
                element2.append("rect")
                    .attr("class", "node_prev_rect")
                    .attr("rx", 6)
                    .attr("ry", 6);
                element2.append("text")
                    .attr("class", "node_prev_text");
            });
            node_prev_group
                .classed("update", true)
                .classed("changed", function (d) {
                return d.delta !== 0;
            })
                .attr("transform", function (d, i) {
                return "translate(" + ((((d.prev_group - 1)) * w / context.groupCount) + (nodeRectWidthPadding / 2)) + "," + ((i + (i * (nodeRectHeight + verticalPadding))) + 10 + paddingTop) + ")";
            })
                .each(function (d) {
                var element2 = d3Select(this);
                //  Change Lines  ---
                var changeLines = element2.selectAll(".arrow").data(d.delta !== 0 ? [d] : []);
                changeLines.enter().append("line")
                    .attr("class", "arrow update");
                changeLines
                    .attr("x1", function (d2) {
                    return (d2.delta > 0) ? nodeRectWidth : 0;
                })
                    .attr("y1", nodeRectHeight / 2)
                    .attr("x2", function (d2) {
                    return (d2.delta > 0) ? (nodeRectWidth + nodeRectWidthPadding - 4) + ((Math.abs(d2.delta) - 1)) * (w / context.groupCount) : ((-nodeRectWidthPadding - ((Math.abs(d2.delta) - 1)) * (w / context.groupCount)) + 4);
                })
                    .attr("y2", nodeRectHeight / 2)
                    .style("stroke-dasharray", ("3, 3"))
                    .style("stroke", "rgb(100,100,100)")
                    .style("marker-end", "url(#end-arrow)")
                    .style("opacity", "1");
                changeLines.exit().remove();
            });
            var node_previous_rect = node_prev_group.select(".node_prev_rect");
            node_previous_rect
                .attr("width", nodeRectWidth)
                .attr("height", nodeRectHeight);
            var node_previous_text = node_prev_group.select(".node_prev_text");
            node_previous_text
                .attr("dy", (nodeRectHeight / 2) + 3)
                .attr("dx", (nodeRectWidth / 4))
                .text(function (d) {
                if (typeof d[dropDownOption] === "number")
                    return d[dropDownOption];
                else
                    return d[dropDownOption].substring(0, 14);
            });
            node_prev_group.exit().remove();
            //  Node Cur Group  ---
            var node_cur_group = this.svg.selectAll(".node_cur_group").data(data);
            node_cur_group.enter().append("g")
                .attr("class", "node_cur_group")
                .attr("transform", function (d, i) {
                return "translate(" + ((((d.prev_group - 1)) * w / context.groupCount) + (nodeRectWidthPadding / 2)) + "," + ((i + (i * (nodeRectHeight + verticalPadding))) + 10 + paddingTop) + ")";
            })
                .on("mouseover", function (d, i) {
                context.tooltipdiv.transition()
                    .duration(200)
                    .style("opacity", 0.9);
                var tooltipHtml = "";
                var mouseHoverMapping = context.mouseHover();
                mouseHoverMapping.forEach(function (obj, index) {
                    if (obj.hoverValue() !== undefined) {
                        tooltipHtml = tooltipHtml + "<span style='font-weight:bold'>" + obj.hoverValue() + ":  " + "</span>" + d[obj.hoverList()] + "<br/>";
                    }
                });
                context.tooltipdiv.html(tooltipHtml)
                    .style("left", (event.pageX) + "px")
                    .style("top", (event.pageY - 100) + "px");
            })
                .on("mouseout", function (d) {
                context.tooltipdiv.transition()
                    .duration(500)
                    .style("opacity", 0);
            })
                .each(function (d) {
                var element2 = d3Select(this);
                element2.append("rect")
                    .attr("class", "node_cur_rect")
                    .attr("fill", function (d2) {
                    var color;
                    if (d2.delta < 0 || d2.cur_group === 7) {
                        color = "#F78181";
                    }
                    else {
                        color = "#A9F5A9";
                    }
                    return color;
                })
                    .attr("rx", 6)
                    .attr("ry", 6);
                element2.append("a")
                    .append("text")
                    .attr("class", "node_cur_text");
            });
            node_cur_group
                .classed("update", true)
                .classed("changed", function (d) {
                return d.delta !== 0;
            })
                .transition().duration(800)
                .ease("linear")
                .attr("transform", function (d, i) {
                return "translate(" + ((((d.cur_group) - 1) * w / context.groupCount) + (nodeRectWidthPadding / 2)) + "," + ((i + (i * (nodeRectHeight + verticalPadding))) + 10 + paddingTop) + ")";
            })
                .each("end", function () {
                d3SelectAll(".arrow").style("opacity", "1");
            });
            var node_current_anchor = node_cur_group.select(".node_cur_group a");
            node_current_anchor.classed("update", true)
                .attr("xlink:href", function (d) {
                return context.url() + d.id;
            })
                .attr("xlink:show", "new");
            var node_current_rect = node_cur_group.select(".node_cur_rect");
            node_current_rect
                .attr("width", nodeRectWidth)
                .attr("height", nodeRectHeight);
            var node_current_text = node_cur_group.select(".node_cur_text");
            node_current_text
                .classed("update", true)
                .attr("dy", (nodeRectHeight / 2) + 3)
                .attr("dx", (nodeRectWidth / 4))
                .style("fill", "blue")
                .text(function (d) {
                if (typeof d[dropDownOption] === "number")
                    return d[dropDownOption];
                else
                    return d[dropDownOption].substring(0, 14);
            });
            node_cur_group.exit().remove();
        }
        var _loop_1 = function (colIndex) {
            if ((context.columnData()[colIndex]) && (context.columnData()[colIndex]).ColumnDropdownList()) {
                var columnData = this_1.svg.selectAll(".columnDataText_" + colIndex).data(data);
                columnData.enter().append("g")
                    .attr("class", "columnDataText_" + colIndex + " update")
                    .each(function (d) {
                    var element2 = d3Select(this);
                    element2.append("text");
                });
                columnData
                    .attr("transform", function (d, i) {
                    return "translate(" + (((context.columnData()[colIndex]).columnIndex() * w / context.groupCount) + (nodeRectWidthPadding / 2)) + "," + ((i + (i * (nodeRectHeight + verticalPadding))) + 12 + paddingTop) + ")";
                })
                    .attr("width", 5)
                    .attr("height", nodeRectHeight)
                    .attr("rx", 6)
                    .attr("ry", 6);
                var textLable = columnData.select("text");
                textLable
                    .attr("y", -6)
                    .attr("dy", (nodeRectHeight) + 14)
                    .attr("dx", 0)
                    .attr("height", 20)
                    .attr("width", 29)
                    .text(function (d, i) {
                    return d[(context.columnData()[colIndex]).ColumnDropdownList()];
                });
                columnData.exit().remove();
            }
        };
        var this_1 = this;
        for (var colIndex = 0; colIndex < context.columnData().length; colIndex++) {
            _loop_1(colIndex);
        }
    };
    Opportunity.prototype.exit = function (domNode, element) {
        _super.prototype.exit.call(this, domNode, element);
    };
    Opportunity.prototype.getIds = function () {
        var dropdownList = this.columns();
        dropdownList.unshift("default");
        return dropdownList;
    };
    return Opportunity;
}(SVGWidget));
Opportunity.prototype._class += " other_Opportunity";
Opportunity.prototype.Column = Column;
Opportunity.prototype.MouseHoverColumn = MouseHoverColumn;
Opportunity.prototype.ColumnDropdown = ColumnDropdown;
Opportunity.prototype.publish("previousGroup", "", "set", "label in Opportunity", function () { return this.getIds(); }, { tags: ["Basic", "Shared"] });
Opportunity.prototype.publish("currentGroup", "", "set", "label in Opportunity", function () { return this.getIds(); }, { tags: ["Basic", "Shared"] });
Opportunity.prototype.publish("opportunityId", "id", "set", "Id for label in Opportunity", function () { return this.getIds(); }, { tags: ["Basic", "Shared"] });
Opportunity.prototype.publish("url", null, "string", "URL in Opportunity", {}, { tags: ["Basic", "Shared"] });
Opportunity.prototype.publish("width", 1100, "number", "label in Opportunity", {}, { tags: ["Basic", "Shared"] });
Opportunity.prototype.publish("addColumn", null, "string", "number of columns in a table", {}, {
    tags: ["Basic", "Shared"],
    editor_input: function (context, widget, cell, param) {
        cell.append("button")
            .attr("id", context.id() + "_addColumn" + param.id)
            .classed("property-input custom-editor-input addColumn update", true)
            .text("AddColumn")
            .on("click", function () {
            widget.groupCount = widget.groupCount + 1;
            var new_value_after_click = "Added a new column";
            context.setProperty(widget, param.id, new_value_after_click);
        });
    }
});
Opportunity.prototype.publish("removeColumn", null, "string", "number of columns in a table", function () { return this.columns(); }, {
    tags: ["Basic", "Shared"],
    editor_input: function (context, widget, cell, param) {
        cell.append("button")
            .attr("id", context.id() + "_removeColumn" + param.id)
            .classed("property-input custom-editor-input removeColumn update", true)
            .text("RemoveColumn")
            .on("click", function () {
            widget.groupCount = widget.groupCount - 1;
            var new_value_after_click = "Removed a column";
            context.setProperty(widget, param.id, new_value_after_click);
        });
    }
});
Opportunity.prototype.publish("headerLabels", [], "propertyArray", "Source Columns", null, { autoExpand: Column });
Opportunity.prototype.publish("mouseHover", [], "propertyArray", "mouse hover options", null, { autoExpand: MouseHoverColumn });
Opportunity.prototype.publish("columnData", [], "propertyArray", "column data", null, { autoExpand: ColumnDropdown });

function discover(widget) {
    return widget.publishedProperties(false, true);
}
function widgetArrayWalker(widgets, visitor) {
    if (!widgets)
        return;
    widgets.forEach(function (widget) {
        widget.widgetWalker(visitor);
    });
}
function widgetPropertyWalker(widget2, visitor, filter) {
    widget2.widgetWalker(function (widget) {
        widget.propertyWalker(visitor, filter);
    });
}
function serializeTheme(widget, filter) {
    return JSON.stringify(serializeThemeToObject(widget, filter));
}
function serializeThemeToObject(widget2, filter) {
    filter = filter || ["surface", "Color", "Font", "palette"];
    var propObj = {};
    widgetPropertyWalker(widget2, null, function (widget, item) {
        if (widget[item.id + "_modified"]() || widget.publishedProperty(item.id).origDefaultValue !== widget.publishedProperty(item.id).defaultValue) {
            if (_isFilterMatch(item.id, filter)) {
                var classParts = widget._class.trim().split(" ");
                for (var i in classParts) {
                    if (classParts.HasOwnProperty(i)) {
                        if (propObj[classParts[i]] === undefined) {
                            propObj[classParts[i]] = {};
                        }
                        if (propObj[classParts[i]][item.id] === undefined) {
                            propObj[classParts[i]][item.id] = widget[item.id]();
                            break;
                        }
                        else if (propObj[classParts[i]][item.id] === widget[item.id]()) {
                            break;
                        }
                    }
                }
            }
        }
    });
    function _isFilterMatch(str, arr) {
        var ret = false;
        for (var i in arr) {
            if (str.indexOf(arr[i]) !== -1) {
                ret = true;
                break;
            }
        }
        return ret;
    }
    return propObj;
}
function removeTheme(widget2, callback) {
    widgetPropertyWalker(widget2, null, function (widget, item) {
        widget.publishedProperty(item.id).defaultValue = widget.publishedProperty(item.id).origDefaultValue;
    });
    if (typeof (callback) === "function") {
        callback.call(this);
    }
}
function applyTheme(widget2, themeObj, callback) {
    var context = this;
    widgetPropertyWalker(widget2, null, function (widget3, item) {
        switch (item.type) {
            case "widget":
                context.applyTheme(widget3[item.id](), themeObj);
                return true;
            case "widgetArray":
                var widgetArray = widget3[item.id]();
                widgetArray.forEach(function (widget) {
                    context.applyTheme(widget, themeObj);
                }, this);
                return true;
            default:
                widget3.applyTheme(themeObj);
                break;
        }
    });
    if (typeof (callback) === "function") {
        callback.call(this);
    }
}
function serializeToObject(widget, filter, includeData, includeState) {
    var retVal = {
        __class: widget.classID()
    };
    if (widget._id.indexOf(widget._idSeed) !== 0) {
        retVal.__id = widget._id;
    }
    if (widget.version) {
        retVal.__version = widget.version();
    }
    retVal.__properties = {};
    widget.propertyWalker(function (childWwidget2, item) {
        if (childWwidget2[item.id + "_modified"]()) {
            switch (item.type) {
                case "widget":
                    retVal.__properties[item.id] = serializeToObject(childWwidget2[item.id](), null, includeData, includeState && !widget.serializeState); //  Only include state once
                    return true;
                case "widgetArray":
                case "propertyArray":
                    retVal.__properties[item.id] = [];
                    var widgetArray = childWwidget2[item.id]();
                    widgetArray.forEach(function (childWwidget) {
                        retVal.__properties[item.id].push(serializeToObject(childWwidget, null, includeData, includeState && !widget.serializeState)); //  Only include state once
                    });
                    return true;
                default:
                    retVal.__properties[item.id] = childWwidget2[item.id]();
                    break;
            }
        }
    }, filter);
    if (widget.classID() === "marshaller_Graph") {
        var vertices = widget.data().vertices;
        if (vertices) {
            this.__vertices = vertices.map(function (item) {
                return serializeToObject(item, null, includeData, includeState && !widget.serializeState);
            });
        }
    }
    if (includeData && widget.data) {
        if (!retVal.__data)
            retVal.__data = {};
        retVal.__data.data = widget.data();
    }
    if (includeState) {
        if (widget.serializeState) {
            retVal.__state = widget.serializeState();
        }
        else if (widget.data) {
            retVal.__state = {
                data: widget.data()
            };
        }
    }
    return retVal;
}
function serialize$1(widget, filter, includeData, includeState) {
    return JSON.stringify(serializeToObject(widget, filter, includeData, includeState));
}

var Persist = /*#__PURE__*/Object.freeze({
    discover: discover,
    widgetArrayWalker: widgetArrayWalker,
    widgetPropertyWalker: widgetPropertyWalker,
    serializeTheme: serializeTheme,
    serializeThemeToObject: serializeThemeToObject,
    removeTheme: removeTheme,
    applyTheme: applyTheme,
    serializeToObject: serializeToObject,
    serialize: serialize$1
});

var css$9 = ".other_PropertyEditor{overflow-y:scroll;height:100%;width:100%}.other_PropertyEditor .other_PropertyEditor{overflow:hidden}.other_PropertyEditor .property-table{width:100%;border:solid #ddd;border-width:0 0 0 1px}.other_PropertyEditor thead>tr>th{background-color:#333}.other_PropertyEditor .other_PropertyEditor th{background-color:#444}.other_PropertyEditor .other_PropertyEditor .other_PropertyEditor th{background-color:#555}.other_PropertyEditor .other_PropertyEditor .other_PropertyEditor .other_PropertyEditor th{background-color:#666}.other_PropertyEditor .other_PropertyEditor .other_PropertyEditor .other_PropertyEditor .other_PropertyEditor th{background-color:#777}.other_PropertyEditor .headerRow{background-color:#eee}.other_PropertyEditor .other_PropertyEditor .headerRow{background-color:#ddd}.other_PropertyEditor .other_PropertyEditor .other_PropertyEditor .headerRow{background-color:#ccc}.other_PropertyEditor .other_PropertyEditor .other_PropertyEditor .other_PropertyEditor .headerRow{background-color:#bbb}.other_PropertyEditor .other_PropertyEditor .other_PropertyEditor .other_PropertyEditor .other_PropertyEditor .headerRow{background-color:#aaa}.other_PropertyEditor .fa{font-size:14px;width:14px}.other_PropertyEditor div.property-table-collapsed{display:none}.other_PropertyEditor .headerRow>.peInput{padding-top:2px}.other_PropertyEditor .headerRow>.peInput>span{font-weight:700;padding-left:2px}.other_PropertyEditor .headerRow>.peInput>i{float:right;padding-top:2px;padding-bottom:2px}.other_PropertyEditor .headerRow>span>i:hover{background-color:#555;cursor:pointer}.other_PropertyEditor .property-table thead>tr>th{text-align:left;background-color:#333;color:#fff;padding-top:2px;padding-left:4px}.other_PropertyEditor .property-table thead>tr>th>i{float:right;padding-top:2px;padding-right:4px;padding-bottom:2px}.other_PropertyEditor .property-table thead>tr>th>i:hover{background-color:#555;cursor:pointer}.other_PropertyEditor .property-table tbody>tr:nth-child(2n){background-color:#f9f9f9}.other_PropertyEditor .property-table tbody>tr:nth-child(odd){background-color:#fff}.other_PropertyEditor .property-table tbody>tr>td{text-align:left;color:#333;padding:0 0 0 2px}.other_PropertyEditor .property-table tbody>tr.disabled>td{color:grey}.other_PropertyEditor .property-table tbody>tr.invalid>td{color:red}.other_PropertyEditor .property-input-cell>div{padding-left:8px}.other_PropertyEditor .property-label{padding-right:4px;box-sizing:border-box;height:20px}.other_PropertyEditor td.property-input-cell{text-align:left;height:20px;padding:1px 0;width:80%}.other_PropertyEditor .property-input-cell>input,.other_PropertyEditor .property-input-cell>textarea{width:100%;box-sizing:border-box}.other_PropertyEditor .property-input-cell>input{height:20px}.other_PropertyEditor .property-input-cell>textarea{height:120px}.other_PropertyEditor .property-input-cell.boolean-cell{width:auto;margin:0;position:relative}.other_PropertyEditor .property-input-cell>input[type=checkbox]{width:auto;margin:0;position:absolute;top:0}.other_PropertyEditor .html-color-cell>input{width:80%}.other_PropertyEditor .html-color-cell>input[type=color]{width:20%;position:relative;top:-1px}";
styleInject(css$9);

function hasProperties(type) {
    switch (type) {
        case "widget":
        case "widgetArray":
        case "propertyArray":
            return true;
        default:
    }
    return false;
}
var PropertyEditor = /** @class */ (function (_super) {
    __extends(PropertyEditor, _super);
    function PropertyEditor() {
        var _this = _super.call(this) || this;
        _this._childPE = local();
        _this._show_header = true;
        _this.watchDepth = 0;
        _this._parentPropertyEditor = null;
        _this._tag = "div";
        _this._show_settings = false;
        return _this;
    }
    PropertyEditor.prototype.parentPropertyEditor = function (_) {
        if (!arguments.length)
            return this._parentPropertyEditor;
        this._parentPropertyEditor = _;
        return this;
    };
    PropertyEditor.prototype.depth = function () {
        var retVal = 0;
        var parent = this.parentPropertyEditor();
        while (parent) {
            ++retVal;
            parent = parent.parentPropertyEditor();
        }
        return retVal;
    };
    PropertyEditor.prototype.show_header = function (_) {
        if (!arguments.length) {
            return this._show_header;
        }
        this._show_header = _;
        return this;
    };
    PropertyEditor.prototype.show_settings = function (_) {
        if (!arguments.length) {
            return this._show_settings;
        }
        this._show_settings = _;
        return this;
    };
    PropertyEditor.prototype.rootWidgets = function () {
        if (this._selectedItems && this._selectedItems.length) {
            return this._selectedItems;
        }
        return this.show_settings() ? [this] : this.widget() ? [this.widget()] : [];
    };
    PropertyEditor.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        var context = this;
        var rootWidgets = this.rootWidgets().filter(function (w) {
            if (w._owningWidget && w._owningWidget.excludeObjs instanceof Array) {
                if (w._owningWidget.excludeObjs.indexOf(w.classID()) !== -1) {
                    return false;
                }
            }
            return true;
        });
        var table = element.selectAll("table.property-table.table-" + this.depth()).data(rootWidgets, function (d) {
            //  We reuse the existing DOM Nodes and this node _might_ have been a regular Input previously  ---
            if (typeof d.id !== "function") {
                return "meta-" + d.id;
            }
            return d.id();
        });
        table.enter().append("table")
            .attr("class", "property-table table-" + this.depth())
            .each(function () {
            var tableElement = d3Select(this);
            //  Header  ---
            if (context._show_header && context.parentPropertyEditor() === null) {
                tableElement.append("thead").append("tr").append("th") // .datum(tableElement)
                    .attr("colspan", "2")
                    .each(function () {
                    context.enterHeader(d3Select(this));
                });
            }
            //  Body  ---
            tableElement.append("tbody");
        })
            .merge(table)
            .each(function (tableData) {
            var tableElement = d3Select(this);
            //  Header  ---
            if (context._show_header && context.parentPropertyEditor() === null) {
                context.updateHeader(tableElement.select("thead > tr > th"));
            }
            //  Body  ---
            context.renderInputs(tableElement.select("tbody"), tableData);
        });
        table.exit()
            .each(function () {
            context.renderInputs(element.select("tbody"), null);
        })
            .remove();
    };
    PropertyEditor.prototype.exit = function (domNode, element) {
        _super.prototype.exit.call(this, domNode, element);
        this.watchWidget(null);
    };
    PropertyEditor.prototype.watchWidget = function (widget) {
        if (this._watch) {
            if (window.__hpcc_debug) {
                --this.watchDepth;
                console.log("watchDepth:  " + this.watchDepth);
            }
            this._watch.remove();
            delete this._watch;
        }
        if (widget) {
            var context_1 = this;
            this._watch = widget.monitor(function (_paramId, newVal, oldVal) {
                if (oldVal !== newVal) {
                    var propEditor = context_1.parentPropertyEditor() || context_1;
                    propEditor.lazyRender();
                }
            });
            if (window.__hpcc_debug) {
                ++this.watchDepth;
                console.log("watchDepth:  " + this.watchDepth);
            }
        }
    };
    PropertyEditor.prototype.enterHeader = function (th) {
        var context = this;
        th.append("span");
        th.append("i")
            .attr("class", "expandIcon fa")
            .on("click", function () {
            switch (context.peInputIcon()) {
                case "fa-caret-up":
                case "fa-caret-right":
                    context.element().selectAll(".table-" + context.depth() + " > tbody > tr > .headerRow > .peInput > .property-table-collapsed")
                        .classed("property-table-collapsed", false);
                    context.element().selectAll(".table-" + context.depth() + " > tbody > tr > .headerRow > .peInput > i")
                        .classed("fa-minus-square-o", true)
                        .classed("fa-plus-square-o", false);
                    break;
                case "fa-caret-down":
                    context.element().selectAll(".table-" + context.depth() + " > tbody > tr > .headerRow > .peInput > div")
                        .classed("property-table-collapsed", true);
                    context.element().selectAll(".table-" + context.depth() + " > tbody > tr > .headerRow > .peInput > i")
                        .classed("fa-minus-square-o", false)
                        .classed("fa-plus-square-o", true);
                    break;
            }
            context.refreshExpandIcon();
        });
        var sortIcon = th.append("i")
            .attr("class", "sortIcon fa")
            .on("click", function () {
            context.refreshSortIcon(sortIcon, true);
        });
        th.append("i")
            .attr("class", "hideParamsIcon fa")
            .on("click", function () {
            context.hideNonWidgets(!context.hideNonWidgets()).render();
        });
    };
    PropertyEditor.prototype.updateHeader = function (th) {
        var widget = this.widget();
        var spanText = "";
        if (widget) {
            if (widget.label) {
                spanText += widget.label();
            }
            if (widget.classID) {
                if (spanText) {
                    spanText += " - ";
                }
                spanText += widget.classID();
            }
        }
        th.select("span")
            .text(spanText);
        this.refreshExpandIcon();
        this.refreshSortIcon(th.select(".sortIcon"));
        this.refreshHideParamsIcon(th.select(".hideParamsIcon"));
    };
    PropertyEditor.prototype.peInputCount = function () {
        return this.element().selectAll(".table-" + this.depth() + " > tbody > tr > .headerRow > .peInput > div").size();
    };
    PropertyEditor.prototype.peInputCollapsedCount = function () {
        return this.element().selectAll(".table-" + this.depth() + " > tbody > tr > .headerRow > .peInput > div.property-table-collapsed").size();
    };
    PropertyEditor.prototype.peInputIcon = function () {
        var collapsed = this.peInputCollapsedCount();
        if (collapsed === 0) {
            return "fa-caret-down";
        }
        else if (collapsed === this.peInputCount()) {
            return "fa-caret-up";
        }
        return "fa-caret-right";
    };
    PropertyEditor.prototype.refreshExpandIcon = function () {
        var newIcon = this.peInputIcon();
        this.element().select(".table-" + this.depth() + " > thead > tr > th > .expandIcon")
            .classed("fa-caret-up", false)
            .classed("fa-caret-right", false)
            .classed("fa-caret-down", false)
            .classed(newIcon, true);
    };
    PropertyEditor.prototype.refreshSortIcon = function (sortIcon, increment) {
        if (increment === void 0) { increment = false; }
        var sort = this.sorting();
        var types = this.sorting_options();
        var icons = this.__meta_sorting.ext.icons;
        if (increment) {
            sortIcon.classed(icons[types.indexOf(sort)], false);
            this.sorting(types[(types.indexOf(sort) + 1) % types.length]).render();
        }
        else {
            sortIcon
                .classed(icons[(types.indexOf(sort)) % types.length], true)
                .attr("title", sort);
        }
    };
    PropertyEditor.prototype.refreshHideParamsIcon = function (hideParamsIcon) {
        hideParamsIcon
            .classed("fa-eye", !this.hideNonWidgets())
            .classed("fa-eye-slash", this.hideNonWidgets());
    };
    PropertyEditor.prototype.gatherDataTree = function (widget) {
        if (!widget)
            return null;
        var retVal = {
            label: widget.id() + " (" + widget.classID() + ")",
            children: []
        };
        var arr2 = discover(widget);
        arr2.forEach(function (prop) {
            var node = {
                label: prop.id,
                children: []
            };
            switch (prop.type) {
                case "widget":
                    node.children.push(this.gatherDataTree(widget[prop.id]()));
                    break;
                case "widgetArray":
                case "propertyArray":
                    var arr = widget[prop.id]();
                    if (arr) {
                        arr.forEach(function (item) {
                            node.children.push(this.gatherDataTree(item));
                        }, this);
                    }
                    break;
                default:
            }
            retVal.children.push(node);
        }, this);
        return retVal;
    };
    PropertyEditor.prototype.getDataTree = function () {
        return this.gatherDataTree(this.widget());
    };
    PropertyEditor.prototype._rowSorting = function (paramArr) {
        if (this.sorting() === "type") {
            var typeOrder_1 = ["boolean", "number", "string", "html-color", "array", "object", "widget", "widgetArray", "propertyArray"];
            paramArr.sort(function (a, b) {
                if (a.type === b.type) {
                    return a.id < b.id ? -1 : 1;
                }
                else {
                    return typeOrder_1.indexOf(a.type) < typeOrder_1.indexOf(b.type) ? -1 : 1;
                }
            });
        }
        else if (this.sorting() === "A-Z") {
            paramArr.sort(function (a, b) { return a.id < b.id ? -1 : 1; });
        }
        else if (this.sorting() === "Z-A") {
            paramArr.sort(function (a, b) { return a.id > b.id ? -1 : 1; });
        }
    };
    PropertyEditor.prototype.filterInputs = function (d) {
        var discArr = discover(d);
        if ((this.filterTags() || this.excludeTags().length > 0 || this.excludeParams.length > 0) && d instanceof PropertyEditor === false) {
            var context_2 = this;
            return discArr.filter(function (param, _idx) {
                if (d[param.id + "_hidden"] && d[param.id + "_hidden"]())
                    return false;
                for (var _i = 0, _a = context_2.excludeParams(); _i < _a.length; _i++) {
                    var excludeParamItem = _a[_i];
                    var arr = excludeParamItem.split(".");
                    var widgetName = void 0;
                    var excludeParam = void 0;
                    if (arr.length > 2) {
                        widgetName = arr[0];
                        excludeParam = arr[2];
                    }
                    else {
                        widgetName = arr[0];
                        excludeParam = arr[1];
                    }
                    if (d.class().indexOf(widgetName) !== -1) {
                        if (param.id === excludeParam) {
                            return false;
                        }
                        return true;
                    }
                }
                if (context_2.excludeTags().length > 0 && param.ext && param.ext.tags && param.ext.tags.some(function (item) { return (context_2.excludeTags().indexOf(item) > -1); })) {
                    return false;
                }
                if ((context_2.filterTags() && param.ext && param.ext.tags && param.ext.tags.indexOf(context_2.filterTags()) !== -1) || !context_2.filterTags()) {
                    return true;
                }
                return false;
            });
        }
        return discArr;
    };
    PropertyEditor.prototype.renderInputs = function (element, d) {
        var context = this;
        var discArr = [];
        var showFields = !this.show_settings() && this.showFields();
        if (d) {
            discArr = this.filterInputs(d).filter(function (prop) { return prop.id !== "fields" ? true : showFields; });
            if (!this.show_settings() && this.showData() && d.data) {
                discArr.push({ id: "data", type: "array" });
            }
            if (this.hideNonWidgets()) {
                discArr = discArr.filter(function (n) {
                    return hasProperties(n.type);
                });
            }
            this._rowSorting(discArr);
        }
        var rows = element.selectAll("tr.prop" + this.id()).data(discArr, function (d2) { return d2.id; });
        rows.enter().append("tr")
            .attr("class", "property-wrapper prop" + this.id())
            .each(function (param) {
            var tr = d3Select(this);
            if (hasProperties(param.type)) {
                tr.classed("property-widget-wrapper", true);
                tr.append("td")
                    .attr("colspan", "2");
            }
            else {
                tr.classed("property-input-wrapper", true);
                tr.append("td")
                    .classed("property-label", true)
                    .text(param.id);
                var inputCell = tr.append("td")
                    .classed("property-input-cell", true);
                context.enterInputs(d, inputCell, param);
            }
        }).merge(rows)
            .each(function (param) {
            var tr = d3Select(this);
            tr.classed("disabled", d[param.id + "_disabled"] && d[param.id + "_disabled"]());
            tr.classed("invalid", d[param.id + "_valid"] && !d[param.id + "_valid"]());
            tr.attr("title", param.description);
            if (hasProperties(param.type)) {
                context.updateWidgetRow(d, tr.select("td"), param);
            }
            else {
                context.updateInputs(d, param);
            }
        });
        rows.exit().each(function (param) {
            var tr = d3Select(this);
            if (hasProperties(param.type)) {
                context.updateWidgetRow(d, tr.select("td"), null);
            }
        }).remove();
        rows.order();
    };
    PropertyEditor.prototype.updateWidgetRow = function (widget, element, param) {
        var tmpWidget = [];
        if (widget && param) {
            tmpWidget = widget[param.id]() || [];
        }
        var widgetArr = tmpWidget instanceof Array ? tmpWidget : [tmpWidget];
        if (param && param.ext && param.ext.autoExpand) {
            //  remove empties and ensure last row is an empty  ---
            var lastModified_1 = true;
            var noEmpties = widgetArr.filter(function (row, idx) {
                lastModified_1 = row.valid();
                row._owner = widget;
                return lastModified_1 || idx === widgetArr.length - 1;
            }, this);
            var widgetDisabled = widget[param.id + "_disabled"] && widget[param.id + "_disabled"]();
            var changed = !!(widgetArr.length - noEmpties.length);
            if (lastModified_1 && !widgetDisabled) {
                changed = true;
                var autoExpandWidget = new param.ext.autoExpand()
                    .owner(widget);
                // autoExpandWidget.monitor((id, newVal, oldVal, source) => {
                // widget.broadcast(param.id, newVal, oldVal, source);
                // });
                noEmpties.push(autoExpandWidget);
            }
            if (changed) {
                widget[param.id](noEmpties);
                widgetArr = noEmpties;
            }
        }
        var context = this;
        element.classed("headerRow", true);
        var peInput = element.selectAll("div.peInput-" + this.depth()).data(widgetArr, function (d) { return d.id(); });
        peInput.enter().append("div")
            .attr("class", "peInput peInput-" + this.depth())
            .each(function (w) {
            var peInputElement = d3Select(this);
            //  Header  ---
            peInputElement.append("span");
            peInputElement.append("i")
                .attr("class", "fa")
                .on("click", function (d) {
                var clickTarget = peInputElement.select("div");
                clickTarget
                    .classed("property-table-collapsed", !clickTarget.classed("property-table-collapsed"));
                d3Select(this)
                    .classed("fa-minus-square-o", !clickTarget.classed("property-table-collapsed"))
                    .classed("fa-plus-square-o", clickTarget.classed("property-table-collapsed"));
                context.refreshExpandIcon();
            });
            //  Body  ---
            var peDiv = peInputElement.append("div");
            context._childPE.set(this, new PropertyEditor().label(param.id).target(peDiv.node()));
        })
            .merge(peInput)
            .each(function (w) {
            var peInputElement = d3Select(this);
            var clickTarget = peInputElement.select("div");
            //  Header  ---
            d3Select(this).select("span")
                .text("" + param.id);
            d3Select(this).select("i")
                .classed("fa-minus-square-o", !clickTarget.classed("property-table-collapsed"))
                .classed("fa-plus-square-o", clickTarget.classed("property-table-collapsed"));
            //  Body  ---
            context._childPE.get(this)
                .parentPropertyEditor(context)
                .showFields(context.showFields())
                .showData(context.showData())
                .sorting(context.sorting())
                .filterTags(context.filterTags())
                .excludeTags(context.excludeTags())
                .excludeParams(context.excludeParams())
                .hideNonWidgets(context.hideNonWidgets() && w._class.indexOf("layout_") >= 0)
                .widget(w)
                .render();
        });
        peInput.exit()
            .each(function (w) {
            context._childPE.get(this)
                .widget(null)
                .render()
                .target(null);
            context._childPE.remove(this);
        })
            .remove();
    };
    PropertyEditor.prototype.setProperty = function (widget, id, value) {
        //  With PropertyExt not all "widgets" have a render, if not use top most render...
        var topWidget;
        var topPropEditor;
        var propEditor = this;
        var oldValue;
        while (propEditor && widget) {
            if (propEditor === this) {
                oldValue = widget[id]();
                widget[id](value);
            }
            if (propEditor) {
                topPropEditor = propEditor;
                var w = propEditor.widget();
                if (w instanceof Widget) {
                    topWidget = w;
                }
            }
            propEditor = propEditor.parentPropertyEditor();
        }
        if (topWidget) {
            topWidget.render();
        }
        if (topPropEditor) {
            topPropEditor.broadcast(id, value, oldValue, widget);
        }
    };
    PropertyEditor.prototype.enterInputs = function (widget, cell, param) {
        cell.classed(param.type + "-cell", true);
        var context = this;
        if (typeof (param.ext.editor_input) === "function") {
            param.ext.editor_input(this, widget, cell, param);
        }
        switch (param.type) {
            case "boolean":
                cell.append("input")
                    .attr("id", this.id() + "_" + param.id)
                    .classed("property-input", true)
                    .attr("type", "checkbox")
                    .on("change", function () {
                    context.setProperty(widget, param.id, this.checked);
                });
                break;
            case "set":
                cell.append("select")
                    .attr("id", this.id() + "_" + param.id)
                    .classed("property-input", true)
                    .on("change", function () {
                    context.setProperty(widget, param.id, this.value);
                });
                break;
            case "array":
            case "object":
                cell.append("textarea")
                    .attr("id", this.id() + "_" + param.id)
                    .classed("property-input", true)
                    .attr("autocomplete", "off")
                    .attr("autocorrect", "off")
                    .attr("autocapitalize", "off")
                    .attr("spellcheck", "false")
                    .on("change", function () {
                    var value;
                    try {
                        value = JSON.parse(this.value);
                    }
                    catch (e) {
                        value = this.value;
                    }
                    context.setProperty(widget, param.id, value);
                });
                break;
            default:
                if (param.ext && param.ext.range) {
                    cell.append("span")
                        .classed("property-input-span", true)
                        .attr("id", this.id() + "_" + param.id + "_currentVal")
                        .text(param.defaultValue);
                    cell.append("input")
                        .attr("type", "range")
                        .attr("step", param.ext.range.step)
                        .attr("min", param.ext.range.min)
                        .attr("max", param.ext.range.max)
                        .attr("id", this.id() + "_" + param.id)
                        .classed("property-input", true)
                        .on("input", function () {
                        context.setProperty(widget, param.id, this.value);
                        d3Select("#" + this.id + "_currentVal").text("Current Value: " + this.value);
                    })
                        .on("change", function () {
                        context.setProperty(widget, param.id, this.value);
                        d3Select("#" + this.id + "_currentVal").text("Current Value: " + this.value);
                    });
                }
                else {
                    cell.append(param.ext && param.ext.multiline ? "textarea" : "input")
                        .attr("id", this.id() + "_" + param.id)
                        .classed("property-input", true)
                        .attr("autocomplete", "off")
                        .attr("autocorrect", "off")
                        .attr("autocapitalize", "off")
                        .attr("spellcheck", "false")
                        .on("change", function () {
                        context.setProperty(widget, param.id, this.value);
                    });
                    if (param.type === "html-color" && !Platform.isIE) {
                        cell.append("input")
                            .attr("id", this.id() + "_" + param.id + "_2")
                            .classed("property-input", true)
                            .attr("type", "color")
                            .on("change", function () {
                            context.setProperty(widget, param.id, this.value);
                        });
                    }
                }
                break;
        }
    };
    PropertyEditor.prototype.updateInputs = function (widget, param) {
        var element = d3SelectAll("#" + this.id() + "_" + param.id + ", #" + this.id() + "_" + param.id + "_2");
        var val = widget ? widget[param.id]() : "";
        element.property("disabled", widget[param.id + "_disabled"] && widget[param.id + "_disabled"]());
        element.property("invalid", widget[param.id + "_valid"] && !widget[param.id + "_valid"]());
        switch (param.type) {
            case "boolean":
                element.property("checked", val);
                break;
            case "set":
                var options = element.selectAll("option").data(widget[param.id + "_options"]());
                options.enter().append("option")
                    .merge(options)
                    .attr("value", function (d) { return (d && d.value !== undefined) ? d.value : d; })
                    .text(function (d) { return (d && d.text !== undefined) ? d.text : d; });
                options.exit().remove();
                element.property("value", val);
                break;
            case "array":
            case "object":
                element.property("value", JSON.stringify(val, function replacer(_key, value) {
                    if (value instanceof Widget) {
                        return serialize$1(value);
                    }
                    return value;
                }, "    "));
                break;
            default:
                if (param.ext && param.ext.range) {
                    d3Select("#" + this.id() + "_" + param.id + "_currentVal").text("Current Value: " + val);
                }
                element.property("value", val && val.length && val.length > 100000 ? "...too big to display..." : val);
                break;
        }
    };
    return PropertyEditor;
}(HTMLWidget));
PropertyEditor.prototype._class += " other_PropertyEditor";
PropertyEditor.prototype.publish("showFields", false, "boolean", "If true, widget.fields() will display as if it was a publish parameter.", null, { tags: ["Basic"] });
PropertyEditor.prototype.publish("showData", false, "boolean", "If true, widget.data() will display as if it was a publish parameter.", null, { tags: ["Basic"] });
PropertyEditor.prototype.publish("sorting", "none", "set", "Specify the sorting type", ["none", "A-Z", "Z-A", "type"], { tags: ["Basic"], icons: ["fa-sort", "fa-sort-alpha-asc", "fa-sort-alpha-desc", "fa-sort-amount-asc"] });
PropertyEditor.prototype.publish("hideNonWidgets", false, "boolean", "Hides non-widget params (at this tier only)", null, { tags: ["Basic"] });
PropertyEditor.prototype.publish("label", "", "string", "Label to display in header of property editor table", null, { tags: ["Basic"] });
PropertyEditor.prototype.publish("filterTags", "", "set", "Only show Publish Params of this type", ["Basic", "Intermediate", "Advance", ""], {});
PropertyEditor.prototype.publish("excludeTags", ["Private"], "array", "Exclude this array of tags", null, {});
PropertyEditor.prototype.publish("excludeParams", [], "array", "Exclude this array of params (widget.param)", null, {});
PropertyEditor.prototype.publish("widget", null, "widget", "Widget", null, { tags: ["Basic"], render: false });
var _widgetOrig = PropertyEditor.prototype.widget;
PropertyEditor.prototype.widget = function (_) {
    if (arguments.length && _widgetOrig.call(this) === _)
        return this;
    var retVal = _widgetOrig.apply(this, arguments);
    if (arguments.length) {
        this.watchWidget(_);
        if (_ instanceof Grid) {
            var context_3 = this;
            _.postSelectionChange = function () {
                context_3._selectedItems = _._selectionBag.get().map(function (item) { return item.widget; });
                context_3.lazyRender();
            };
        }
    }
    return retVal;
};

var css$a = ".other_RadioCheckbox label,.other_RadioCheckbox span{vertical-align:top}";
styleInject(css$a);

var RadioCheckbox = /** @class */ (function (_super) {
    __extends(RadioCheckbox, _super);
    function RadioCheckbox() {
        return _super.call(this) || this;
    }
    RadioCheckbox.prototype.rcData = function () {
        if (this.data().length === 0)
            return [];
        var view = this._db.rollupView([this.textColumn(), this.valueColumn()]);
        var retVal = [];
        retVal = retVal.concat(view.entries().map(function (row) {
            return {
                text: row.key,
                value: row.values.length ? row.values[0].key : "",
                origRow: row.values.length && row.values[0].values.length ? row.values[0].values[0] : []
            };
        }, this));
        if (this.sort_exists()) {
            var descending_1 = this.sort() === "descending";
            retVal.sort(function (l, r) {
                if (l.text < r.text)
                    return descending_1 ? 1 : -1;
                if (l.text > r.text)
                    return descending_1 ? -1 : 1;
                return 0;
            });
        }
        return retVal;
    };
    RadioCheckbox.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        this._span = element.append("span");
        this._label = this._span.append("label")
            .attr("for", this.id() + "_radioCheckbox");
        this._Checkbox = this._span.append("div")
            .attr("id", this.id() + "_radioCheckbox");
    };
    RadioCheckbox.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        var context = this;
        this._label
            .text(this.label());
        var radioCheckbox = this._Checkbox.selectAll(".dataRow").data(this.rcData());
        radioCheckbox.enter().append("div")
            .attr("class", "dataRow")
            .each(function (row, idx) {
            var checkboxDiv = d3Select(this);
            var id = context.id() + "_checkbox_" + idx;
            checkboxDiv.append("input")
                .attr("id", id)
                .attr("name", context.id() + "_radioCheckbox")
                .on("change", function (selectedData) {
                context.handleClick();
            });
            checkboxDiv.append("label")
                .attr("for", id);
        });
        radioCheckbox
            .each(function (row, idx) {
            var rcDiv = d3Select(this);
            rcDiv.select("input")
                .attr("type", context.multiple() ? "checkbox" : "radio")
                .attr("value", row.value);
            rcDiv.select("label")
                .text(row.text);
        });
        radioCheckbox.exit().remove();
        radioCheckbox.order();
    };
    RadioCheckbox.prototype.exit = function (domNode, element) {
        this._span.remove();
        _super.prototype.exit.call(this, domNode, element);
    };
    RadioCheckbox.prototype.handleClick = function () {
        var options = [];
        this._Checkbox.selectAll(".dataRow > input")
            .each(function (row, idx) {
            var input = d3Select(this);
            if (input.property("checked") && row && row.origRow) {
                options.push(row.origRow);
            }
        });
        if (options.length) {
            //  TODO Handle Multiple Selections - part of 1.16.x
            this.click(this.rowToObj(options[0]), this.valueColumn(), true);
        }
        else {
            this.click([], this.valueColumn(), false);
        }
    };
    RadioCheckbox.prototype.click = function (row, column, selected) {
        console.log("Click:  " + JSON.stringify(row) + ", " + column + ", " + selected);
    };
    return RadioCheckbox;
}(HTMLWidget));
RadioCheckbox.prototype._class += " other_RadioCheckbox";
RadioCheckbox.prototype.publish("label", null, "string", "Label for RadioCheckbox");
RadioCheckbox.prototype.publish("valueColumn", null, "set", "RadioCheckbox display value", function () { return this.columns(); }, { optional: true });
RadioCheckbox.prototype.publish("textColumn", null, "set", "RadioCheckbox value(s)", function () { return this.columns(); }, { optional: true });
RadioCheckbox.prototype.publish("sort", null, "set", "Sort contents", ["", "ascending", "descending"], { optional: true });
RadioCheckbox.prototype.publish("multiple", false, "boolean", "Multiple selection");

var css$b = ".other_Select label,.other_Select span{vertical-align:top}";
styleInject(css$b);

var Select = /** @class */ (function (_super) {
    __extends(Select, _super);
    function Select() {
        return _super.call(this) || this;
    }
    Select.prototype.selectData = function () {
        if (this.data().length === 0)
            return [];
        var view = this._db.rollupView([this.textColumn(), this.valueColumn()]);
        var retVal = [];
        retVal = retVal.concat(view.entries().map(function (row) {
            return {
                text: row.key,
                value: row.values.length ? row.values[0].key : "",
                origRow: row.values.length && row.values[0].value.length ? row.values[0].value[0] : []
            };
        }, this));
        if (this.sort_exists()) {
            var descending_1 = this.sort() === "descending";
            retVal.sort(function (l, r) {
                if (l.text < r.text)
                    return descending_1 ? 1 : -1;
                if (l.text > r.text)
                    return descending_1 ? -1 : 1;
                return 0;
            });
        }
        if (this.optional()) {
            retVal.unshift({ value: "", text: "" });
        }
        return retVal;
    };
    Select.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        this._span = element.append("span");
        this._prompt = this._span.append("label")
            .attr("for", this.id() + "_select");
        var context = this;
        this._select = this._span.append("select")
            .attr("id", this.id() + "_select")
            .on("change", function (d) {
            var options = [];
            var options_dom_node = context._select.node().options;
            for (var i = 0; i < options_dom_node.length; ++i) {
                var optionNode = options_dom_node[i];
                if (optionNode.selected) {
                    options.push(d3Select(optionNode).datum().origRow);
                }
            }
            if (options.length) {
                context.click(context.rowToObj(options[0]), context.valueColumn(), true); // TODO:  Multiselect not support in HIPIE
            }
            else {
                context.click([], context.valueColumn(), false);
            }
        });
    };
    Select.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        this._prompt
            .text(this.label());
        this._select
            .attr("multiple", this.multiple() ? this.multiple() : null)
            .attr("size", this.multiple() && this.selectSize() ? this.selectSize() : null);
        var option = this._select.selectAll(".dataRow").data(this.selectData());
        var optionUpdate = option.enter().append("option")
            .attr("class", "dataRow")
            .merge(option)
            .attr("value", function (row) { return row.value; })
            .text(function (row) { return row.text; });
        option.exit().remove();
        optionUpdate.order();
    };
    Select.prototype.exit = function (domNode, element) {
        this._span.remove();
        _super.prototype.exit.call(this, domNode, element);
    };
    Select.prototype.click = function (row, column, selected) {
        console.log("Click:  " + JSON.stringify(row) + ", " + column + ", " + selected);
    };
    return Select;
}(HTMLWidget));
Select.prototype._class += " other_Select";
Select.prototype.publish("label", null, "string", "Label for select");
Select.prototype.publish("valueColumn", null, "set", "Select display value", function () { return this.columns(); }, { optional: true });
Select.prototype.publish("textColumn", null, "set", "Select value(s)", function () { return this.columns(); }, { optional: true });
Select.prototype.publish("optional", true, "boolean", "Optional Select");
Select.prototype.publish("sort", null, "set", "Sort contents", ["", "ascending", "descending"], { optional: true });
Select.prototype.publish("multiple", false, "boolean", "Multiple selection");
Select.prototype.publish("selectSize", 5, "number", "Size of multiselect box", null, { disable: function (w) { return !w.multiple(); } });

var css$c = ".other_ThemeEditor *{box-sizing:border-box}.other_ThemeEditor table{width:100%;margin-bottom:4px}.other_ThemeEditor table:last-child{margin-bottom:0}.other_ThemeEditor thead>tr>th{text-align:left}.other_ThemeEditor thead>tr>th>b{font-weight:700}.other_ThemeEditor thead>tr>th{background-color:#fafafa}.other_ThemeEditor tbody>tr>td,.other_ThemeEditor tbody>tr>th{font-weight:400;background-color:#fafafa}.other_ThemeEditor thead>tr:first-child>th{background-color:#e5e5e5}.other_ThemeEditor thead>tr.mm-content>th{padding:0 4px;font-size:12px}.other_ThemeEditor td,.other_ThemeEditor th{padding:4px;white-space:nowrap}.other_ThemeEditor thead.mm-label>tr:first-child>th{position:relative;padding-left:29px}.other_ThemeEditor thead.mm-label>tr:first-child>th:before{content:\"[+]\";position:absolute;left:3px;top:3px;color:#404040;height:15px;width:15px;font-family:monospace}.other_ThemeEditor thead.mm-label.max>tr:first-child>th:before{content:\"[-]\"}.other_ThemeEditor tr.sharedPropertyRow>td.label:after{content:\"[+]\";position:absolute;right:10px;top:3px;color:#404040;height:15px;width:15px;font-family:monospace}.other_ThemeEditor tr.sharedPropertyRow>td.label.expanded:after{content:\"[-]\"}.other_ThemeEditor tr.sharedPropertyRow>td.label{position:relative;padding-right:30px;text-decoration:underline}.other_ThemeEditor tr.sharedPropertyRow>td.label:hover{text-decoration:none;cursor:pointer}.other_ThemeEditor tr.propertyRow>td,.other_ThemeEditor tr.propertyRow>th{background-color:#f4f4f4}.other_ThemeEditor tr.propertyRow>td.label{padding-left:24px}.other_ThemeEditor table,.other_ThemeEditor td,.other_ThemeEditor th{border:1px solid #e5e5e5}.other_ThemeEditor .mm-label.min+.mm-content,.other_ThemeEditor .mm-label.min .mm-content{display:none}.mm-label:hover,.other_ThemeEditor .sharedPropertyRow>.te-label{cursor:pointer}.other_ThemeEditor .sharedPropertyRow>.te-label:hover{text-decoration:none}.other_ThemeEditor .propertyRow.shown>.te-label{padding-left:15px}.other_ThemeEditor .propertyRow>td{background-color:#f4f4f4}.other_ThemeEditor input,.other_ThemeEditor select,.other_ThemeEditor textarea{height:30px;float:left}.other_ThemeEditor input,.other_ThemeEditor select{width:150px}.other_ThemeEditor .te-checkbox{width:20px;height:20px;margin:0}.other_ThemeEditor .te-html-color-input{height:30px;width:120px}.other_ThemeEditor .te-html-color-button{width:30px}.other_ThemeEditor .te-html-color-button,.other_ThemeEditor button{background-color:#ccc;border:1px solid #a9a9a9;border-left:0;height:30px;float:left;padding:4px}.other_ThemeEditor .te-html-color-button,.other_ThemeEditor .te-section-table thead,.other_ThemeEditor button{cursor:pointer}.other_ThemeEditor .te-html-color-button:hover,.other_ThemeEditor button:hover{background-color:#bbb}.other_ThemeEditor .te-html-color-button:active,.other_ThemeEditor button:active{background-color:#aaa}.other_ThemeEditor .te-label{white-space:nowrap;width:1%;vertical-align:top}.other_ThemeEditor .te-section-table>tbody>tr:hover{background-color:#f8ff98}.te-section-table thead th{font-weight:700}.te-section-table.expanded>thead>tr>th:after{font:normal normal normal 14px/1 FontAwesome;content:\"ï…‡\";float:right;margin-right:6px;margin-top:4px}.te-section-table.collapsed>thead>tr>th:after{font:normal normal normal 14px/1 FontAwesome;content:\"ï†–\";float:right;margin-right:6px;margin-top:4px}#te-tableModeOptions thead>tr>th,#te-themeEditorOptions thead>tr>th{border:1px solid #6e6e73;background-color:#6e6e73;color:#fafafa}";
styleInject(css$c);

function hasLocalStorage() {
    var mod = "@hpcc-js/other";
    try {
        localStorage.setItem(mod, mod);
        localStorage.removeItem(mod);
        return true;
    }
    catch (e) {
        return false;
    }
}
//  Polyfill for IE in file:// mode  ----
var _localStorage = hasLocalStorage() ? localStorage : {
    getItem: function (id) {
        return undefined;
    }
};
var getThemes = function (idx) {
    if (typeof (window.g_defaultThemes) === "function") {
        window.g_defaultThemes(idx);
    }
    return JSON.parse(_localStorage.getItem("themeEditorThemes") || "{}");
};
var getSerials = function (idx) {
    if (typeof (window.g_defaultSerials) === "function") {
        window.g_defaultSerials(idx);
    }
    return JSON.parse(_localStorage.getItem("themeEditorSerials") || "{}");
};
var getThemeNames = function (idx) {
    var loadedThemes = getThemes();
    var themes = [];
    for (var themeName in loadedThemes) {
        themes.push(themeName);
    }
    if (typeof (idx) !== "undefined" && typeof (themes[idx]) !== "undefined") {
        themes = themes[idx];
    }
    return themes;
};
var getSerialNames = function (idx) {
    var loadedSerials = getSerials();
    var serials = [];
    for (var serialName in loadedSerials) {
        serials.push(serialName);
    }
    if (typeof (idx) !== "undefined" && typeof (serials[idx]) !== "undefined") {
        serials = serials[idx];
    }
    return serials;
};
var tableNeedsRedraw = function (context) {
    var needsRedraw = false;
    if (typeof (context._current_grouping) === "undefined") {
        context._current_grouping = context._group_params_by;
    }
    else if (context._current_grouping !== context._group_params_by) {
        needsRedraw = true;
    }
    if (typeof (context._showing_columns) === "undefined") {
        context._showing_columns = context.showColumns();
    }
    else if (context._showing_columns !== context.showColumns()) {
        needsRedraw = true;
    }
    if (typeof (context._showing_data) === "undefined") {
        context._showing_data = context.showData();
    }
    else if (context._showing_data !== context.showData()) {
        needsRedraw = true;
    }
    return needsRedraw;
};
var camelizeString = function (str) {
    var spacedText = str.split(/(?=[0-9A-Z])/).map(function (n) { return n.length > 1 ? n + " " : n; }).join("");
    return spacedText.replace(/(?:^|\s)\S/g, function (a) { return a.toUpperCase(); });
};
var tableInputHtml = function (rowObj, value, widgetArr, idSuffix) {
    var inputHtml = "";
    var id = "te-input-" + rowObj.id + "-" + idSuffix;
    var inputType;
    if (typeof (rowObj.ext) !== "undefined" && typeof (rowObj.ext.inputType) !== "undefined") {
        inputType = rowObj.ext.inputType;
    }
    if (typeof (rowObj.inputID) !== "undefined") {
        id = rowObj.inputID;
    }
    var dataWIDs = "data-paramid='" + rowObj.id + "' data-wids='" + widgetArr.map(function (w) {
        if (typeof (w.widget) === "object") {
            return w.widget._id;
        }
        else {
            return w;
        }
    }).join(",") + "'";
    switch (rowObj.type) {
        case "boolean":
            var checked = value ? " checked" : "";
            inputHtml = "<input id='" + id + "' " + dataWIDs + " type='checkbox' class='te-checkbox te-input'" + checked + ">";
            break;
        case "number":
            if (typeof (inputType) !== "undefined") {
                if (inputType === "textarea") {
                    inputHtml = "<textarea id='" + id + "' class='te-textarea te-input' " + dataWIDs + ">" + value + "</textarea>";
                }
                else if (inputType === "range") {
                    inputHtml = "<input id='" + id + "' class='te-input' type='range' " + dataWIDs + " value='" + value + "'  min='" + rowObj.ext.min + "' max='" + rowObj.ext.max + "' step='" + rowObj.ext.step + "'>";
                }
            }
            else {
                inputHtml = "<input id='" + id + "' type='text' class='te-text te-input' " + dataWIDs + " value='" + value + "'>";
            }
            break;
        case "string":
            if (typeof (inputType) !== "undefined") {
                if (inputType === "textarea") {
                    inputHtml = "<textarea id='" + id + "' class='te-textarea te-input' " + dataWIDs + ">" + value + "</textarea>";
                }
            }
            else {
                inputHtml = "<input id='" + id + "' type='text' class='te-text te-input' value='" + value + "' " + dataWIDs + ">";
            }
            break;
        case "html-color":
            var valueAttr = value === "" ? "" : " value='" + value + "'";
            inputHtml = "<input id='" + id + "' type='text' class='te-html-color-input te-input' " + dataWIDs + " " + valueAttr + ">";
            inputHtml += "<input type='color' class='te-html-color-button te-input' " + dataWIDs + " " + valueAttr + ">";
            break;
        case "set":
            var options = _options(rowObj, value);
            inputHtml = "<select id='" + id + "' class='te-select te-input'" + dataWIDs + ">" + options + "</select>";
            break;
        case "array":
            inputHtml = "<textarea id='" + id + "' class='te-textarea te-input' data-type='array' " + dataWIDs + ">" + value + "</textarea>";
            break;
        default:
            break;
    }
    if (typeof (rowObj.ext.saveButton) !== "undefined") {
        inputHtml += "<button id='" + rowObj.ext.saveButtonID + "'>" + rowObj.ext.saveButton + "</button>";
    }
    return inputHtml;
    function _options(obj, val) {
        var options = "";
        obj.set.forEach(function (s) {
            var selected = s === val ? " selected" : "";
            options += "<option value='" + s + "'" + selected + ">" + s + "</option>";
        });
        return options;
    }
};
var ThemeEditor = /** @class */ (function (_super) {
    __extends(ThemeEditor, _super);
    function ThemeEditor() {
        var _this = _super.call(this) || this;
        _this._tag = "div";
        _this._current_grouping = undefined;
        _this._showing_columns = undefined;
        _this._showing_data = undefined;
        _this.columns(["Key", "Value"]);
        _this._contentEditors = [];
        _this._showSettings = true;
        _this._defaultThemes = [];
        _this._widgetObjsById = {};
        return _this;
    }
    ThemeEditor.prototype.showSettings = function (_) {
        if (!arguments.length) {
            return this._showSettings;
        }
        this._showSettings = _;
        return this;
    };
    ThemeEditor.prototype.onChange = function (widget, propID) { };
    ThemeEditor.prototype.enter = function (domNode, element) {
        _super.prototype.enter.call(this, domNode, element);
        this._placeholderElement.style("overflow", "auto");
    };
    ThemeEditor.prototype.widgetProperty = function (widget, propID, _) {
        if (_ === undefined) {
            return widget[propID]();
        }
        return widget[propID](_);
    };
    ThemeEditor.prototype.load = function (elmValue) { };
    ThemeEditor.prototype.save = function (themeName) { };
    ThemeEditor.prototype.needsPropTableRedraw = function () {
        var ret = document.getElementById("te-themeEditorOptions") === null;
        return ret;
    };
    ThemeEditor.prototype.update = function (domNode, element) {
        _super.prototype.update.call(this, domNode, element);
        if (tableNeedsRedraw(this)) {
            element.selectAll("#" + this._id + " > table").remove();
        }
        this._current_grouping = this.paramGrouping();
        this._widgetObjsById[this._id] = this;
        this._sharedProperties = this.findSharedProperties(this.data());
        var needsPropertiesTableRedraw = this.needsPropTableRedraw();
        if (needsPropertiesTableRedraw && this.showSettings()) {
            var teParams = discover(this);
            for (var i in teParams) {
                if (teParams[i].ext.tags.indexOf(this.editorComplexity()) !== -1) {
                    var teParamVal = this[teParams[i].id]();
                    if (teParams[i].id === "loadedTheme" || teParams[i].id === "loadedSerial") {
                        teParams[i].inputID = "te-load-theme";
                    }
                    teParams[i].input = tableInputHtml(teParams[i], teParamVal, [this._id], this._id);
                }
                else {
                    delete teParams[i];
                }
            }
            domNode.innerHTML = this.propertiesTableHtml(teParams);
            var evt = document.createEvent("Events");
            evt.initEvent("TE Properties Ready", true, true);
            document.dispatchEvent(evt);
        }
        this.buildTableObjects(domNode, this._sharedProperties);
        this.initFunctionality(domNode);
    };
    ThemeEditor.prototype.exit = function (domNode, element) {
        _super.prototype.exit.call(this, domNode, element);
    };
    ThemeEditor.prototype.click = function (d) {
    };
    ThemeEditor.prototype.propertiesTableHtml = function (editorParams) {
        var tableObj = {
            id: "te-themeEditorOptions",
            label: "Editor Options",
            rowArr: []
        };
        var modeTableObj = {
            id: "te-tableModeOptions",
            label: this.themeMode() ? "Save/Load Theme" : "Save/Load Serial",
            rowArr: []
        };
        for (var i in editorParams) {
            if (this.themeMode()) {
                if (editorParams[i].ext.tags.indexOf("Theme") === -1 && editorParams[i].ext.tags.indexOf("Serial") === -1) {
                    tableObj.rowArr.push({
                        th: camelizeString(editorParams[i].id),
                        td: editorParams[i].input,
                        trClass: "propertyRow"
                    });
                }
                else if (editorParams[i].ext.tags.indexOf("Theme") !== -1) {
                    modeTableObj.rowArr.push({
                        th: camelizeString(editorParams[i].id),
                        td: editorParams[i].input,
                        trClass: "propertyRow"
                    });
                }
            }
            else {
                if (editorParams[i].ext.tags.indexOf("Serial") === -1 && editorParams[i].ext.tags.indexOf("Theme") === -1) {
                    tableObj.rowArr.push({
                        th: camelizeString(editorParams[i].id),
                        td: editorParams[i].input,
                        trClass: "propertyRow"
                    });
                }
                else if (editorParams[i].ext.tags.indexOf("Serial") !== -1) {
                    modeTableObj.rowArr.push({
                        th: camelizeString(editorParams[i].id),
                        td: editorParams[i].input,
                        trClass: "propertyRow"
                    });
                }
            }
        }
        var html = "";
        if (tableObj.rowArr.length > 0) {
            html += this.tableObjHtml(tableObj);
        }
        if (modeTableObj.rowArr.length > 0) {
            html += this.tableObjHtml(modeTableObj);
        }
        return html;
    };
    ThemeEditor.prototype.buildTableObjects = function (targetElement, propObjs) {
        var sectionObjs = {};
        if (this.themeMode()) {
            sectionObjs = {
                chartColorSection: {
                    id: "te-colorOptions",
                    label: "Chart Colors",
                    rowObjArr: []
                },
                surfaceSection: {
                    id: "te-containerOptions",
                    label: "Container Styles/Colors",
                    rowObjArr: []
                },
                fontSection: {
                    id: "te-fontOptions",
                    label: "Font Styles/Colors",
                    rowObjArr: []
                }
            };
        }
        else {
            sectionObjs = {
                nonSurfaceSection: {
                    id: "te-chartOptions",
                    label: "Chart Properties",
                    rowObjArr: []
                }
            };
        }
        for (var p in propObjs) {
            if (this.themeMode()) {
                if (p.toUpperCase().indexOf("FONT") !== -1 && !(propObjs[p].arr[0].widget._class.indexOf("layout_Surface") !== -1 && p.toUpperCase().indexOf("COLOR") !== -1)) {
                    sectionObjs["fontSection"].rowObjArr.push(propObjs[p]);
                }
                else if (p === "paletteID") {
                    sectionObjs["chartColorSection"].rowObjArr.push(propObjs[p]);
                }
                else if (propObjs[p].arr[0].widget._class.indexOf("layout_Surface") !== -1) {
                    sectionObjs["surfaceSection"].rowObjArr.push(propObjs[p]);
                }
            }
            else {
                if (propObjs[p].arr[0].widget._class.indexOf("layout_Surface") === -1) {
                    sectionObjs["nonSurfaceSection"].rowObjArr.push(propObjs[p]);
                }
            }
        }
        var html = "";
        for (var i in sectionObjs) {
            html += this.sharedPropertyTableHtml(sectionObjs[i]);
        }
        targetElement.innerHTML += html;
    };
    ThemeEditor.prototype.initFunctionality = function (elm) {
        var context = this;
        _expandCollapse(elm);
        _inputOnChange(elm);
        _inputOnClick();
        function _inputOnClick(elm2) {
            if (context.showSettings()) {
                var saveBtn = document.getElementById("te-save-button");
                saveBtn.onclick = function (e) {
                    var clickedElm = e.target;
                    var themeName = clickedElm.previousSibling.value;
                    if (themeName.length > 1) {
                        var loadSelect = document.getElementById("te-load-theme");
                        var loadOptions = loadSelect.getElementsByTagName("option");
                        var saveExists = false;
                        for (var i in loadOptions) {
                            var val = loadOptions[i].value;
                            if (val === themeName) {
                                saveExists = true;
                            }
                        }
                        if (!saveExists) {
                            loadSelect.innerHTML += "<option value='" + themeName + "'>" + themeName + "</option>";
                        }
                        clickedElm.previousSibling.value = "";
                        loadSelect.value = themeName;
                    }
                    else {
                        alert("Save Name cannot be empty.");
                    }
                };
            }
        }
        function _inputOnChange(elm2) {
            var teInputs = elm2.getElementsByClassName("te-input");
            for (var i in teInputs) {
                if (isNaN(parseInt(i)))
                    break;
                var inputElm = teInputs[i];
                var inputID = inputElm.getAttribute("id");
                if (inputID === "te-load-theme") {
                    inputElm.onchange = function (e) {
                        var elm3 = e.srcElement;
                        context.load(elm3.value);
                    };
                }
                else if (inputID !== null && inputID.indexOf("te-input-themeMode") !== -1) {
                    inputElm.onchange = function (e) {
                        var elm3 = e.srcElement;
                        context.themeMode(elm3.checked);
                        var name = document.getElementById("te-load-theme");
                        var nameToLoad = name !== null ? name.value : "Default";
                        context.load(nameToLoad);
                    };
                }
                else if (inputElm.tagName === "INPUT" || inputElm.tagName === "SELECT" || inputElm.tagName === "TEXTAREA") {
                    inputElm.onchange = function (e) {
                        var elm3 = e.srcElement;
                        var id = elm3.getAttribute("id");
                        if (elm3.className.split(" ").indexOf("te-html-color-button") !== -1) {
                            id = elm3.previousSibling.getAttribute("id");
                            elm3.previousSibling.value = elm3.value;
                        }
                        var elmType = elm3.getAttribute("type");
                        var splitId = id.split("-");
                        var genericId = splitId.slice(0, splitId.length - 1).join("-") + "-";
                        var widsStr = elm3.getAttribute("data-wids");
                        var paramId = elm3.getAttribute("data-paramid");
                        var widArr = widsStr.split(",");
                        widArr.forEach(function (wid) {
                            var individualId = genericId + wid;
                            var indElm = document.getElementById(individualId);
                            if (elmType === "checkbox") {
                                indElm.checked = elm3.checked;
                                context._widgetObjsById[wid][paramId](elm3.checked);
                            }
                            else if (elm3.getAttribute("data-type") === "array") {
                                indElm.value = elm3.value;
                                try {
                                    context._widgetObjsById[wid][paramId](JSON.parse(elm3.value));
                                }
                                catch (e) { }
                            }
                            else {
                                indElm.value = elm3.value;
                                context._widgetObjsById[wid][paramId](elm3.value);
                                if (indElm.className.split(" ").indexOf("te-html-color-input") !== -1) {
                                    indElm.nextSibling.value = elm3.value;
                                }
                                else if (indElm.className.split(" ").indexOf("te-html-color-button") !== -1) {
                                    indElm.previousSibling.value = elm3.value;
                                }
                            }
                        });
                        context.data().forEach(function (d) {
                            d.render();
                        });
                    };
                }
            }
        }
        function _expandCollapse(elm2) {
            var tableArr = elm2.getElementsByClassName("te-section-table");
            for (var i in tableArr) {
                if (typeof (tableArr[i].getElementsByTagName) === "function") {
                    var thead = tableArr[i].getElementsByTagName("thead");
                    thead[0].onclick = function (e) {
                        var elm3 = e.toElement;
                        if (elm3.tagName === "TH") {
                            elm3 = elm3.parentElement.parentElement;
                        }
                        var parent = elm3.parentElement;
                        var tbodyClass = "";
                        if (parent.className.split(" ").indexOf("expanded") === -1) {
                            parent.className = "te-section-table expanded";
                            tbodyClass = "shown";
                        }
                        else {
                            parent.className = "te-section-table collapsed";
                            tbodyClass = "hidden";
                        }
                        var tbody = parent.getElementsByTagName("tbody");
                        tbody[0].className = tbodyClass;
                    };
                }
            }
            var sharedRowArr = elm2.getElementsByClassName("sharedPropertyRow");
            for (var n in sharedRowArr) {
                if (typeof (sharedRowArr[n].getElementsByClassName) === "function") {
                    var label = sharedRowArr[n].getElementsByClassName("te-label");
                    label[0].onclick = function (e) {
                        var elm3 = e.toElement;
                        var parent = elm3.parentElement;
                        var subRowClass = "";
                        if (parent.className.split(" ").indexOf("expanded") === -1) {
                            parent.className = "sharedPropertyRow expanded";
                            subRowClass = "shown";
                        }
                        else {
                            parent.className = "sharedPropertyRow collapsed";
                            subRowClass = "hidden";
                        }
                        var nextSib = parent.nextSibling;
                        while (nextSib !== null) {
                            if (nextSib.className.split(" ").indexOf("sharedPropertyRow") === -1) {
                                nextSib.className = "propertyRow " + subRowClass;
                                nextSib = nextSib.nextSibling;
                            }
                            else {
                                nextSib = null;
                            }
                        }
                    };
                }
            }
        }
    };
    ThemeEditor.prototype.sharedPropertyTableHtml = function (sectionObj) {
        var tableObj = {
            id: sectionObj.id,
            label: sectionObj.label,
            rowArr: []
        };
        sectionObj.rowObjArr.forEach(function (rowObj) {
            rowObj.arr.forEach(function (widgetObj, widgetIdx) {
                if (widgetIdx === 0) {
                    tableObj.rowArr.push({
                        th: _sharedPropertyLabel(rowObj),
                        td: _sharedPropertyInput(rowObj),
                        trClass: "sharedPropertyRow collapsed"
                    });
                }
                tableObj.rowArr.push({
                    th: _propertyLabel(widgetObj),
                    td: _propertyInput(rowObj, widgetIdx),
                    trClass: "propertyRow hidden"
                });
            });
        });
        return this.tableObjHtml(tableObj);
        function _propertyLabel(widgetObj) {
            var splitClass = widgetObj.widget.classID().split("_");
            var displayClass = splitClass.join("/");
            return displayClass + " <i>[" + widgetObj.widget._id + "]</i>";
        }
        function _sharedPropertyLabel(rowObj) {
            return camelizeString(rowObj.id);
        }
        function _propertyInput(rowObj, idx) {
            var value = _value(rowObj, idx);
            var html = tableInputHtml(rowObj, value, [rowObj.arr[idx]], rowObj.arr[idx].widget._id);
            return html;
            function _value(rowObj2, idx2) {
                var value2 = rowObj2.arr[idx2].widget[rowObj2.id]();
                return value2 !== null ? value2 : "";
            }
        }
        function _sharedPropertyInput(rowObj) {
            var value = _sharedValue(rowObj);
            var html = tableInputHtml(rowObj, value, rowObj.arr, "shared");
            return html;
            function _sharedValue(rowObj2) {
                var value2 = rowObj2.arr[0].widget[rowObj2.id]();
                rowObj2.arr.forEach(function (w, i) {
                    if (value2 !== w.widget[w.id]()) {
                        return "";
                    }
                });
                if (value2 !== null) {
                    if (rowObj2.type === "array") {
                        return JSON.stringify(value2);
                    }
                    return value2;
                }
                return "";
            }
        }
    };
    ThemeEditor.prototype.tableObjHtml = function (tableObj) {
        var html = "<table id='" + tableObj.id + "' class='te-section-table expanded'>";
        html += "<thead><tr><th colspan='2'>" + tableObj.label + "</th></tr></thead>";
        html += "<tbody>";
        tableObj.rowArr.forEach(function (rowObj) {
            html += this.tableRowObjHtml(rowObj);
        }, this);
        html += "</tbody>";
        return html + "</table>";
    };
    ThemeEditor.prototype.tableRowObjHtml = function (rowObj) {
        var html = typeof (rowObj.trClass) !== "undefined" ? "<tr class='" + rowObj.trClass + "'>" : "<tr>";
        html += "<th class='te-label'>" + rowObj.th + "</th>";
        html += "<td>" + rowObj.td + "</td>";
        return html + "</tr>";
    };
    ThemeEditor.prototype.setWidgetObjsById = function (widgetProp) {
        var context = this;
        var val = widgetProp.widget[widgetProp.id]();
        if (widgetProp.type === "widgetArray") {
            val.forEach(function (widget) {
                context._widgetObjsById[widget._id] = widget;
            });
        }
        else if (widgetProp.type === "widget" && val !== null) {
            this._widgetObjsById[val._id] = val;
        }
    };
    ThemeEditor.prototype.checkTagFilter = function (tagArr) {
        var allowTags = ["Basic"];
        var ret = false;
        tagArr.forEach(function (tag) {
            if (allowTags.indexOf(tag) !== -1) {
                ret = true;
            }
        });
        return ret;
    };
    ThemeEditor.prototype.findSharedProperties = function (data) {
        var context = this;
        var propsByID;
        if (typeof (data) !== "undefined" && data.length > 0) {
            var allProps_1 = [];
            propsByID = {};
            var surfacePropsByID_1 = {};
            var nonSurfacePropsByID_1 = {};
            data.forEach(function (widget) {
                var gpResponse = _getParams(widget);
                allProps_1 = allProps_1.concat(gpResponse);
            });
            allProps_1.forEach(function (prop) {
                if (["widget", "widgetArray"].indexOf(prop.type) !== -1) {
                    context.setWidgetObjsById(prop);
                }
                else if (context.checkTagFilter(prop.ext.tags)) {
                    var tempIdx = prop.id;
                    if (prop.widget._class.indexOf("Surface") !== -1) {
                        if (typeof (surfacePropsByID_1[tempIdx]) === "undefined") {
                            surfacePropsByID_1[tempIdx] = { arr: [] };
                        }
                        surfacePropsByID_1[tempIdx].id = prop.id;
                        surfacePropsByID_1[tempIdx].description = prop.description;
                        surfacePropsByID_1[tempIdx].type = prop.type;
                        surfacePropsByID_1[tempIdx].set = prop.set;
                        surfacePropsByID_1[tempIdx].ext = prop.ext;
                        surfacePropsByID_1[tempIdx].arr.push(prop);
                    }
                    else {
                        if (typeof (nonSurfacePropsByID_1[tempIdx]) === "undefined") {
                            nonSurfacePropsByID_1[tempIdx] = { arr: [] };
                        }
                        nonSurfacePropsByID_1[tempIdx].id = prop.id;
                        nonSurfacePropsByID_1[tempIdx].description = prop.description;
                        nonSurfacePropsByID_1[tempIdx].type = prop.type;
                        nonSurfacePropsByID_1[tempIdx].set = prop.set;
                        nonSurfacePropsByID_1[tempIdx].ext = prop.ext;
                        nonSurfacePropsByID_1[tempIdx].arr.push(prop);
                    }
                    if (typeof (propsByID[tempIdx]) === "undefined") {
                        propsByID[tempIdx] = { arr: [] };
                    }
                    propsByID[tempIdx].id = prop.id;
                    propsByID[tempIdx].description = prop.description;
                    propsByID[tempIdx].type = prop.type;
                    propsByID[tempIdx].set = prop.set;
                    propsByID[tempIdx].ext = prop.ext;
                    propsByID[tempIdx].arr.push(prop);
                }
            });
        }
        return propsByID;
        function _getParams(widgetObj, depth) {
            var retArr = [];
            if (widgetObj !== null) {
                var paramArr = discover(widgetObj);
                paramArr.forEach(function (param, i1) {
                    if (typeof (param.ext.tags) !== "undefined") {
                        retArr.push({
                            id: param.id,
                            type: param.type,
                            description: param.description,
                            set: param.set,
                            ext: param.ext,
                            widget: widgetObj
                        });
                    }
                    if (param.type === "widgetArray") {
                        var childWidgetArray = context.widgetProperty(widgetObj, param.id);
                        childWidgetArray.forEach(function (childWidget) {
                            var cwArr = _getParams(childWidget);
                            retArr = retArr.concat(cwArr);
                        });
                    }
                    else if (param.type === "widget") {
                        var childWidget = context.widgetProperty(widgetObj, param.id);
                        var temp = _getParams(childWidget);
                        retArr = retArr.concat(temp);
                    }
                });
            }
            return retArr;
        }
    };
    return ThemeEditor;
}(HTMLWidget));
ThemeEditor.prototype._class += " other_ThemeEditor";
ThemeEditor.prototype.publish("themeMode", true, "boolean", "Edit default values", null, { tags: ["Basic"] });
ThemeEditor.prototype.publish("saveTheme", "", "string", "Save Theme", null, { tags: ["Basic", "Theme"], saveButton: "Save", saveButtonID: "te-save-button" });
ThemeEditor.prototype.publish("loadedTheme", getThemeNames(1), "set", "Loaded Theme", getThemeNames(), { tags: ["Basic", "Theme"] });
ThemeEditor.prototype.publish("saveSerial", "", "string", "Save Serial", null, { tags: ["Basic", "Serial"], saveButton: "Save", saveButtonID: "te-save-button" });
ThemeEditor.prototype.publish("loadedSerial", getSerialNames(0), "set", "Loaded Serial", getSerialNames(), { tags: ["Basic", "Serial"] });
ThemeEditor.prototype.publish("showColumns", true, "boolean", "Show Columns", null, { tags: ["Intermediate"] });
ThemeEditor.prototype.publish("showData", true, "boolean", "Show Data", null, { tags: ["Intermediate"] });
ThemeEditor.prototype.publish("shareCountMin", 1, "number", "Share Count Min", null, { tags: ["Private"] });
ThemeEditor.prototype.publish("paramGrouping", "By Param", "set", "Param Grouping", ["By Param", "By Widget"], { tags: ["Private"] });
ThemeEditor.prototype.publish("editorComplexity", "Basic", "set", "Choose what publish properties to display within the editor.", ["Basic", "Intermediate", "Advanced", "Private"], { tags: ["Private"] });
ThemeEditor.prototype.publish("sectionTitle", "", "string", "Section Title", null, { tags: ["Private"] });
ThemeEditor.prototype.publish("collapsibleSections", true, "boolean", "Collapsible Sections", null, { tags: ["Intermediate"] });
ThemeEditor.prototype.getThemes = getThemes;
ThemeEditor.prototype.getSerials = getSerials;
ThemeEditor.prototype.getDefaultThemes = getThemeNames;
ThemeEditor.prototype.getDefaultSerials = getSerialNames;

export { Audio, AutoCompleteText, BUILD_VERSION, CalendarHeatMap, Column, ColumnDropdown, Comms$1 as Comms, HPCCBadge, HeatMap, Html, IconList, Legend, MorphText, MouseHoverColumn, NestedTable, Opportunity, PKG_NAME, PKG_VERSION, Paginator, Persist, PropertyEditor, RadioCheckbox, Select, Table, ThemeEditor, cache, createConnection, createResult, enableCache, flattenResult };
//# sourceMappingURL=index.es6.js.map
